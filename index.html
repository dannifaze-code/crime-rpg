<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Crime RPG</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #0a0a0a !important;
      background-image: none !important;
      background-size: auto !important;
      color: #e0e0e0;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    /* App Container */
    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
    }

    /* Content Area */
    #content {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 16px;
      padding-bottom: 80px;
    }

    /* Account System Styles */
    .account-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(10, 10, 10, 0.98);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: account-fade-in 0.3s ease-out;
    }

    @keyframes account-fade-in {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .account-container {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 32px 24px;
      max-width: 400px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
    }

    .account-header {
      text-align: center;
      margin-bottom: 24px;
    }

    .account-icon {
      font-size: 48px;
      margin-bottom: 12px;
    }

    .account-title {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .account-subtitle {
      font-size: 13px;
      opacity: 0.7;
      line-height: 1.5;
    }

    .account-form {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .account-input-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .account-label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.8;
    }

    .account-input {
      padding: 12px;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 14px;
      font-family: inherit;
      transition: border-color 0.2s;
    }

    .account-input:focus {
      outline: none;
      border-color: #8ab4f8;
    }

    .account-input.error {
      border-color: #f28b82;
    }

    .account-error {
      font-size: 12px;
      color: #f28b82;
      display: none;
    }

    .account-error.visible {
      display: block;
    }

    .account-hint {
      font-size: 11px;
      opacity: 0.6;
      line-height: 1.4;
    }

    .account-btn {
      padding: 14px 20px;
      background: #2a2a2a;
      border: 1px solid #4a4a4a;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      min-height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .account-btn:hover {
      background: #3a3a3a;
      border-color: #5a5a5a;
    }

    .account-btn:active {
      transform: scale(0.98);
    }

    .account-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .account-btn-primary {
      background: #8ab4f8;
      border-color: #8ab4f8;
      color: #0a0a0a;
    }

    .account-btn-primary:hover {
      background: #9ac4ff;
      border-color: #9ac4ff;
    }

    .account-divider {
      text-align: center;
      margin: 20px 0;
      position: relative;
    }

    .account-divider::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      height: 1px;
      background: #2a2a2a;
    }

    .account-divider-text {
      position: relative;
      display: inline-block;
      padding: 0 12px;
      background: #1a1a1a;
      font-size: 12px;
      opacity: 0.6;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .account-info-box {
      padding: 12px;
      background: rgba(138, 180, 248, 0.1);
      border-left: 3px solid #8ab4f8;
      border-radius: 4px;
      font-size: 12px;
      line-height: 1.5;
      margin-bottom: 16px;
    }

    .account-warning-box {
      padding: 12px;
      background: rgba(253, 214, 99, 0.1);
      border-left: 3px solid #fdd663;
      border-radius: 4px;
      font-size: 12px;
      line-height: 1.5;
      margin-bottom: 16px;
    }

    .account-success-message {
      text-align: center;
      padding: 40px 20px;
    }

    .account-success-icon {
      font-size: 64px;
      margin-bottom: 16px;
    }

    .account-success-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #81c995;
    }

    .account-success-text {
      font-size: 13px;
      opacity: 0.8;
      line-height: 1.5;
      margin-bottom: 24px;
    }

    /* Responsive adjustments */
    @media (max-width: 480px) {
      .account-container {
        padding: 24px 16px;
      }
      
      .account-title {
        font-size: 18px;
      }
    }

    /* Tab Bar */
    #tab-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 64px;
      background: #1a1a1a;
      border-top: 1px solid #2a2a2a;
      display: flex;
      justify-content: space-around;
      align-items: center;
      z-index: 1000;
    }

    .tab {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      min-height: 44px;
      cursor: pointer;
      transition: opacity 0.2s;
      padding: 8px;
    }

    .tab-icon {
      font-size: 24px;
      opacity: 0.5;
      transition: opacity 0.2s;
    }

    .tab-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.5;
      transition: opacity 0.2s;
    }

    .tab.active .tab-icon,
    .tab.active .tab-label {
      opacity: 1;
    }

    .tab:active {
      opacity: 0.7;
    }

    /* Tab Content Styles */
    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Profile Tab - Clean Background (No Grid) */
    #profile-tab {
      position: relative;
      background: #0a0a0a;
    }

    #profile-tab::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      opacity: 0.15;
      pointer-events: none;
      z-index: 0;
      /* Grid pattern completely removed for clean look */
      background: transparent;
    }

    /* Ensure all Profile content appears above the map */
    #profile-tab > * {
      position: relative;
      z-index: 1;
    }

    /* Stats Card Styling */
    .crime-card.card-stats {
      background: linear-gradient(135deg, #1a1a2a 0%, #0f0f1a 100%);
      cursor: pointer;
    }

    .crime-card.card-stats .crime-card-icon {
      filter: drop-shadow(0 2px 4px rgba(138, 180, 248, 0.4));
    }

    .crime-card.card-stats:hover {
      border-color: #8ab4f8;
      box-shadow: 
        0 8px 16px rgba(0, 0, 0, 0.6),
        0 0 0 2px rgba(138, 180, 248, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    /* Heat Log Card Styling */
    .crime-card.card-heat-log {
      background: linear-gradient(135deg, #2a1a1a 0%, #1a0a0a 100%);
      cursor: pointer;
    }

    .crime-card.card-heat-log .crime-card-icon {
      filter: drop-shadow(0 2px 4px rgba(242, 139, 130, 0.4));
    }

    .crime-card.card-heat-log .crime-card-value {
      color: #f28b82;
      font-size: 14px;
      font-weight: 500;
    }

    .crime-card.card-heat-log:hover {
      border-color: #f28b82;
      box-shadow: 
        0 8px 16px rgba(0, 0, 0, 0.6),
        0 0 0 2px rgba(242, 139, 130, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    /* Expense Log Card Styling */
    .crime-card.card-expense-log {
      background: linear-gradient(135deg, #1a1a0f 0%, #0f0f0a 100%);
      cursor: pointer;
    }

    .crime-card.card-expense-log .crime-card-icon {
      filter: drop-shadow(0 2px 4px rgba(129, 201, 149, 0.4));
    }

    .crime-card.card-expense-log .crime-card-value {
      color: #fdd663;
      font-size: 14px;
      font-weight: 500;
    }

    .crime-card.card-expense-log:hover {
      border-color: #fdd663;
      box-shadow: 
        0 8px 16px rgba(0, 0, 0, 0.6),
        0 0 0 2px rgba(253, 214, 99, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    /* Players Online Card Styling */
    .crime-card.card-players-online {
      background: linear-gradient(135deg, #1a2a1a 0%, #0f1a0f 100%);
      cursor: pointer;
    }

    .crime-card.card-players-online .crime-card-value {
      display: flex;
      align-items: center;
      gap: 6px;
      color: #81c995;
      font-size: 14px;
      font-weight: 500;
    }

    .online-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #81c995;
      box-shadow: 0 0 8px rgba(129, 201, 149, 0.6);
      animation: pulse-green 2s ease-in-out infinite;
    }

    @keyframes pulse-green {
      0%, 100% { 
        opacity: 1;
        transform: scale(1);
      }
      50% { 
        opacity: 0.6;
        transform: scale(1.2);
      }
    }

    .crime-card.card-players-online:hover {
      border-color: #81c995;
      box-shadow: 
        0 8px 16px rgba(0, 0, 0, 0.6),
        0 0 0 2px rgba(129, 201, 149, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    /* Leaderboard Card Styling */
    .crime-card.card-leaderboard {
      background: linear-gradient(135deg, #2a2a1a 0%, #1a1a0f 100%);
      cursor: pointer;
      border-color: rgba(253, 214, 99, 0.2);
    }

    .crime-card.card-leaderboard .crime-card-icon {
      animation: trophy-shine 2s ease-in-out infinite;
      font-size: 36px;
      filter: drop-shadow(0 0 8px rgba(253, 214, 99, 0.6)) 
              drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
    }

    @keyframes trophy-shine {
      0%, 100% { 
        filter: drop-shadow(0 0 6px rgba(253, 214, 99, 0.5)) 
                drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
        transform: scale(1);
      }
      50% { 
        filter: drop-shadow(0 0 12px rgba(253, 214, 99, 0.8)) 
                drop-shadow(0 2px 8px rgba(253, 214, 99, 0.4));
        transform: scale(1.05);
      }
    }

    .crime-card.card-leaderboard .crime-card-value {
      color: #fdd663;
      font-size: 14px;
      font-weight: 500;
    }

    .crime-card.card-leaderboard:hover {
      border-color: #fdd663;
      box-shadow: 
        0 8px 16px rgba(0, 0, 0, 0.6),
        0 0 0 2px rgba(253, 214, 99, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    /* Chat System Styles */
    .chat-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(10, 10, 10, 0.95);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      animation: chat-fade-in 0.3s ease-out;
    }

    @keyframes chat-fade-in {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .chat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px;
      background: #1a1a1a;
      border-bottom: 1px solid #2a2a2a;
    }

    .chat-title {
      font-size: 18px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .chat-close-btn {
      background: transparent;
      border: 1px solid #2a2a2a;
      color: #e0e0e0;
      font-size: 18px;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 44px;
      min-height: 44px;
    }

    .chat-close-btn:hover {
      background: #2a2a2a;
      border-color: #4a4a4a;
    }

    .chat-messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .chat-message {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-width: 80%;
      animation: message-slide-in 0.2s ease-out;
    }

    @keyframes message-slide-in {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .chat-message.own {
      align-self: flex-end;
    }

    .chat-message.other {
      align-self: flex-start;
    }

    .chat-message-header {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      opacity: 0.7;
    }

    .chat-message.own .chat-message-header {
      flex-direction: row-reverse;
    }

    .chat-message-username {
      font-weight: 600;
    }

    .chat-message-time {
      font-size: 10px;
    }

    .chat-message-bubble {
      padding: 10px 14px;
      border-radius: 12px;
      word-wrap: break-word;
      line-height: 1.4;
      font-size: 14px;
    }

    .chat-message.own .chat-message-bubble {
      background: #8ab4f8;
      color: #0a0a0a;
      border-bottom-right-radius: 4px;
    }

    .chat-message.other .chat-message-bubble {
      background: #2a2a2a;
      color: #e0e0e0;
      border-bottom-left-radius: 4px;
    }

    .chat-input-container {
      padding: 16px;
      background: #1a1a1a;
      border-top: 1px solid #2a2a2a;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .chat-input {
      flex: 1;
      padding: 12px;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 14px;
      font-family: inherit;
      resize: none;
      max-height: 100px;
      min-height: 44px;
    }

    .chat-input:focus {
      outline: none;
      border-color: #8ab4f8;
    }

    .chat-send-btn {
      background: #8ab4f8;
      border: 1px solid #8ab4f8;
      color: #0a0a0a;
      font-size: 20px;
      padding: 12px 16px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 44px;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .chat-send-btn:hover {
      background: #9ac4ff;
      border-color: #9ac4ff;
    }

    .chat-send-btn:active {
      transform: scale(0.95);
    }

    .chat-send-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .chat-empty {
      text-align: center;
      padding: 60px 20px;
      opacity: 0.5;
    }

    .chat-empty-icon {
      font-size: 48px;
      margin-bottom: 12px;
    }

    .chat-empty-text {
      font-size: 14px;
    }

    /* Player Profile Modal */
    .player-profile-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(10, 10, 10, 0.95);
      z-index: 1100;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      animation: modal-fade-in 0.3s ease-out;
    }

    .player-profile-content {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 24px;
      max-width: 400px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
    }

    .player-profile-header {
      text-align: center;
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid #2a2a2a;
    }

    .player-profile-avatar {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      background: linear-gradient(135deg, #8ab4f8 0%, #5a84c8 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      font-weight: 700;
      color: #0a0a0a;
      margin: 0 auto 12px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
    }

    .player-profile-username {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .player-profile-status {
      font-size: 12px;
      opacity: 0.7;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .player-profile-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }

    .player-profile-stat {
      background: #0a0a0a;
      padding: 12px;
      border-radius: 4px;
      border: 1px solid #2a2a2a;
      text-align: center;
    }

    .player-profile-stat-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.6;
      margin-bottom: 4px;
    }

    .player-profile-stat-value {
      font-size: 16px;
      font-weight: 600;
    }

    .player-profile-actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .player-action-btn {
      padding: 14px 20px;
      background: #2a2a2a;
      border: 1px solid #4a4a4a;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      min-height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .player-action-btn:hover {
      background: #3a3a3a;
      border-color: #5a5a5a;
    }

    .player-action-btn:active {
      transform: scale(0.98);
    }

    .player-action-btn.primary {
      background: #8ab4f8;
      border-color: #8ab4f8;
      color: #0a0a0a;
    }

    .player-action-btn.primary:hover {
      background: #9ac4ff;
      border-color: #9ac4ff;
    }

    /* Leaderboard Styles */
    .leaderboard-container {
      margin: 20px 0;
      padding: 16px;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
    }
    
    .leaderboard-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 400px;
      overflow-y: auto;
      padding-right: 4px;
    }
    
    .leaderboard-entry {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      transition: all 0.2s ease;
    }
    
    .leaderboard-entry:hover {
      background: #222222;
      border-color: #3a3a3a;
    }
    
    .leaderboard-current-player {
      background: rgba(138, 180, 248, 0.1);
      border: 2px solid #8ab4f8;
      box-shadow: 0 0 12px rgba(138, 180, 248, 0.3);
      animation: leaderboard-pulse 2s ease-in-out infinite;
    }
    
    @keyframes leaderboard-pulse {
      0%, 100% {
        box-shadow: 0 0 12px rgba(138, 180, 248, 0.3);
      }
      50% {
        box-shadow: 0 0 16px rgba(138, 180, 248, 0.5);
      }
    }
    
    .leaderboard-rank {
      font-size: 24px;
      min-width: 40px;
      text-align: center;
      flex-shrink: 0;
    }
    
    .leaderboard-player-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .leaderboard-username {
      font-size: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .player-badge {
      font-size: 9px;
      padding: 2px 6px;
      background: #8ab4f8;
      color: #0a0a0a;
      border-radius: 3px;
      font-weight: 700;
      letter-spacing: 0.5px;
    }
    
    .leaderboard-stats {
      display: flex;
      gap: 12px;
      font-size: 11px;
    }
    
    .leaderboard-stat {
      display: flex;
      align-items: center;
      gap: 4px;
      opacity: 0.8;
    }
    
    .leaderboard-stat-icon {
      font-size: 12px;
    }
    
    .leaderboard-empty {
      text-align: center;
      padding: 40px 20px;
    }
    
    .leaderboard-empty-icon {
      font-size: 64px;
      margin-bottom: 16px;
      opacity: 0.5;
    }
    
    .leaderboard-empty-text {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      opacity: 0.8;
    }
    
    .leaderboard-empty-subtext {
      font-size: 13px;
      opacity: 0.6;
    }

    /* Main Profile Card on Crime Board */
    .crime-card.card-profile {
      grid-column: span 2;
      min-height: 140px;
      background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 16px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .crime-card.card-profile:hover {
      transform: scale(1.03) rotate(0deg) translateY(-2px);
      box-shadow: 
        0 8px 16px rgba(0, 0, 0, 0.6),
        0 0 0 2px rgba(138, 180, 248, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    .crime-card.card-profile:active {
      transform: scale(0.98) rotate(0deg);
    }

    .profile-card-avatar {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      background: linear-gradient(135deg, #8ab4f8 0%, #5a84c8 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      font-weight: 700;
      color: #0a0a0a;
      flex-shrink: 0;
      box-shadow: 
        0 4px 8px rgba(0, 0, 0, 0.4),
        inset 0 -2px 4px rgba(0, 0, 0, 0.2);
    }

    .profile-card-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .profile-card-name {
      font-size: 18px;
      font-weight: 700;
      color: #e0e0e0;
      margin-bottom: 4px;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    .profile-card-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      padding: 4px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .profile-card-row:last-child {
      border-bottom: none;
    }

    .profile-card-label {
      opacity: 0.7;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .profile-card-value {
      font-weight: 600;
      color: #8ab4f8;
    }

    @media (max-width: 480px) {
      .crime-card.card-profile {
        grid-column: span 2;
      }
      
      .profile-card-avatar {
        width: 56px;
        height: 56px;
        font-size: 28px;
      }
      
      .profile-card-name {
        font-size: 16px;
      }
    }

    /* Crime Board Card System */
    .crime-board {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 16px;
      margin-top: 20px;
      padding: 0 4px;
    }

    .crime-card {
      background: linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%);
      border: 1px solid #2a2a2a;
      border-radius: 6px;
      padding: 16px 12px;
      min-height: 120px;
      position: relative;
      cursor: pointer;
      user-select: none;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow: 
        0 4px 8px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
      transform-origin: center;
      -webkit-tap-highlight-color: transparent;
    }

    /* Pinned card variations with slight rotation */
    .crime-card:nth-child(1) {
      transform: rotate(-1deg);
    }

    .crime-card:nth-child(2) {
      transform: rotate(0.5deg);
    }

    .crime-card:nth-child(3) {
      transform: rotate(-0.5deg);
    }

    .crime-card:nth-child(4) {
      transform: rotate(1deg);
    }

    .crime-card:nth-child(5) {
      transform: rotate(-0.8deg);
    }

    .crime-card:nth-child(6) {
      transform: rotate(0.3deg);
    }

    /* Hover/tap states */
    .crime-card:hover {
      transform: scale(1.02) rotate(0deg) translateY(-2px);
      box-shadow: 
        0 8px 16px rgba(0, 0, 0, 0.6),
        0 0 0 2px rgba(138, 180, 248, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      border-color: #3a3a3a;
      z-index: 10;
    }

    .crime-card:active {
      transform: scale(0.98) rotate(0deg);
      box-shadow: 
        0 2px 4px rgba(0, 0, 0, 0.4),
        0 0 0 3px rgba(138, 180, 248, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
      transition: all 0.1s ease;
    }

    /* Card header with icon */
    .crime-card-icon {
      font-size: 32px;
      margin-bottom: 8px;
      display: block;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
    }

    .crime-card-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.6;
      margin-bottom: 4px;
    }

    .crime-card-value {
      font-size: 20px;
      font-weight: 600;
      line-height: 1.2;
      color: #e0e0e0;
    }

    /* Specialty card colors */
    .crime-card.card-cash .crime-card-value {
      color: #81c995;
    }

    .crime-card.card-heat .crime-card-value {
      color: #f28b82;
    }

    .crime-card.card-xp .crime-card-value {
      color: #8ab4f8;
    }

    .crime-card.card-rep .crime-card-value {
      color: #fdd663;
    }

    /* Tape effect for pinned look */
    .crime-card::before {
      content: '';
      position: absolute;
      top: -6px;
      right: 20%;
      width: 40px;
      height: 12px;
      background: rgba(253, 214, 99, 0.15);
      border: 1px solid rgba(253, 214, 99, 0.1);
      transform: rotate(-5deg);
      border-radius: 1px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    /* Stats card with sub-items */
    .crime-card-stats {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 4px;
    }

    .crime-card-stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      padding: 4px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .crime-card-stat-row:last-child {
      border-bottom: none;
    }

    .crime-card-stat-label {
      opacity: 0.7;
      font-size: 11px;
    }

    .crime-card-stat-value {
      font-weight: 600;
      color: #8ab4f8;
    }

    /* Mobile optimizations */
    @media (max-width: 480px) {
      .crime-board {
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
      }

      .crime-card {
        min-height: 110px;
        padding: 14px 10px;
      }

      .crime-card-icon {
        font-size: 28px;
      }

      .crime-card-value {
        font-size: 18px;
      }
    }

    /* Profile Tab */
    .stat-grid {
      display: grid;
      gap: 12px;
      margin-top: 16px;
    }

    .stat-card {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      padding: 16px;
      border-radius: 4px;
    }

    .stat-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.6;
      margin-bottom: 8px;
    }

    .stat-value {
      font-size: 24px;
      font-weight: 600;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      padding: 12px 0;
      border-bottom: 1px solid #2a2a2a;
    }

    .stat-row:last-child {
      border-bottom: none;
    }

    /* Placeholder */
    .placeholder {
      text-align: center;
      padding: 40px 20px;
      opacity: 0.5;
    }

    .placeholder-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }

    .placeholder-text {
      font-size: 14px;
    }

    /* Header */
    .page-header {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 1px solid #2a2a2a;
    }

    /* City Map - Clean Background (No Grid) */
    #city-map {
      position: relative;
      width: 100%;
      aspect-ratio: 9 / 16;
      max-height: calc(100vh - 140px);
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      overflow: hidden;
      margin: 0 auto;
    }
    
    /* Remove any grid patterns from Turf tab */
    #turf-tab {
      background: transparent;
    }
    
    #turf-tab::before,
    #turf-tab::after {
      display: none;
    }
    
    /* CRITICAL: Keep icons within map bounds */
    #map-icons {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      pointer-events: none;
    }
    
    #map-icons > * {
      pointer-events: auto;
    }
    
    /* DIAGNOSTIC: Remove any potential grid-creating styles */
    #tile-layer,
    #tile-layer *,
    #city-map,
    #city-map * {
      border: none !important;
      outline: none !important;
      box-shadow: none !important;
    }
    
    /* Force SVG paths to have no stroke */
    svg path,
    svg rect {
      stroke: none !important;
      stroke-width: 0 !important;
    }

    #map-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    #map-icons {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .map-icon {
      position: absolute;
      font-size: 40px;
      transform: translate(-50%, -50%);
      transition: all 0.3s ease;
      pointer-events: auto;
      cursor: pointer;
      user-select: none;
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.8));
    }

    .map-icon.dormant {
      opacity: 1;
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.8)) brightness(0.9);
    }

    .map-icon.active {
      opacity: 1;
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.8)) brightness(1.1);
      animation: icon-pulse 3s ease-in-out infinite;
    }

    @keyframes icon-pulse {
      0%, 100% {
        transform: translate(-50%, -50%) scale(1);
      }
      50% {
        transform: translate(-50%, -50%) scale(1.05);
      }
    }

    /* Icon label tooltip */
    .map-icon::after {
      content: attr(data-label);
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 8px;
      background: rgba(26, 26, 26, 0.95);
      border: 1px solid #2a2a2a;
      border-radius: 3px;
      font-size: 10px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      margin-top: 4px;
    }

    .map-icon:hover::after {
      opacity: 1;
    }

    /* Safe house icon never dims */
    .map-icon[data-type="safeHouse"] {
      opacity: 1;
      filter: none;
      animation: none;
    }

    /* Interactive Building Icons - Mobile Optimized */
    .building-icon {
      cursor: pointer;
      z-index: 5;
      transition: transform 0.12s ease, filter 0.12s ease;
      /* Touch-friendly tap area */
      min-width: 44px;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .building-icon:hover {
      z-index: 100;
    }

    .building-icon:active {
      transform: translate(-50%, -70%) scale(1.05) !important;
    }

    /* 2.5D Building Styles */
    .building-3d {
      pointer-events: auto;
    }
    
    .building-3d svg {
      display: block;
      overflow: visible;
    }
    
    /* Building type specific glow on hover/touch */
    .building-3d[data-type="gun_shop"]:hover,
    .building-3d[data-type="gun_shop"]:active {
      filter: brightness(1.2) drop-shadow(0 0 6px rgba(242, 139, 130, 0.6));
    }

    .building-3d[data-type="chop_shop"]:hover,
    .building-3d[data-type="chop_shop"]:active {
      filter: brightness(1.2) drop-shadow(0 0 6px rgba(138, 180, 248, 0.6));
    }

    .building-3d[data-type="casino"]:hover,
    .building-3d[data-type="casino"]:active {
      filter: brightness(1.2) drop-shadow(0 0 8px rgba(253, 214, 99, 0.7));
    }

    .building-3d[data-type="nightclub"]:hover,
    .building-3d[data-type="nightclub"]:active {
      filter: brightness(1.2) drop-shadow(0 0 6px rgba(186, 130, 245, 0.6));
    }

    .building-3d[data-type="safehouse"]:hover,
    .building-3d[data-type="safehouse"]:active {
      filter: brightness(1.2) drop-shadow(0 0 6px rgba(129, 201, 149, 0.6));
    }

    /* Character Sprite */
    .character-icon {
      position: absolute;
      font-size: 28px;
      transform: translate(-50%, -50%);
      z-index: 10;
      animation: idle-sway 3s ease-in-out infinite;
    }

    @keyframes idle-sway {
      0%, 100% {
        transform: translate(-50%, -50%) rotate(-2deg);
      }
      50% {
        transform: translate(-50%, -50%) rotate(2deg);
      }
    }

    .character-silhouette {
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
    }

    /* Status Indicator */
    .status-indicator {
      position: absolute;
      top: -18px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 20px;
      z-index: 11;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .status-indicator.laying_low {
      opacity: 0.6;
      filter: grayscale(50%);
    }

    .status-indicator.active {
      opacity: 1;
      animation: status-pulse 2s ease-in-out infinite;
    }

    @keyframes status-pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.7;
      }
    }

    /* Status Controls */
    .status-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      padding: 8px;
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
    }

    .status-btn {
      flex: 1;
      padding: 12px;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      min-height: 44px;
    }

    .status-btn:active {
      transform: scale(0.98);
    }

    .status-btn.selected {
      background: #2a2a2a;
      border-color: #4a4a4a;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .status-btn.laying_low.selected {
      color: #8ab4f8;
    }

    .status-btn.active-status.selected {
      color: #f28b82;
    }

    /* Free Roam Controls */
    .roam-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
      padding: 8px;
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      position: relative;
    }

    .roam-btn {
      flex: 1;
      padding: 10px;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      min-height: 44px;
    }

    .roam-btn:active {
      transform: scale(0.98);
    }

    .roam-btn.active {
      background: #2a2a2a;
      border-color: #4a4a4a;
      color: #8ab4f8;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .map-refresh-btn {
      position: absolute;
      top: 50%;
      right: 8px;
      transform: translateY(-50%);
      width: 36px;
      height: 36px;
      padding: 0;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      color: #8ab4f8;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .map-refresh-btn:hover {
      background: #1a1a1a;
      border-color: #4a4a4a;
    }
    
    .map-refresh-btn:active {
      transform: translateY(-50%) scale(0.95);
    }
    
    .map-refresh-btn.spinning {
      animation: spin 0.5s ease-in-out;
    }
    
    @keyframes spin {
      from { transform: translateY(-50%) rotate(0deg); }
      to { transform: translateY(-50%) rotate(360deg); }
    }

    /* Event Notification */
    .event-notification {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(26, 26, 26, 0.95);
      border: 1px solid #2a2a2a;
      padding: 12px 16px;
      border-radius: 4px;
      font-size: 13px;
      z-index: 100;
      max-width: 80%;
      text-align: center;
      animation: event-fade-in 0.3s ease-out;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }

    @keyframes event-fade-in {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }

    /* Floating Pickups */
    .floating-pickup {
      position: absolute;
      font-size: 20px;
      pointer-events: none;
      animation: pickup-float 2s ease-out forwards;
      z-index: 50;
    }

    @keyframes pickup-float {
      0% {
        opacity: 1;
        transform: translate(-50%, -50%) translateY(0);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) translateY(-40px);
      }
    }

    /* Death Overlay */
    .death-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 64px;
      background: rgba(10, 10, 10, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 200;
      animation: death-fade-in 0.5s ease-out;
    }

    @keyframes death-fade-in {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .death-icon {
      font-size: 72px;
      margin-bottom: 20px;
      animation: death-pulse 1.5s ease-in-out infinite;
    }

    @keyframes death-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .death-message {
      font-size: 18px;
      margin-bottom: 24px;
      opacity: 0.9;
    }

    .respawn-btn {
      padding: 14px 28px;
      background: #2a2a2a;
      border: 1px solid #4a4a4a;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      min-height: 44px;
    }

    .respawn-btn:hover {
      background: #3a3a3a;
      border-color: #5a5a5a;
    }

    .respawn-btn:active {
      transform: scale(0.98);
    }

    /* Event Modal */
    .event-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 64px;
      background: rgba(10, 10, 10, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 150;
      animation: modal-fade-in 0.3s ease-out;
      padding: 16px;
    }

    @keyframes modal-fade-in {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    .event-modal-content {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 24px;
      max-width: 400px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
    }

    .event-modal-icon {
      font-size: 56px;
      text-align: center;
      margin-bottom: 16px;
    }

    .event-modal-title {
      font-size: 18px;
      font-weight: 600;
      text-align: center;
      margin-bottom: 12px;
    }

    .event-modal-description {
      font-size: 14px;
      opacity: 0.8;
      text-align: center;
      margin-bottom: 24px;
      line-height: 1.5;
    }

    .event-choices {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .choice-btn {
      padding: 14px 16px;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: left;
      min-height: 44px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .choice-btn:hover {
      background: #1a1a1a;
      border-color: #3a3a3a;
    }

    .choice-btn:active {
      transform: scale(0.98);
    }

    .choice-icon {
      font-size: 20px;
      flex-shrink: 0;
    }

    .choice-text {
      flex: 1;
    }

    /* Outcome Display */
    .outcome-display {
      text-align: center;
      padding: 20px;
    }

    .outcome-icon {
      font-size: 48px;
      margin-bottom: 12px;
    }

    .outcome-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .outcome-description {
      font-size: 13px;
      opacity: 0.8;
      margin-bottom: 20px;
      line-height: 1.4;
    }

    .outcome-btn {
      padding: 12px 24px;
      background: #2a2a2a;
      border: 1px solid #4a4a4a;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      min-height: 44px;
    }

    .outcome-btn:hover {
      background: #3a3a3a;
      border-color: #5a5a5a;
    }

    .outcome-btn:active {
      transform: scale(0.98);
    }

    .outcome-success {
      color: #81c995;
    }

    .outcome-danger {
      color: #f28b82;
    }

    .outcome-warning {
      color: #fdd663;
    }

    /* Heat Indicator */
    .heat-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      margin-bottom: 12px;
    }

    .heat-icon {
      font-size: 20px;
    }

    .heat-bar-container {
      flex: 1;
      height: 8px;
      background: #0a0a0a;
      border-radius: 4px;
      overflow: hidden;
      border: 1px solid #2a2a2a;
    }

    .heat-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #fdd663 0%, #f28b82 100%);
      transition: width 0.3s ease;
      border-radius: 4px;
    }

    .heat-value {
      font-size: 12px;
      opacity: 0.8;
      min-width: 40px;
      text-align: right;
    }

    /* Jail Overlay */
    .jail-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 64px;
      background: rgba(10, 10, 10, 0.98);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 200;
      animation: jail-fade-in 0.5s ease-out;
      padding: 20px;
    }

    @keyframes jail-fade-in {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .jail-icon {
      font-size: 72px;
      margin-bottom: 20px;
      animation: jail-shake 2s ease-in-out infinite;
    }

    @keyframes jail-shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-3px); }
      75% { transform: translateX(3px); }
    }

    .jail-title {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 12px;
      color: #f28b82;
    }

    .jail-message {
      font-size: 14px;
      opacity: 0.8;
      margin-bottom: 20px;
      text-align: center;
      max-width: 300px;
      line-height: 1.5;
    }

    .jail-timer {
      font-size: 32px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #8ab4f8;
      font-family: 'Courier New', monospace;
    }

    .jail-timer-label {
      font-size: 12px;
      opacity: 0.6;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* XP Notification */
    .xp-notification {
      position: fixed;
      top: 80px;
      right: 20px;
      background: rgba(26, 26, 26, 0.95);
      border: 1px solid #2a2a2a;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 13px;
      z-index: 100;
      animation: xp-slide-in 0.3s ease-out;
      pointer-events: none;
    }

    @keyframes xp-slide-in {
      from {
        opacity: 0;
        transform: translateX(20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .xp-positive {
      color: #81c995;
    }

    .xp-negative {
      color: #f28b82;
    }

    /* Gang Tab */
    .gang-container {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .gang-header {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 20px;
      text-align: center;
    }

    .gang-flag {
      font-size: 48px;
      margin-bottom: 12px;
    }

    .gang-name {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .gang-role {
      font-size: 12px;
      opacity: 0.7;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .gang-stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }

    .gang-stat-card {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 16px;
      text-align: center;
    }

    .gang-stat-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.6;
      margin-bottom: 8px;
    }

    .gang-stat-value {
      font-size: 20px;
      font-weight: 600;
    }

    .gang-section {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 16px;
    }

    .gang-section-title {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.8;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid #2a2a2a;
    }

    .gang-member-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .gang-member {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
    }

    .gang-member-name {
      font-size: 14px;
    }

    .gang-member-role {
      font-size: 11px;
      opacity: 0.6;
      padding: 3px 8px;
      background: #2a2a2a;
      border-radius: 3px;
    }

    .gang-property-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .gang-property {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
    }

    .property-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .property-name {
      font-size: 14px;
    }

    .property-income {
      font-size: 11px;
      opacity: 0.6;
      color: #81c995;
    }

    .property-icon {
      font-size: 24px;
    }

    /* Gang Creation */
    .no-gang-message {
      text-align: center;
      padding: 40px 20px;
      opacity: 0.7;
    }

    .no-gang-icon {
      font-size: 64px;
      margin-bottom: 16px;
    }

    .no-gang-text {
      font-size: 14px;
      margin-bottom: 24px;
      line-height: 1.5;
    }

    .gang-action-buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-width: 300px;
      margin: 0 auto;
    }

    .gang-action-btn {
      padding: 14px 20px;
      background: #2a2a2a;
      border: 1px solid #4a4a4a;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .gang-action-btn:hover {
      background: #3a3a3a;
      border-color: #5a5a5a;
    }

    .gang-action-btn:active {
      transform: scale(0.98);
    }

    /* Gang Creation Modal */
    .gang-creation-form {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .form-label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.8;
    }

    .form-input {
      padding: 12px;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 14px;
      font-family: inherit;
    }

    .form-input:focus {
      outline: none;
      border-color: #4a4a4a;
    }

    .flag-selector {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;
    }

    .flag-option {
      padding: 12px;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      font-size: 24px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .flag-option:hover {
      background: #1a1a1a;
    }

    .flag-option.selected {
      background: #2a2a2a;
      border-color: #4a4a4a;
      box-shadow: 0 0 8px rgba(138, 180, 248, 0.3);
    }

    .color-selector {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }

    .color-option {
      padding: 16px;
      border: 2px solid #2a2a2a;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .color-option.selected {
      border-color: #4a4a4a;
      box-shadow: 0 0 8px rgba(138, 180, 248, 0.3);
    }

    .form-cost {
      font-size: 12px;
      opacity: 0.7;
      color: #f28b82;
    }

    .gang-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 300px;
      overflow-y: auto;
    }

    .gang-list-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .gang-list-item:hover {
      background: #1a1a1a;
      border-color: #3a3a3a;
    }

    .gang-list-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .gang-list-flag {
      font-size: 24px;
    }

    .gang-list-details {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .gang-list-name {
      font-size: 14px;
      font-weight: 500;
    }

    .gang-list-members {
      font-size: 11px;
      opacity: 0.6;
    }

    /* Gang Relations */
    .relations-section {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 16px;
      margin-top: 16px;
    }

    .relation-card {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 12px;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      margin-bottom: 12px;
    }

    .relation-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .relation-gang-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .relation-flag {
      font-size: 24px;
    }

    .relation-name {
      font-size: 14px;
      font-weight: 500;
    }

    .relation-status {
      padding: 4px 10px;
      border-radius: 3px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .relation-status.neutral {
      background: #2a2a2a;
      color: #e0e0e0;
    }

    .relation-status.war {
      background: #5a1a1a;
      color: #f28b82;
      animation: war-pulse 2s ease-in-out infinite;
    }

    @keyframes war-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .relation-heat-bar {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .heat-bar-small {
      flex: 1;
      height: 6px;
      background: #0a0a0a;
      border-radius: 3px;
      overflow: hidden;
      border: 1px solid #2a2a2a;
    }

    .heat-bar-small-fill {
      height: 100%;
      background: linear-gradient(90deg, #fdd663 0%, #f28b82 100%);
      transition: width 0.3s ease;
    }

    .heat-value-small {
      font-size: 11px;
      opacity: 0.7;
      min-width: 35px;
      text-align: right;
    }

    .relation-actions {
      display: flex;
      gap: 8px;
    }

    .raid-btn {
      flex: 1;
      padding: 10px;
      background: #2a2a2a;
      border: 1px solid #4a4a4a;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      min-height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .raid-btn:hover {
      background: #3a3a3a;
      border-color: #5a5a5a;
    }

    .raid-btn:active {
      transform: scale(0.98);
    }

    .raid-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* War Log */
    .war-log-section {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 16px;
      margin-top: 16px;
    }

    .war-log-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 300px;
      overflow-y: auto;
    }

    .war-log-entry {
      padding: 10px;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      font-size: 12px;
      line-height: 1.4;
    }

    .war-log-timestamp {
      font-size: 10px;
      opacity: 0.5;
      margin-top: 4px;
    }

    .war-log-empty {
      text-align: center;
      opacity: 0.5;
      padding: 20px;
      font-size: 13px;
    }

    /* Raid Result Modal */
    .raid-result {
      text-align: center;
      padding: 20px;
    }

    .raid-result-icon {
      font-size: 56px;
      margin-bottom: 16px;
    }

    .raid-result-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 12px;
    }

    .raid-result-description {
      font-size: 13px;
      opacity: 0.8;
      margin-bottom: 16px;
      line-height: 1.5;
    }

    .raid-result-rewards {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 20px;
      padding: 12px;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
    }

    .reward-item {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
    }

    .reward-label {
      opacity: 0.7;
    }

    .reward-value {
      font-weight: 600;
    }

    .reward-positive {
      color: #81c995;
    }

    .reward-negative {
      color: #f28b82;
    }

    /* Global Heat Indicator */
    .global-heat-display {
      position: fixed;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(26, 26, 26, 0.95);
      border: 1px solid #2a2a2a;
      padding: 10px 16px;
      border-radius: 4px;
      z-index: 120;
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 200px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }

    .global-heat-icon {
      font-size: 20px;
    }

    .global-heat-bar-container {
      flex: 1;
      height: 8px;
      background: #0a0a0a;
      border-radius: 4px;
      overflow: hidden;
      border: 1px solid #2a2a2a;
    }

    .global-heat-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #81c995 0%, #fdd663 50%, #f28b82 100%);
      transition: width 0.5s ease;
    }

    .global-heat-value {
      font-size: 12px;
      font-weight: 600;
      min-width: 35px;
      text-align: right;
    }

    .heat-state-label {
      position: absolute;
      top: -8px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.7;
      white-space: nowrap;
    }

    /* Lockdown Overlay */
    .lockdown-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 64px;
      background: rgba(138, 26, 26, 0.15);
      pointer-events: none;
      z-index: 5;
      animation: lockdown-pulse 3s ease-in-out infinite;
    }

    @keyframes lockdown-pulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.6; }
    }

    .lockdown-banner {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(138, 26, 26, 0.95);
      border: 2px solid #f28b82;
      padding: 12px 20px;
      border-radius: 4px;
      z-index: 130;
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 4px 16px rgba(242, 139, 130, 0.4);
      animation: banner-flash 1.5s ease-in-out infinite;
    }

    @keyframes banner-flash {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* Manhunt Warning */
    .manhunt-warning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(10, 10, 10, 0.98);
      border: 2px solid #f28b82;
      padding: 24px;
      border-radius: 4px;
      z-index: 200;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.8);
      animation: manhunt-shake 0.5s ease-in-out;
    }

    @keyframes manhunt-shake {
      0%, 100% { transform: translate(-50%, -50%); }
      25% { transform: translate(-52%, -50%); }
      75% { transform: translate(-48%, -50%); }
    }

    .manhunt-header {
      text-align: center;
      margin-bottom: 20px;
    }

    .manhunt-icon {
      font-size: 56px;
      margin-bottom: 12px;
    }

    .manhunt-title {
      font-size: 20px;
      font-weight: 600;
      color: #f28b82;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .manhunt-description {
      font-size: 13px;
      opacity: 0.9;
      line-height: 1.5;
      margin-bottom: 20px;
      text-align: center;
    }

    .manhunt-choices {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .manhunt-choice-btn {
      padding: 12px 16px;
      background: #2a2a2a;
      border: 1px solid #4a4a4a;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      min-height: 44px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .manhunt-choice-btn:hover {
      background: #3a3a3a;
      border-color: #5a5a5a;
    }

    .manhunt-choice-btn:active {
      transform: scale(0.98);
    }

    .manhunt-choice-icon {
      font-size: 18px;
    }

    /* Heat Log */
    .heat-log-section {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 16px;
      margin-top: 16px;
    }

    .heat-log-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 250px;
      overflow-y: auto;
    }

    .heat-log-entry {
      padding: 10px;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      font-size: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .heat-log-message {
      flex: 1;
      line-height: 1.4;
    }

    .heat-log-value {
      font-size: 11px;
      font-weight: 600;
      padding: 3px 8px;
      background: #2a2a2a;
      border-radius: 3px;
      color: #f28b82;
    }

    .heat-log-timestamp {
      font-size: 10px;
      opacity: 0.5;
      margin-top: 4px;
    }

    /* Transition Indicator */
    .transition-indicator {
      position: fixed;
      top: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(26, 26, 26, 0.95);
      border: 1px solid #2a2a2a;
      padding: 10px 20px;
      border-radius: 4px;
      z-index: 110;
      font-size: 12px;
      opacity: 0.9;
      animation: transition-fade 0.3s ease-in;
      pointer-events: none;
      max-width: 80%;
      text-align: center;
    }

    @keyframes transition-fade {
      from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
      to { opacity: 0.9; transform: translateX(-50%) translateY(0); }
    }

    .status-btn.transitioning {
      opacity: 0.6;
      cursor: not-allowed;
      pointer-events: none;
    }

    /* Suspicion Eye Indicator */
    .suspicion-eye {
      position: absolute;
      top: -25px;
      right: -15px;
      font-size: 18px;
      z-index: 12;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s ease;
      animation: eye-watch 3s ease-in-out infinite;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.7));
    }

    .suspicion-eye.visible {
      opacity: 0.7;
    }

    @keyframes eye-watch {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    /* Detection Flash */
    .detection-flash {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.8);
      z-index: 250;
      animation: flash-effect 0.5s ease-out;
      pointer-events: none;
    }

    @keyframes flash-effect {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }

    /* Risk-based icon brightness */
    .map-icon[data-type="police"],
    .map-icon[data-type="dealer"],
    .map-icon[data-type="gang"] {
      transition: filter 2s ease, transform 0.3s ease;
    }

    .map-icon.risk-low {
      filter: brightness(0.7) grayscale(40%);
    }

    .map-icon.risk-medium {
      filter: brightness(1) grayscale(20%);
    }

    .map-icon.risk-high {
      filter: brightness(1.2) grayscale(0%);
      animation: icon-alert 2s ease-in-out infinite;
    }

    .map-icon.risk-extreme {
      filter: brightness(1.4) grayscale(0%) drop-shadow(0 0 4px rgba(242, 139, 130, 0.6));
      animation: icon-alert 1s ease-in-out infinite;
    }

    @keyframes icon-alert {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.05); }
    }

    /* Safe House Tab */
    .character-creator {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .creator-section {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 16px;
    }

    .section-title {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.8;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid #2a2a2a;
    }

    .option-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 8px;
      margin-top: 12px;
    }

    .option-btn {
      padding: 12px 8px;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      min-height: 44px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    .option-btn:active {
      transform: scale(0.98);
    }

    .option-btn.selected {
      background: #2a2a2a;
      border-color: #4a4a4a;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    /* Wardrobe Items */
    .wardrobe-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 8px;
      margin-top: 12px;
    }

    .wardrobe-item {
      padding: 12px;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      min-height: 80px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      position: relative;
    }

    .wardrobe-item.locked {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .wardrobe-item.equipped {
      background: #2a2a2a;
      border-color: #4a4a4a;
      box-shadow: 0 0 8px rgba(138, 180, 248, 0.3);
    }

    .wardrobe-item:not(.locked):active {
      transform: scale(0.98);
    }

    .item-icon {
      font-size: 32px;
    }

    .item-name {
      font-size: 11px;
      opacity: 0.9;
    }

    .item-cost {
      font-size: 10px;
      opacity: 0.6;
      color: #8ab4f8;
    }

    .item-locked-badge {
      position: absolute;
      top: 4px;
      right: 4px;
      font-size: 14px;
    }

    /* Character Preview */
    .character-preview {
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 24px;
      text-align: center;
      margin-bottom: 16px;
    }

    .preview-sprite {
      font-size: 64px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    .preview-details {
      font-size: 12px;
      opacity: 0.7;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
    }

    .preview-tag {
      background: #1a1a1a;
      padding: 4px 8px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="content">
      <!-- Profile Tab -->
      <div id="profile-tab" class="tab-content active">
        <div class="page-header">Profile</div>
        <div class="stat-grid">
          <div class="stat-card">
            <div class="stat-label">Player</div>
            <div class="stat-value" id="player-name">Unknown</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Cash</div>
            <div class="stat-value" id="player-cash">$1,000</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">XP / Level</div>
            <div class="stat-value">
              <span id="player-xp">0</span> / <span id="player-level">1</span>
            </div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Reputation</div>
            <div class="stat-value" id="player-rep">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Heat Level</div>
            <div class="stat-value" id="player-heat">0%</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Global Heat</div>
            <div class="stat-value" id="player-global-heat">0%</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Stats</div>
            <div class="stat-row">
              <span>Strength</span>
              <span id="stat-strength">5</span>
            </div>
            <div class="stat-row">
              <span>Intelligence</span>
              <span id="stat-intelligence">5</span>
            </div>
            <div class="stat-row">
              <span>Charisma</span>
              <span id="stat-charisma">5</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Turf Tab -->
      <div id="turf-tab" class="tab-content">
        <div class="page-header">Turf</div>
        
        <!-- Status Controls -->
        <div class="status-controls">
          <button class="status-btn laying_low selected" data-status="laying_low">
            <span></span>
            <span>Lay Low</span>
          </button>
          <button class="status-btn active-status" data-status="active">
            <span></span>
            <span>Active</span>
          </button>
        </div>

        <!-- Heat Indicator -->
        <div class="heat-indicator">
          <div class="heat-icon"></div>
          <div class="heat-bar-container">
            <div class="heat-bar-fill" id="heat-bar-fill" style="width: 0%"></div>
          </div>
          <div class="heat-value" id="heat-value">0%</div>
        </div>

        <!-- Free Roam Controls -->
        <div class="roam-controls">
          <button class="roam-btn" id="roam-toggle-btn">
            <span id="roam-icon"></span>
            <span id="roam-label">Start Free Roam</span>
          </button>
          <button class="map-refresh-btn" id="map-refresh-btn" title="Regenerate Map"></button>
        </div>
        
        <div id="city-map">
          <canvas id="map-canvas"></canvas>
          <div id="event-notification-container"></div>
          <div id="map-icons"></div>
          <div id="floating-pickups"></div>
          <div id="character-sprite" class="character-icon">
            <div class="status-indicator laying_low"></div>
            <div class="suspicion-eye" id="suspicion-eye"></div>
            <div class="character-silhouette"></div>
          </div>
        </div>
      </div>

      <!-- Crimes Tab -->
      <div id="crimes-tab" class="tab-content">
        <div class="page-header">Crimes</div>
        <div class="placeholder">
          <div class="placeholder-icon"></div>
          <div class="placeholder-text">No crimes available</div>
        </div>
      </div>

      <!-- Safe House Tab -->
      <div id="safehouse-tab" class="tab-content">
        <div class="page-header">Safe House</div>
        
        <div class="character-creator">
          <!-- Character Preview -->
          <div class="character-preview">
            <div class="preview-sprite" id="preview-sprite">
              <span id="preview-character"></span>
              <span id="preview-wardrobe"></span>
            </div>
            <div class="preview-details" id="preview-details">
              <span class="preview-tag">Male</span>
              <span class="preview-tag">Human</span>
              <span class="preview-tag">Short Hair</span>
            </div>
          </div>

          <!-- Gender Selection -->
          <div class="creator-section">
            <div class="section-title">Gender</div>
            <div class="option-grid">
              <button class="option-btn selected" data-trait="gender" data-value="male">
                <span></span>
                <span>Male</span>
              </button>
              <button class="option-btn" data-trait="gender" data-value="female">
                <span></span>
                <span>Female</span>
              </button>
            </div>
          </div>

          <!-- Race Selection -->
          <div class="creator-section">
            <div class="section-title">Race</div>
            <div class="option-grid">
              <button class="option-btn selected" data-trait="race" data-value="human">Human</button>
              <button class="option-btn" data-trait="race" data-value="elf">Elf</button>
              <button class="option-btn" data-trait="race" data-value="dwarf">Dwarf</button>
              <button class="option-btn" data-trait="race" data-value="orc">Orc</button>
            </div>
          </div>

          <!-- Face Selection -->
          <div class="creator-section">
            <div class="section-title">Face</div>
            <div class="option-grid">
              <button class="option-btn selected" data-trait="face" data-value="neutral">Neutral</button>
              <button class="option-btn" data-trait="face" data-value="sharp">Sharp</button>
              <button class="option-btn" data-trait="face" data-value="round">Round</button>
              <button class="option-btn" data-trait="face" data-value="weathered">Weathered</button>
            </div>
          </div>

          <!-- Body Selection -->
          <div class="creator-section">
            <div class="section-title">Body Type</div>
            <div class="option-grid">
              <button class="option-btn selected" data-trait="body" data-value="average">Average</button>
              <button class="option-btn" data-trait="body" data-value="slim">Slim</button>
              <button class="option-btn" data-trait="body" data-value="athletic">Athletic</button>
              <button class="option-btn" data-trait="body" data-value="heavy">Heavy</button>
            </div>
          </div>

          <!-- Hair Selection -->
          <div class="creator-section">
            <div class="section-title">Hair Style</div>
            <div class="option-grid">
              <button class="option-btn selected" data-trait="hair" data-value="short">Short</button>
              <button class="option-btn" data-trait="hair" data-value="long">Long</button>
              <button class="option-btn" data-trait="hair" data-value="bald">Bald</button>
              <button class="option-btn" data-trait="hair" data-value="mohawk">Mohawk</button>
            </div>
          </div>

          <!-- Wardrobe -->
          <div class="creator-section">
            <div class="section-title">Wardrobe</div>
            <div class="wardrobe-grid" id="wardrobe-grid">
              <!-- Populated by JS -->
            </div>
          </div>
        </div>
      </div>

      <!-- Inventory Tab -->
      <div id="inventory-tab" class="tab-content">
        <div class="page-header">Inventory</div>
        <div class="placeholder">
          <div class="placeholder-icon"></div>
          <div class="placeholder-text">Empty</div>
        </div>
      </div>

      <!-- Gang Tab -->
      <div id="gang-tab" class="tab-content">
        <div class="page-header">Gang</div>
        <div id="gang-content">
          <!-- Populated by JS -->
        </div>
      </div>
    </div>

    <!-- Tab Bar -->
    <div id="tab-bar">
      <div class="tab active" data-tab="profile">
        <div class="tab-icon"></div>
        <div class="tab-label">Profile</div>
      </div>
      <div class="tab" data-tab="turf">
        <div class="tab-icon"></div>
        <div class="tab-label">Turf</div>
      </div>
      <div class="tab" data-tab="crimes">
        <div class="tab-icon"></div>
        <div class="tab-label">Crimes</div>
      </div>
      <div class="tab" data-tab="safehouse">
        <div class="tab-icon"></div>
        <div class="tab-label">Safe House</div>
      </div>
      <div class="tab" data-tab="gang">
        <div class="tab-icon"></div>
        <div class="tab-label">Gang</div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>
  
  <script>
    // ========================================
    // CHAT SYSTEM: Real-time Messaging
    // ========================================
    const ChatSystem = {
      currentChatWith: null,
      messageListener: null,
      unreadCounts: {},
      
      // Open chat overlay
      openChat(targetPlayerId = null) {
        console.log('Opening chat with:', targetPlayerId || 'global');
        
        this.currentChatWith = targetPlayerId;
        
        // Create chat overlay
        const overlay = document.createElement('div');
        overlay.className = 'chat-overlay';
        overlay.id = 'chat-overlay';
        
        const chatTitle = targetPlayerId ? this.getPlayerName(targetPlayerId) : 'Global Chat';
        
        overlay.innerHTML = `
          <div class="chat-header">
            <div class="chat-title">
              <span></span>
              <span>${chatTitle}</span>
            </div>
            <button class="chat-close-btn" id="chat-close-btn"></button>
          </div>
          <div class="chat-messages-container" id="chat-messages-container">
            <div class="chat-empty">
              <div class="chat-empty-icon"></div>
              <div class="chat-empty-text">No messages yet. Start the conversation!</div>
            </div>
          </div>
          <div class="chat-input-container">
            <textarea 
              class="chat-input" 
              id="chat-input" 
              placeholder="Type a message..." 
              rows="1"
              maxlength="500"
            ></textarea>
            <button class="chat-send-btn" id="chat-send-btn"></button>
          </div>
        `;
        
        document.getElementById('app').appendChild(overlay);
        
        // Add event listeners
        document.getElementById('chat-close-btn')?.addEventListener('click', () => {
          this.closeChat();
        });
        
        document.getElementById('chat-send-btn')?.addEventListener('click', () => {
          this.sendMessage();
        });
        
        const chatInput = document.getElementById('chat-input');
        chatInput?.addEventListener('keypress', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            this.sendMessage();
          }
        });
        
        // Auto-resize textarea
        chatInput?.addEventListener('input', (e) => {
          e.target.style.height = 'auto';
          e.target.style.height = e.target.scrollHeight + 'px';
        });
        
        // Load messages
        this.loadMessages();
        
        // Mark as read
        if (targetPlayerId) {
          this.unreadCounts[targetPlayerId] = 0;
          this.updateChatButton();
        }
      },
      
      // Close chat overlay
      closeChat() {
        const overlay = document.getElementById('chat-overlay');
        if (overlay) overlay.remove();
        
        // Remove message listener
        if (this.messageListener && database) {
          database.ref(this.getChatPath()).off('child_added', this.messageListener);
          this.messageListener = null;
        }
        
        this.currentChatWith = null;
      },
      
      // Get chat path in Firebase
      getChatPath() {
        if (!this.currentChatWith) {
          return 'global_chat';
        }
        
        // Create consistent chat room ID (sorted to ensure same room for both users)
        const ids = [GameState.accountId, this.currentChatWith].sort();
        return `private_chats/${ids[0]}_${ids[1]}`;
      },
      
      // Send message
      sendMessage() {
        const input = document.getElementById('chat-input');
        const message = input?.value.trim();
        
        if (!message) {
          console.log('Empty message, not sending');
          return;
        }
        
        if (!database) {
          console.error('Firebase not initialized');
          alert('Chat is not available - Firebase not connected');
          return;
        }
        
        if (!GameState.accountId || !GameState.player.name) {
          console.error('Player data missing');
          alert('Player data not loaded');
          return;
        }
        
        console.log('Sending message:', message);
        console.log('Chat path:', this.getChatPath());
        
        const chatPath = this.getChatPath();
        const messageData = {
          senderId: GameState.accountId,
          senderName: GameState.player.name,
          message: message,
          timestamp: Date.now()
        };
        
        console.log('Message data:', messageData);
        
        // Disable send button temporarily
        const sendBtn = document.getElementById('chat-send-btn');
        if (sendBtn) sendBtn.disabled = true;
        
        // Push to Firebase
        database.ref(chatPath).push(messageData)
          .then(() => {
            console.log(' Message sent successfully:', message);
            input.value = '';
            input.style.height = 'auto';
            if (sendBtn) sendBtn.disabled = false;
            input.focus();
          })
          .catch((error) => {
            console.error(' Failed to send message:', error);
            alert('Failed to send message: ' + error.message);
            if (sendBtn) sendBtn.disabled = false;
          });
      },
      
      // Load messages from Firebase
      loadMessages() {
        if (!database) return;
        
        const chatPath = this.getChatPath();
        const messagesRef = database.ref(chatPath).limitToLast(50);
        
        // Load existing messages
        messagesRef.once('value', (snapshot) => {
          const container = document.getElementById('chat-messages-container');
          if (!container) return;
          
          container.innerHTML = '';
          
          const hasMessages = snapshot.numChildren() > 0;
          
          if (!hasMessages) {
            container.innerHTML = `
              <div class="chat-empty">
                <div class="chat-empty-icon"></div>
                <div class="chat-empty-text">No messages yet. Start the conversation!</div>
              </div>
            `;
          } else {
            snapshot.forEach((childSnapshot) => {
              const messageData = childSnapshot.val();
              this.renderMessage(messageData);
            });
          }
          
          this.scrollToBottom();
        });
        
        // Listen for new messages (child_added fires for ALL children on attach, so we track what we've seen)
        let initialLoadComplete = false;
        
        messagesRef.once('value', () => {
          initialLoadComplete = true;
        });
        
        this.messageListener = messagesRef.on('child_added', (snapshot) => {
          // Only render new messages after initial load
          if (initialLoadComplete) {
            const messageData = snapshot.val();
            const container = document.getElementById('chat-messages-container');
            
            if (container) {
              // Remove empty state if exists
              const emptyState = container.querySelector('.chat-empty');
              if (emptyState) {
                emptyState.remove();
              }
              
              this.renderMessage(messageData);
              this.scrollToBottom();
            }
          }
        });
      },
      
      // Render a message
      renderMessage(messageData) {
        const container = document.getElementById('chat-messages-container');
        if (!container) return;
        
        const isOwnMessage = messageData.senderId === GameState.accountId;
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message ${isOwnMessage ? 'own' : 'other'}`;
        
        const time = new Date(messageData.timestamp).toLocaleTimeString([], { 
          hour: '2-digit', 
          minute: '2-digit' 
        });
        
        messageDiv.innerHTML = `
          <div class="chat-message-header">
            <span class="chat-message-username">${messageData.senderName}</span>
            <span class="chat-message-time">${time}</span>
          </div>
          <div class="chat-message-bubble">${this.escapeHtml(messageData.message)}</div>
        `;
        
        container.appendChild(messageDiv);
      },
      
      // Scroll to bottom
      scrollToBottom() {
        const container = document.getElementById('chat-messages-container');
        if (container) {
          container.scrollTop = container.scrollHeight;
        }
      },
      
      // Escape HTML to prevent XSS
      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      },
      
      // Get player name by ID
      getPlayerName(playerId) {
        // Try to get from cached leaderboard
        const player = GlobalLeaderboard.cachedLeaderboard.find(p => p.accountId === playerId);
        return player ? player.username : 'Unknown Player';
      },
      
      // Update chat button with unread count
      updateChatButton() {
        const chatBtn = document.getElementById('chat-tab-btn');
        if (!chatBtn) return;
        
        const totalUnread = Object.values(this.unreadCounts).reduce((sum, count) => sum + count, 0);
        
        if (totalUnread > 0) {
          chatBtn.innerHTML = ` <span style="background: #f28b82; padding: 2px 6px; border-radius: 10px; font-size: 10px; margin-left: 4px;">${totalUnread}</span>`;
        } else {
          chatBtn.textContent = '';
        }
      },
      
      // Listen for new messages (for unread counts)
      startListeningForMessages() {
        if (!database || !GameState.accountId) return;
        
        // Listen to all chats involving this player
        const chatsRef = database.ref('private_chats');
        
        chatsRef.on('child_added', (snapshot) => {
          const chatId = snapshot.key;
          
          // Check if this chat involves current player
          if (chatId.includes(GameState.accountId)) {
            const lastMessageRef = snapshot.ref.limitToLast(1);
            
            lastMessageRef.on('child_added', (msgSnapshot) => {
              const message = msgSnapshot.val();
              
              // Increment unread if not from self and chat not open
              if (message.senderId !== GameState.accountId) {
                const otherPlayerId = chatId.replace(GameState.accountId, '').replace('_', '');
                
                if (this.currentChatWith !== otherPlayerId) {
                  this.unreadCounts[otherPlayerId] = (this.unreadCounts[otherPlayerId] || 0) + 1;
                  this.updateChatButton();
                }
              }
            });
          }
        });
      }
    };

    // ========================================
    // FIREBASE: Initialize Connection
    // ========================================
    
    // Global database reference
    let database = null;
    let firebaseReady = false;
    
    // Load Firebase scripts dynamically
    function loadFirebase() {
      console.log(' loadFirebase() started...');
      return new Promise((resolve, reject) => {
        // Load Firebase App
        console.log(' Loading Firebase App script...');
        const appScript = document.createElement('script');
        appScript.src = 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js';
        appScript.onload = () => {
          console.log(' Firebase App script loaded');
          // Load Firebase Database
          console.log(' Loading Firebase Database script...');
          const dbScript = document.createElement('script');
          dbScript.src = 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js';
          dbScript.onload = () => {
            console.log(' Firebase Database script loaded');
            try {
              // Initialize Firebase
              console.log(' Initializing Firebase...');
              const firebaseConfig = {
                apiKey: "AIzaSyBg2q6syxAjTWcvlpNfWMX7rbDNVTXYKb0",
                authDomain: "crime-rpg-leaderboards.firebaseapp.com",
                databaseURL: "https://crime-rpg-leaderboards-default-rtdb.firebaseio.com",
                projectId: "crime-rpg-leaderboards",
                storageBucket: "crime-rpg-leaderboards.firebasestorage.app",
                messagingSenderId: "37052336470",
                appId: "1:37052336470:web:eb7832af09a79d0726aef7"
              };
              
              console.log(' Firebase config:', firebaseConfig);
              firebase.initializeApp(firebaseConfig);
              console.log(' Firebase app initialized');
              
              database = firebase.database();
              console.log(' Database reference created:', database ? 'SUCCESS' : 'FAILED');
              
              firebaseReady = true;
              console.log(' firebaseReady set to:', firebaseReady);
              
              console.log(' Firebase connected successfully!');
              resolve();
            } catch (error) {
              console.error(' Firebase initialization error:', error);
              reject(error);
            }
          };
          dbScript.onerror = (error) => {
            console.error(' Firebase Database script failed to load:', error);
            reject(error);
          };
          document.head.appendChild(dbScript);
        };
        appScript.onerror = (error) => {
          console.error(' Firebase App script failed to load:', error);
          reject(error);
        };
        document.head.appendChild(appScript);
      });
    }

    // ========================================
    // AUTH MANAGER: Authentication State
    // ========================================
    const AuthManager = {
      AUTH_STATE_KEY: 'crime_rpg_auth_state',
      
      // Get current auth state
      getAuthState() {
        try {
          const data = localStorage.getItem(this.AUTH_STATE_KEY);
          if (!data) {
            return {
              isLoggedIn: false,
              activeUserId: null
            };
          }
          return JSON.parse(data);
        } catch (e) {
          console.error('Failed to load auth state:', e);
          return {
            isLoggedIn: false,
            activeUserId: null
          };
        }
      },
      
      // Set auth state
      setAuthState(isLoggedIn, activeUserId = null) {
        try {
          const authState = {
            isLoggedIn,
            activeUserId,
            lastLogin: isLoggedIn ? Date.now() : null
          };
          localStorage.setItem(this.AUTH_STATE_KEY, JSON.stringify(authState));
          console.log('Auth state updated:', authState);
        } catch (e) {
          console.error('Failed to save auth state:', e);
        }
      },
      
      // Login (set auth state)
      login(accountId) {
        console.log('[AUTH MANAGER DEBUG] login() called with accountId:', accountId);
        this.setAuthState(true, accountId);
        console.log('[AUTH MANAGER DEBUG] Auth state set to logged in');
        console.log('[AUTH MANAGER DEBUG] User logged in:', accountId);
      },
      
      // Logout (clear auth state, preserve game data)
      logout() {
        console.log('=== Logout Process Started ===');
        
        // 1. Save current game state first
        Storage.save();
        console.log('Game state saved');
        
        // 2. Get current user info for logging
        const currentAccountId = AccountManager.getCurrentAccountId();
        const currentAccount = currentAccountId ? AccountManager.getAccount(currentAccountId) : null;
        console.log('Logging out:', currentAccount ? currentAccount.username : 'Unknown');
        
        // 3. Clear authentication state only
        this.setAuthState(false, null);
        
        // 4. Clear current account ID (but NOT account data or saves)
        AccountManager.setCurrentAccountId(null);
        
        // 5. Stop all active intervals/timers
        this.stopAllGameIntervals();
        
        console.log('Auth state cleared');
        console.log('All game data preserved');
        console.log('==============================');
        
        // 6. Redirect to login screen
        this.showLoginScreen();
      },
      
      // Stop all game intervals on logout
      stopAllGameIntervals() {
        // Stop TurfTab intervals
        if (TurfTab.roamInterval) {
          clearInterval(TurfTab.roamInterval);
          TurfTab.roamInterval = null;
        }
        if (TurfTab.eventInterval) {
          clearTimeout(TurfTab.eventInterval);
          TurfTab.eventInterval = null;
        }
        if (TurfTab.heatDecayInterval) {
          clearInterval(TurfTab.heatDecayInterval);
          TurfTab.heatDecayInterval = null;
        }
        if (TurfTab.jailCheckInterval) {
          clearInterval(TurfTab.jailCheckInterval);
          TurfTab.jailCheckInterval = null;
        }
        if (TurfTab.globalHeatDecayInterval) {
          clearInterval(TurfTab.globalHeatDecayInterval);
          TurfTab.globalHeatDecayInterval = null;
        }
        if (TurfTab.lockdownCheckInterval) {
          clearInterval(TurfTab.lockdownCheckInterval);
          TurfTab.lockdownCheckInterval = null;
        }
        if (TurfTab.manhuntCheckInterval) {
          clearInterval(TurfTab.manhuntCheckInterval);
          TurfTab.manhuntCheckInterval = null;
        }
        if (TurfTab.transitionCheckInterval) {
          clearInterval(TurfTab.transitionCheckInterval);
          TurfTab.transitionCheckInterval = null;
        }
        if (TurfTab.suspicionBuildInterval) {
          clearInterval(TurfTab.suspicionBuildInterval);
          TurfTab.suspicionBuildInterval = null;
        }
        if (TurfTab.suspicionDecayInterval) {
          clearInterval(TurfTab.suspicionDecayInterval);
          TurfTab.suspicionDecayInterval = null;
        }
        if (TurfTab.suspicionCheckInterval) {
          clearInterval(TurfTab.suspicionCheckInterval);
          TurfTab.suspicionCheckInterval = null;
        }
        if (TurfTab.worldTickInterval) {
          clearInterval(TurfTab.worldTickInterval);
          TurfTab.worldTickInterval = null;
        }
        if (TurfTab.moneyDrainInterval) {
          clearInterval(TurfTab.moneyDrainInterval);
          TurfTab.moneyDrainInterval = null;
        }
        
        // Stop GangTab intervals
        if (GangTab.propertyIncomeInterval) {
          clearInterval(GangTab.propertyIncomeInterval);
          GangTab.propertyIncomeInterval = null;
        }
        if (GangTab.heatDecayInterval) {
          clearInterval(GangTab.heatDecayInterval);
          GangTab.heatDecayInterval = null;
        }
        
        console.log('All game intervals stopped');
      },
      
      // Show login screen (replace app content)
      showLoginScreen() {
        // Clear app content
        const app = document.getElementById('app');
        if (!app) return;
        
        app.innerHTML = '';
        
        // Show account creation/login UI
        AccountUI.showAccountCreationPrompt(false);
      },
      
      // Check if user is logged in
      isLoggedIn() {
        const authState = this.getAuthState();
        return authState.isLoggedIn === true && authState.activeUserId !== null;
      }
    };
    
    console.log('=== AUTH MANAGER: Authentication System - COMPLETE ===');

    // ========================================
    // PHASE B: BOOT FLOW & USER DETECTION
    // ========================================
    const BootFlow = {
      // Detect user state and determine next action
      detectUserState() {
        console.log('=== PHASE B: Boot Flow Detection ===');
        
        const currentAccountId = AccountManager.getCurrentAccountId();
        const hasAnonymous = Storage.hasAnonymousProgress();
        const hasMigrated = AccountManager.hasMigrated();
        
        console.log('Current Account ID:', currentAccountId);
        console.log('Has Anonymous Progress:', hasAnonymous);
        console.log('Has Migrated:', hasMigrated);
        
        // Scenario 1: Existing account - auto sign in
        if (currentAccountId) {
          const account = AccountManager.getAccount(currentAccountId);
          if (account) {
            console.log(' Scenario 1: Existing account found');
            return {
              scenario: 'existing_account',
              account: account,
              action: 'auto_signin'
            };
          } else {
            // Account ID exists but account not found - corrupted state
            console.warn('Account ID exists but account not found - clearing');
            AccountManager.setCurrentAccountId(null);
          }
        }
        
        // Scenario 2: Anonymous progress exists - prompt to create account
        if (hasAnonymous && !hasMigrated) {
          console.log(' Scenario 2: Anonymous progress exists');
          return {
            scenario: 'anonymous_progress',
            action: 'prompt_account_creation'
          };
        }
        
        // Scenario 3: New user (shared link or first visit) - require account
        console.log(' Scenario 3: New user');
        return {
          scenario: 'new_user',
          action: 'require_account_creation'
        };
      },
      
      // Execute boot action based on state
      async executeBoot() {
        const state = this.detectUserState();
        
        console.log('Boot Action:', state.action);
        
        switch (state.action) {
          case 'auto_signin':
            this.autoSignIn(state.account);
            return true; // Continue to game
            
          case 'prompt_account_creation':
            AccountUI.showAccountCreationPrompt(true); // hasProgress = true
            return false; // Wait for account creation
            
          case 'require_account_creation':
            AccountUI.showAccountCreationPrompt(false); // hasProgress = false
            return false; // Wait for account creation
        }
      },
      
      // Auto sign in existing user
      autoSignIn(account) {
        console.log('Auto signing in:', account.username);
        
        // Set current account
        AccountManager.setCurrentAccountId(account.accountId);
        AccountManager.updateSignIn(account.accountId);
        
        // Load account's save
        Storage.loadAccountSave(account.accountId);
        
        // Update player name if not set
        if (GameState.player.name === 'Unknown' || !GameState.player.name) {
          GameState.player.name = account.username;
        }
        
        // Ensure accountId is set in GameState
        GameState.accountId = account.accountId;
        
        Storage.save();
        
        // IMMEDIATE: Sync returning player to leaderboard
        console.log(' Updating leaderboard for returning player...');
        Storage.updateLeaderboard();
        
        console.log('Auto sign-in complete for:', account.username);
      },
      
      // Sign in with email
      signIn(email) {
        console.log('[BOOTFLOW DEBUG] signIn() called with email:', email);
        
        const account = AccountManager.findAccountByEmail(email);
        
        console.log('[BOOTFLOW DEBUG] Account lookup result:', account);
        
        if (!account) {
          console.log('[BOOTFLOW DEBUG] Account NOT FOUND');
          return {
            success: false,
            error: 'No account found with this email'
          };
        }
        
        console.log('[BOOTFLOW DEBUG] Account FOUND:', account.username);
        
        // Load this account's save
        AccountManager.setCurrentAccountId(account.accountId);
        console.log('[BOOTFLOW DEBUG] Set current account ID:', account.accountId);
        
        AccountManager.updateSignIn(account.accountId);
        console.log('[BOOTFLOW DEBUG] Updated sign-in timestamp');
        
        const loaded = Storage.loadAccountSave(account.accountId);
        console.log('[BOOTFLOW DEBUG] Load account save result:', loaded);
        
        if (!loaded) {
          // No save found for this account - create fresh state
          console.log('[BOOTFLOW DEBUG] No save found - creating fresh state');
          GameState.accountId = account.accountId;
          GameState.player.name = account.username;
        }
        
        Storage.save();
        console.log('[BOOTFLOW DEBUG] Game state saved');
        
        // IMMEDIATE: Update leaderboard on sign-in
        console.log(' Syncing player to leaderboard...');
        Storage.updateLeaderboard();
        
        console.log('[BOOTFLOW DEBUG] Sign-in successful for:', account.username);
        
        return {
          success: true,
          account: account
        };
      },
      
      // Create account and bind progress
      createAccountAndBind(email, username) {
        // Validate
        if (!AccountManager.isValidEmail(email)) {
          return {
            success: false,
            error: 'Invalid email format'
          };
        }
        
        if (!AccountManager.isValidUsername(username)) {
          return {
            success: false,
            error: 'Username must be 3-20 characters'
          };
        }
        
        // Check if email exists
        if (AccountManager.findAccountByEmail(email)) {
          return {
            success: false,
            error: 'An account with this email already exists'
          };
        }
        
        // Check if username is taken
        if (AccountManager.isUsernameTaken(username)) {
          return {
            success: false,
            error: 'This username is already taken on this device'
          };
        }
        
        // Create account
        const account = AccountManager.createAccount(email, username);
        
        // Check if anonymous progress exists
        const hasAnonymous = Storage.hasAnonymousProgress();
        
        if (hasAnonymous) {
          Storage.migrateToAccount(account.accountId);
          AccountManager.markMigrated();
        }
        
        // Set as current account
        AccountManager.setCurrentAccountId(account.accountId);
        
        // Update GameState
        GameState.accountId = account.accountId;
        GameState.player.name = username;
        
        // Generate new player ID if not exists
        if (!GameState.player.id) {
          GameState.player.id = account.accountId;
        }
        
        Storage.save();
        
        return {
          success: true,
          account: account,
          migratedProgress: hasAnonymous
        };
      }
    };
    
    console.log('=== PHASE B: Boot Flow - COMPLETE ===');

    // ========================================
    // PHASE C: ACCOUNT CREATION UI
    // ========================================
    const AccountUI = {
      // Show account creation prompt
      showAccountCreationPrompt(hasProgress) {
        const overlay = document.createElement('div');
        overlay.className = 'account-overlay';
        overlay.id = 'account-overlay';
        
        const iconMap = hasProgress ? '' : '';
        const titleMap = hasProgress ? 'Save Your Progress' : 'Welcome to Crime RPG';
        const subtitleMap = hasProgress 
          ? 'Create an account to save your progress and continue on any device.'
          : 'Create an account to start your criminal career.';
        
        overlay.innerHTML = `
          <div class="account-container">
            <div class="account-header">
              <div class="account-icon">${iconMap}</div>
              <div class="account-title">${titleMap}</div>
              <div class="account-subtitle">${subtitleMap}</div>
            </div>
            
            ${hasProgress ? `
              <div class="account-warning-box">
                 You have unsaved progress. Create an account now to prevent losing it.
              </div>
            ` : `
              <div class="account-info-box">
                 Your account is stored locally on this device. No email verification required.
              </div>
            `}
            
            <div class="account-form">
              <div class="account-input-group">
                <label class="account-label">Email</label>
                <input 
                  type="email" 
                  class="account-input" 
                  id="account-email-input"
                  placeholder="your.email@example.com"
                  autocomplete="email"
                >
                <div class="account-error" id="email-error"></div>
                <div class="account-hint">Used for account identification only</div>
              </div>
              
              <div class="account-input-group">
                <label class="account-label">Username</label>
                <input 
                  type="text" 
                  class="account-input" 
                  id="account-username-input"
                  placeholder="Your criminal alias"
                  autocomplete="username"
                  minlength="3"
                  maxlength="20"
                >
                <div class="account-error" id="username-error"></div>
                <div class="account-hint">3-20 characters, shown in-game</div>
              </div>
              
              <button type="button" class="account-btn account-btn-primary" id="create-account-btn">
                <span></span>
                <span>Create Account</span>
              </button>
            </div>
            
            <div class="account-divider">
              <span class="account-divider-text">Already have an account?</span>
            </div>
            
            <button type="button" class="account-btn" id="show-signin-btn">
              <span></span>
              <span>Sign In</span>
            </button>
          </div>
        `;
        
        document.body.appendChild(overlay);
        this.bindAccountUIEvents();
      },
      
      // Bulletproof event binding
      bindAccountUIEvents() {
        setTimeout(() => {
          const createBtn = document.getElementById('create-account-btn');
          const signinBtn = document.getElementById('show-signin-btn');
          
          if (createBtn) {
            createBtn.addEventListener('click', () => {
              this.handleAccountCreation();
            });
          }
          
          if (signinBtn) {
            signinBtn.addEventListener('click', () => {
              const overlay = document.getElementById('account-overlay');
              if (overlay) overlay.remove();
              this.showSignInPrompt();
            });
          }
        }, 0);
      },
      
      // Handle account creation
      handleAccountCreation() {
        const emailInput = document.getElementById('account-email-input');
        const usernameInput = document.getElementById('account-username-input');
        
        if (!emailInput || !usernameInput) {
          alert('Error: Form inputs not found. Please refresh and try again.');
          return;
        }
        
        const email = emailInput.value.trim();
        const username = usernameInput.value.trim();
        
        if (!email || !username) {
          alert('Please enter both email and username.');
          return;
        }
        
        // Clear previous errors
        document.querySelectorAll('.account-error').forEach(el => el.classList.remove('visible'));
        document.querySelectorAll('.account-input').forEach(el => el.classList.remove('error'));
        
        // Validate
        if (!AccountManager.isValidEmail(email)) {
          this.showError('email-error', 'Please enter a valid email address');
          emailInput.classList.add('error');
          return;
        }
        
        if (!AccountManager.isValidUsername(username)) {
          this.showError('username-error', 'Username must be 3-20 characters');
          usernameInput.classList.add('error');
          return;
        }
        
        // Create account
        const result = BootFlow.createAccountAndBind(email, username);
        
        if (!result.success) {
          if (result.error.toLowerCase().includes('email')) {
            this.showError('email-error', result.error);
            emailInput.classList.add('error');
          } else {
            this.showError('username-error', result.error);
            usernameInput.classList.add('error');
          }
          return;
        }
        
        // Success
        this.showAccountCreationSuccess(result.account, result.migratedProgress);
      },
      
      // Show error message
      showError(errorId, message) {
        const errorEl = document.getElementById(errorId);
        if (errorEl) {
          errorEl.textContent = message;
          errorEl.classList.add('visible');
        }
      },
      
      // Show success message
      showAccountCreationSuccess(account, migratedProgress) {
        const overlay = document.getElementById('account-overlay');
        if (!overlay) return;
        
        const container = overlay.querySelector('.account-container');
        if (!container) return;
        
        container.innerHTML = `
          <div class="account-success-message">
            <div class="account-success-icon"></div>
            <div class="account-success-title">Account Created!</div>
            <div class="account-success-text">
              Welcome, <strong>${account.username}</strong>!
              ${migratedProgress ? '<br>Your progress has been saved to your account.' : '<br>Your criminal empire begins now.'}
            </div>
            <button type="button" class="account-btn account-btn-primary" id="start-game-btn">
              <span></span>
              <span>Enter the Game</span>
            </button>
          </div>
        `;
        
        setTimeout(() => {
          const startBtn = document.getElementById('start-game-btn');
          if (startBtn) {
            startBtn.addEventListener('click', () => {
              // Set auth state to logged in FIRST
              AuthManager.login(account.accountId);
              
              // Remove overlay
              overlay.remove();
              
              // Rebuild app structure and initialize game
              const app = document.getElementById('app');
              if (!app) {
                console.error('App container not found!');
                return;
              }
              
              // Show loading state briefly
              app.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100vh; color: #e0e0e0; font-size: 18px;"> Loading your criminal empire...</div>';
              
              // Wait a moment, then rebuild and initialize
              setTimeout(() => {
                this.rebuildAppStructure();
                initializeGame();
              }, 300);
            });
          }
        }, 0);
      },
      
      rebuildAppStructure() {
        const app = document.getElementById('app');
        if (!app) return;
        
        // Restore original app HTML structure
        app.innerHTML = `
          <div id="content">
            <!-- Profile Tab -->
            <div id="profile-tab" class="tab-content active">
              <div class="page-header">Profile</div>
              <div class="stat-grid">
                <div class="stat-card">
                  <div class="stat-label">Player</div>
                  <div class="stat-value" id="player-name">Unknown</div>
                </div>
                <div class="stat-card">
                  <div class="stat-label">Cash</div>
                  <div class="stat-value" id="player-cash">$1,000</div>
                </div>
                <div class="stat-card">
                  <div class="stat-label">XP / Level</div>
                  <div class="stat-value">
                    <span id="player-xp">0</span> / <span id="player-level">1</span>
                  </div>
                </div>
                <div class="stat-card">
                  <div class="stat-label">Reputation</div>
                  <div class="stat-value" id="player-rep">0</div>
                </div>
                <div class="stat-card">
                  <div class="stat-label">Heat Level</div>
                  <div class="stat-value" id="player-heat">0%</div>
                </div>
                <div class="stat-card">
                  <div class="stat-label">Global Heat</div>
                  <div class="stat-value" id="player-global-heat">0%</div>
                </div>
                <div class="stat-card">
                  <div class="stat-label">Stats</div>
                  <div class="stat-row">
                    <span>Strength</span>
                    <span id="stat-strength">5</span>
                  </div>
                  <div class="stat-row">
                    <span>Intelligence</span>
                    <span id="stat-intelligence">5</span>
                  </div>
                  <div class="stat-row">
                    <span>Charisma</span>
                    <span id="stat-charisma">5</span>
                  </div>
                </div>
              </div>
            </div>

            <!-- Turf Tab -->
            <div id="turf-tab" class="tab-content">
              <div class="page-header">Turf</div>
              
              <div class="status-controls">
                <button class="status-btn laying_low selected" data-status="laying_low">
                  <span></span>
                  <span>Lay Low</span>
                </button>
                <button class="status-btn active-status" data-status="active">
                  <span></span>
                  <span>Active</span>
                </button>
              </div>

              <div class="heat-indicator">
                <div class="heat-icon"></div>
                <div class="heat-bar-container">
                  <div class="heat-bar-fill" id="heat-bar-fill" style="width: 0%"></div>
                </div>
                <div class="heat-value" id="heat-value">0%</div>
              </div>

              <div class="roam-controls">
                <button class="roam-btn" id="roam-toggle-btn">
                  <span id="roam-icon"></span>
                  <span id="roam-label">Start Free Roam</span>
                </button>
                <button class="map-refresh-btn" id="map-refresh-btn" title="Regenerate Map"></button>
              </div>
              
              <div id="city-map">
                <canvas id="map-canvas"></canvas>
                <div id="event-notification-container"></div>
                <div id="map-icons"></div>
                <div id="floating-pickups"></div>
                <div id="character-sprite" class="character-icon">
                  <div class="status-indicator laying_low"></div>
                  <div class="suspicion-eye" id="suspicion-eye"></div>
                  <div class="character-silhouette"></div>
                </div>
              </div>
            </div>

            <!-- Crimes Tab -->
            <div id="crimes-tab" class="tab-content">
              <div class="page-header">Crimes</div>
              <div class="placeholder">
                <div class="placeholder-icon"></div>
                <div class="placeholder-text">No crimes available</div>
              </div>
            </div>

            <!-- Safe House Tab -->
            <div id="safehouse-tab" class="tab-content">
              <div class="page-header">Safe House</div>
              
              <div class="character-creator">
                <div class="character-preview">
                  <div class="preview-sprite" id="preview-sprite">
                    <span id="preview-character"></span>
                    <span id="preview-wardrobe"></span>
                  </div>
                  <div class="preview-details" id="preview-details">
                    <span class="preview-tag">Male</span>
                    <span class="preview-tag">Human</span>
                    <span class="preview-tag">Short Hair</span>
                  </div>
                </div>

                <div class="creator-section">
                  <div class="section-title">Gender</div>
                  <div class="option-grid">
                    <button class="option-btn selected" data-trait="gender" data-value="male">
                      <span></span>
                      <span>Male</span>
                    </button>
                    <button class="option-btn" data-trait="gender" data-value="female">
                      <span></span>
                      <span>Female</span>
                    </button>
                  </div>
                </div>

                <div class="creator-section">
                  <div class="section-title">Race</div>
                  <div class="option-grid">
                    <button class="option-btn selected" data-trait="race" data-value="human">Human</button>
                    <button class="option-btn" data-trait="race" data-value="elf">Elf</button>
                    <button class="option-btn" data-trait="race" data-value="dwarf">Dwarf</button>
                    <button class="option-btn" data-trait="race" data-value="orc">Orc</button>
                  </div>
                </div>

                <div class="creator-section">
                  <div class="section-title">Face</div>
                  <div class="option-grid">
                    <button class="option-btn selected" data-trait="face" data-value="neutral">Neutral</button>
                    <button class="option-btn" data-trait="face" data-value="sharp">Sharp</button>
                    <button class="option-btn" data-trait="face" data-value="round">Round</button>
                    <button class="option-btn" data-trait="face" data-value="weathered">Weathered</button>
                  </div>
                </div>

                <div class="creator-section">
                  <div class="section-title">Body Type</div>
                  <div class="option-grid">
                    <button class="option-btn selected" data-trait="body" data-value="average">Average</button>
                    <button class="option-btn" data-trait="body" data-value="slim">Slim</button>
                    <button class="option-btn" data-trait="body" data-value="athletic">Athletic</button>
                    <button class="option-btn" data-trait="body" data-value="heavy">Heavy</button>
                  </div>
                </div>

                <div class="creator-section">
                  <div class="section-title">Hair Style</div>
                  <div class="option-grid">
                    <button class="option-btn selected" data-trait="hair" data-value="short">Short</button>
                    <button class="option-btn" data-trait="hair" data-value="long">Long</button>
                    <button class="option-btn" data-trait="hair" data-value="bald">Bald</button>
                    <button class="option-btn" data-trait="hair" data-value="mohawk">Mohawk</button>
                  </div>
                </div>

                <div class="creator-section">
                  <div class="section-title">Wardrobe</div>
                  <div class="wardrobe-grid" id="wardrobe-grid"></div>
                </div>
              </div>
            </div>

            <!-- Inventory Tab -->
            <div id="inventory-tab" class="tab-content">
              <div class="page-header">Inventory</div>
              <div class="placeholder">
                <div class="placeholder-icon"></div>
                <div class="placeholder-text">Empty</div>
              </div>
            </div>

            <!-- Gang Tab -->
            <div id="gang-tab" class="tab-content">
              <div class="page-header">Gang</div>
              <div id="gang-content"></div>
            </div>
          </div>

          <!-- Tab Bar -->
          <div id="tab-bar">
            <div class="tab active" data-tab="profile">
              <div class="tab-icon"></div>
              <div class="tab-label">Profile</div>
            </div>
            <div class="tab" data-tab="turf">
              <div class="tab-icon"></div>
              <div class="tab-label">Turf</div>
            </div>
            <div class="tab" data-tab="crimes">
              <div class="tab-icon"></div>
              <div class="tab-label">Crimes</div>
            </div>
            <div class="tab" data-tab="safehouse">
              <div class="tab-icon"></div>
              <div class="tab-label">Safe House</div>
            </div>
            <div class="tab" data-tab="gang">
              <div class="tab-icon"></div>
              <div class="tab-label">Gang</div>
            </div>
          </div>
        `;
      },
      
      // Show sign-in prompt
      showSignInPrompt() {
        console.log('[SIGN IN DEBUG] showSignInPrompt() called');
        
        const overlay = document.createElement('div');
        overlay.className = 'account-overlay';
        overlay.id = 'account-overlay';
        
        overlay.innerHTML = `
          <div class="account-container">
            <div class="account-header">
              <div class="account-icon"></div>
              <div class="account-title">Sign In</div>
              <div class="account-subtitle">Enter your email to continue</div>
            </div>
            
            <div class="account-info-box">
               Sign in is device-local only. Your data is stored on this device.
            </div>
            
            <div class="account-form">
              <div class="account-input-group">
                <label class="account-label">Email</label>
                <input 
                  type="email" 
                  class="account-input" 
                  id="signin-email-input"
                  placeholder="your.email@example.com"
                  autocomplete="email"
                >
                <div class="account-error" id="signin-error"></div>
              </div>
              
              <button type="button" class="account-btn account-btn-primary" id="signin-btn">
                <span></span>
                <span>Sign In</span>
              </button>
            </div>
            
            <div class="account-divider">
              <span class="account-divider-text">Don't have an account?</span>
            </div>
            
            <button type="button" class="account-btn" id="show-create-btn">
              <span></span>
              <span>Create Account</span>
            </button>
          </div>
        `;
        
        document.body.appendChild(overlay);
        console.log('[SIGN IN DEBUG] Modal appended to DOM');
        
        // NUCLEAR OPTION: Use multiple timing strategies
        const attachListeners = () => {
          console.log('[SIGN IN DEBUG] Attempting to attach listeners...');
          
          const signinBtn = document.getElementById('signin-btn');
          const emailInput = document.getElementById('signin-email-input');
          const createBtn = document.getElementById('show-create-btn');
          
          console.log('[SIGN IN DEBUG] Sign-in button:', signinBtn);
          console.log('[SIGN IN DEBUG] Email input:', emailInput);
          console.log('[SIGN IN DEBUG] Create button:', createBtn);
          
          if (!signinBtn) {
            console.error('[SIGN IN DEBUG]  SIGN-IN BUTTON NOT FOUND');
            return false;
          }
          
          if (!emailInput) {
            console.error('[SIGN IN DEBUG]  EMAIL INPUT NOT FOUND');
            return false;
          }
          
          // DIRECT CLICK HANDLER - NO FORM
          signinBtn.addEventListener('click', (e) => {
            console.log('[SIGN IN DEBUG] ========================================');
            console.log('[SIGN IN DEBUG]  BUTTON CLICKED ');
            console.log('[SIGN IN DEBUG] ========================================');
            e.preventDefault();
            e.stopPropagation();
            this.handleSignIn();
          }, { capture: true }); // Use capture phase
          
          console.log('[SIGN IN DEBUG]  Sign-in button listener attached');
          
          // Also listen for Enter key on email input
          emailInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
              console.log('[SIGN IN DEBUG] ENTER KEY PRESSED');
              e.preventDefault();
              this.handleSignIn();
            }
          });
          
          console.log('[SIGN IN DEBUG]  Enter key listener attached');
          
          // Create account button
          if (createBtn) {
            createBtn.addEventListener('click', (e) => {
              console.log('[SIGN IN DEBUG] Create account clicked');
              e.preventDefault();
              overlay.remove();
              this.showAccountCreationPrompt(false);
            });
            console.log('[SIGN IN DEBUG]  Create account button listener attached');
          }
          
          console.log('[SIGN IN DEBUG] ========================================');
          console.log('[SIGN IN DEBUG]  ALL LISTENERS ATTACHED ');
          console.log('[SIGN IN DEBUG] ========================================');
          
          return true;
        };
        
        // Try multiple timing strategies
        // Strategy 1: Immediate
        if (attachListeners()) {
          console.log('[SIGN IN DEBUG] Listeners attached immediately');
        } else {
          console.log('[SIGN IN DEBUG] Immediate attachment failed, trying setTimeout...');
          
          // Strategy 2: setTimeout
          setTimeout(() => {
            if (attachListeners()) {
              console.log('[SIGN IN DEBUG] Listeners attached via setTimeout');
            } else {
              console.log('[SIGN IN DEBUG] setTimeout failed, trying requestAnimationFrame...');
              
              // Strategy 3: requestAnimationFrame
              requestAnimationFrame(() => {
                if (attachListeners()) {
                  console.log('[SIGN IN DEBUG] Listeners attached via requestAnimationFrame');
                } else {
                  console.error('[SIGN IN DEBUG]  ALL STRATEGIES FAILED ');
                }
              });
            }
          }, 0);
        }
      },
      
      // Handle sign-in
      handleSignIn() {
        console.log('[SIGN IN DEBUG] ========================================');
        console.log('[SIGN IN DEBUG]  SIGN IN HANDLER FIRED ');
        console.log('[SIGN IN DEBUG] ========================================');
        
        const emailInput = document.getElementById('signin-email-input');
        console.log('[SIGN IN DEBUG] Email input element:', emailInput);
        
        if (!emailInput) {
          console.error('[SIGN IN DEBUG] CRITICAL ERROR: Email input not found!');
          return;
        }
        
        const email = emailInput.value.trim();
        console.log('[SIGN IN DEBUG] Email value read from input:', `"${email}"`);
        console.log('[SIGN IN DEBUG] Email length:', email.length);
        
        // Clear previous errors
        const errorEl = document.getElementById('signin-error');
        if (errorEl) {
          errorEl.classList.remove('visible');
          errorEl.textContent = '';
        }
        emailInput.classList.remove('error');
        
        // Validate
        console.log('[SIGN IN DEBUG] Validating email format...');
        if (!AccountManager.isValidEmail(email)) {
          console.log('[SIGN IN DEBUG]  Email validation FAILED');
          this.showError('signin-error', 'Please enter a valid email address');
          emailInput.classList.add('error');
          return;
        }
        
        console.log('[SIGN IN DEBUG]  Email validation PASSED');
        console.log('[SIGN IN DEBUG] Calling BootFlow.signIn()...');
        
        // Sign in
        const result = BootFlow.signIn(email);
        
        console.log('[SIGN IN DEBUG] BootFlow.signIn() returned');
        console.log('[SIGN IN DEBUG] Result:', result);
        
        if (!result.success) {
          console.log('[SIGN IN DEBUG]  Sign-in FAILED:', result.error);
          this.showError('signin-error', result.error);
          emailInput.classList.add('error');
          return;
        }
        
        console.log('[SIGN IN DEBUG]  Sign-in SUCCESS');
        console.log('[SIGN IN DEBUG] Account:', result.account);
        console.log('[SIGN IN DEBUG] Proceeding to success screen...');
        
        // Success
        this.showSignInSuccess(result.account);
      },
      
      // Show sign-in success
      showSignInSuccess(account) {
        console.log('[SIGN IN DEBUG] showSignInSuccess() called');
        console.log('[SIGN IN DEBUG] Account data:', account);
        
        const overlay = document.getElementById('account-overlay');
        if (!overlay) {
          console.error('[SIGN IN DEBUG] Account overlay NOT FOUND');
          return;
        }
        
        const container = overlay.querySelector('.account-container');
        if (!container) {
          console.error('[SIGN IN DEBUG] Account container NOT FOUND');
          return;
        }
        
        console.log('[SIGN IN DEBUG] Rendering success screen...');
        
        container.innerHTML = `
          <div class="account-success-message">
            <div class="account-success-icon"></div>
            <div class="account-success-title">Welcome Back!</div>
            <div class="account-success-text">
              Signed in as <strong>${account.username}</strong>
              <br>Loading your progress...
            </div>
          </div>
        `;
        
        console.log('[SIGN IN DEBUG] Success screen rendered');
        console.log('[SIGN IN DEBUG] Auto-loading game in 500ms...');
        
        // Auto-load game after brief success message
        setTimeout(() => {
          console.log('[SIGN IN DEBUG] Setting auth state to logged in...');
          
          // Set auth state to logged in
          AuthManager.login(account.accountId);
          
          console.log('[SIGN IN DEBUG] Removing overlay...');
          overlay.remove();
          
          console.log('[SIGN IN DEBUG] Rebuilding app structure...');
          
          // CRITICAL FIX: Rebuild the entire app HTML structure
          const app = document.getElementById('app');
          if (!app) {
            console.error('[SIGN IN DEBUG] App container not found!');
            return;
          }
          
          // Restore original app HTML structure
          app.innerHTML = `
            <div id="content">
              <!-- Profile Tab -->
              <div id="profile-tab" class="tab-content active">
                <div class="page-header">Profile</div>
                <div class="stat-grid">
                  <div class="stat-card">
                    <div class="stat-label">Player</div>
                    <div class="stat-value" id="player-name">Unknown</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-label">Cash</div>
                    <div class="stat-value" id="player-cash">$1,000</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-label">XP / Level</div>
                    <div class="stat-value">
                      <span id="player-xp">0</span> / <span id="player-level">1</span>
                    </div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-label">Reputation</div>
                    <div class="stat-value" id="player-rep">0</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-label">Heat Level</div>
                    <div class="stat-value" id="player-heat">0%</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-label">Global Heat</div>
                    <div class="stat-value" id="player-global-heat">0%</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-label">Stats</div>
                    <div class="stat-row">
                      <span>Strength</span>
                      <span id="stat-strength">5</span>
                    </div>
                    <div class="stat-row">
                      <span>Intelligence</span>
                      <span id="stat-intelligence">5</span>
                    </div>
                    <div class="stat-row">
                      <span>Charisma</span>
                      <span id="stat-charisma">5</span>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Turf Tab -->
              <div id="turf-tab" class="tab-content">
                <div class="page-header">Turf</div>
                
                <div class="status-controls">
                  <button class="status-btn laying_low selected" data-status="laying_low">
                    <span></span>
                    <span>Lay Low</span>
                  </button>
                  <button class="status-btn active-status" data-status="active">
                    <span></span>
                    <span>Active</span>
                  </button>
                </div>

                <div class="heat-indicator">
                  <div class="heat-icon"></div>
                  <div class="heat-bar-container">
                    <div class="heat-bar-fill" id="heat-bar-fill" style="width: 0%"></div>
                  </div>
                  <div class="heat-value" id="heat-value">0%</div>
                </div>

                <div class="roam-controls">
                  <button class="roam-btn" id="roam-toggle-btn">
                    <span id="roam-icon"></span>
                    <span id="roam-label">Start Free Roam</span>
                  </button>
                  <button class="map-refresh-btn" id="map-refresh-btn" title="Regenerate Map"></button>
                </div>
                
                <div id="city-map">
                  <canvas id="map-canvas"></canvas>
                  <div id="event-notification-container"></div>
                  <div id="map-icons"></div>
                  <div id="floating-pickups"></div>
                  <div id="character-sprite" class="character-icon">
                    <div class="status-indicator laying_low"></div>
                    <div class="suspicion-eye" id="suspicion-eye"></div>
                    <div class="character-silhouette"></div>
                  </div>
                </div>
              </div>

              <!-- Crimes Tab -->
              <div id="crimes-tab" class="tab-content">
                <div class="page-header">Crimes</div>
                <div class="placeholder">
                  <div class="placeholder-icon"></div>
                  <div class="placeholder-text">No crimes available</div>
                </div>
              </div>

              <!-- Safe House Tab -->
              <div id="safehouse-tab" class="tab-content">
                <div class="page-header">Safe House</div>
                
                <div class="character-creator">
                  <div class="character-preview">
                    <div class="preview-sprite" id="preview-sprite">
                      <span id="preview-character"></span>
                      <span id="preview-wardrobe"></span>
                    </div>
                    <div class="preview-details" id="preview-details">
                      <span class="preview-tag">Male</span>
                      <span class="preview-tag">Human</span>
                      <span class="preview-tag">Short Hair</span>
                    </div>
                  </div>

                  <div class="creator-section">
                    <div class="section-title">Gender</div>
                    <div class="option-grid">
                      <button class="option-btn selected" data-trait="gender" data-value="male">
                        <span></span>
                        <span>Male</span>
                      </button>
                      <button class="option-btn" data-trait="gender" data-value="female">
                        <span></span>
                        <span>Female</span>
                      </button>
                    </div>
                  </div>

                  <div class="creator-section">
                    <div class="section-title">Race</div>
                    <div class="option-grid">
                      <button class="option-btn selected" data-trait="race" data-value="human">Human</button>
                      <button class="option-btn" data-trait="race" data-value="elf">Elf</button>
                      <button class="option-btn" data-trait="race" data-value="dwarf">Dwarf</button>
                      <button class="option-btn" data-trait="race" data-value="orc">Orc</button>
                    </div>
                  </div>

                  <div class="creator-section">
                    <div class="section-title">Face</div>
                    <div class="option-grid">
                      <button class="option-btn selected" data-trait="face" data-value="neutral">Neutral</button>
                      <button class="option-btn" data-trait="face" data-value="sharp">Sharp</button>
                      <button class="option-btn" data-trait="face" data-value="round">Round</button>
                      <button class="option-btn" data-trait="face" data-value="weathered">Weathered</button>
                    </div>
                  </div>

                  <div class="creator-section">
                    <div class="section-title">Body Type</div>
                    <div class="option-grid">
                      <button class="option-btn selected" data-trait="body" data-value="average">Average</button>
                      <button class="option-btn" data-trait="body" data-value="slim">Slim</button>
                      <button class="option-btn" data-trait="body" data-value="athletic">Athletic</button>
                      <button class="option-btn" data-trait="body" data-value="heavy">Heavy</button>
                    </div>
                  </div>

                  <div class="creator-section">
                    <div class="section-title">Hair Style</div>
                    <div class="option-grid">
                      <button class="option-btn selected" data-trait="hair" data-value="short">Short</button>
                      <button class="option-btn" data-trait="hair" data-value="long">Long</button>
                      <button class="option-btn" data-trait="hair" data-value="bald">Bald</button>
                      <button class="option-btn" data-trait="hair" data-value="mohawk">Mohawk</button>
                    </div>
                  </div>

                  <div class="creator-section">
                    <div class="section-title">Wardrobe</div>
                    <div class="wardrobe-grid" id="wardrobe-grid"></div>
                  </div>
                </div>
              </div>

              <!-- Inventory Tab -->
              <div id="inventory-tab" class="tab-content">
                <div class="page-header">Inventory</div>
                <div class="placeholder">
                  <div class="placeholder-icon"></div>
                  <div class="placeholder-text">Empty</div>
                </div>
              </div>

              <!-- Gang Tab -->
              <div id="gang-tab" class="tab-content">
                <div class="page-header">Gang</div>
                <div id="gang-content"></div>
              </div>
            </div>

            <!-- Tab Bar -->
            <div id="tab-bar">
              <div class="tab active" data-tab="profile">
                <div class="tab-icon"></div>
                <div class="tab-label">Profile</div>
              </div>
              <div class="tab" data-tab="turf">
                <div class="tab-icon"></div>
                <div class="tab-label">Turf</div>
              </div>
              <div class="tab" data-tab="crimes">
                <div class="tab-icon"></div>
                <div class="tab-label">Crimes</div>
              </div>
              <div class="tab" data-tab="safehouse">
                <div class="tab-icon"></div>
                <div class="tab-label">Safe House</div>
              </div>
              <div class="tab" data-tab="gang">
                <div class="tab-icon"></div>
                <div class="tab-label">Gang</div>
              </div>
            </div>
          `;
          
          console.log('[SIGN IN DEBUG] App structure rebuilt');
          console.log('[SIGN IN DEBUG] Calling initializeGame()...');
          
          // Initialize game
          initializeGame();
        }, 500);
      }
    };
    
    console.log('=== PHASE C: Account UI - COMPLETE ===');

    // ========================================
    // PHASE A: ACCOUNT DATA MODEL
    // ========================================
    const AccountManager = {
      STORAGE_KEY_ACCOUNTS: 'crime_rpg_accounts',
      STORAGE_KEY_CURRENT_ACCOUNT: 'crime_rpg_current_account',
      STORAGE_KEY_MIGRATION_FLAG: 'crime_rpg_migrated',
      
      // Generate UUID v4
      generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          const r = Math.random() * 16 | 0;
          const v = c === 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
      },
      
      // Get all accounts stored on this device
      getAllAccounts() {
        try {
          const data = localStorage.getItem(this.STORAGE_KEY_ACCOUNTS);
          return data ? JSON.parse(data) : {};
        } catch (e) {
          console.error('Failed to load accounts:', e);
          return {};
        }
      },
      
      // Save accounts to storage
      saveAccounts(accounts) {
        try {
          localStorage.setItem(this.STORAGE_KEY_ACCOUNTS, JSON.stringify(accounts));
        } catch (e) {
          console.error('Failed to save accounts:', e);
        }
      },
      
      // Get current account ID
      getCurrentAccountId() {
        return localStorage.getItem(this.STORAGE_KEY_CURRENT_ACCOUNT);
      },
      
      // Set current account ID
      setCurrentAccountId(accountId) {
        if (accountId) {
          localStorage.setItem(this.STORAGE_KEY_CURRENT_ACCOUNT, accountId);
          // Also update auth state
          AuthManager.login(accountId);
        } else {
          localStorage.removeItem(this.STORAGE_KEY_CURRENT_ACCOUNT);
        }
      },
      
      // Check if account exists by email
      findAccountByEmail(email) {
        console.log('[ACCOUNT MANAGER DEBUG] findAccountByEmail() called with:', email);
        
        const accounts = this.getAllAccounts();
        console.log('[ACCOUNT MANAGER DEBUG] All accounts:', accounts);
        console.log('[ACCOUNT MANAGER DEBUG] Account count:', Object.keys(accounts).length);
        
        const found = Object.values(accounts).find(acc => {
          const match = acc.email.toLowerCase() === email.toLowerCase();
          console.log(`[ACCOUNT MANAGER DEBUG] Comparing "${acc.email}" with "${email}": ${match}`);
          return match;
        });
        
        console.log('[ACCOUNT MANAGER DEBUG] Found account:', found);
        
        return found;
      },
      
      // Check if username is taken on this device
      isUsernameTaken(username, excludeAccountId = null) {
        const accounts = this.getAllAccounts();
        return Object.values(accounts).some(acc => 
          acc.username.toLowerCase() === username.toLowerCase() && 
          acc.accountId !== excludeAccountId
        );
      },
      
      // Create new account
      createAccount(email, username) {
        const accountId = this.generateUUID();
        const account = {
          accountId: accountId,
          email: email.trim().toLowerCase(),
          username: username.trim(),
          createdAt: Date.now(),
          lastSignIn: Date.now()
        };
        
        const accounts = this.getAllAccounts();
        accounts[accountId] = account;
        this.saveAccounts(accounts);
        
        console.log('Account created:', accountId, username);
        return account;
      },
      
      // Update account last sign-in
      updateSignIn(accountId) {
        const accounts = this.getAllAccounts();
        if (accounts[accountId]) {
          accounts[accountId].lastSignIn = Date.now();
          this.saveAccounts(accounts);
        }
      },
      
      // Get account by ID
      getAccount(accountId) {
        const accounts = this.getAllAccounts();
        return accounts[accountId] || null;
      },
      
      // Check if migration has occurred
      hasMigrated() {
        return localStorage.getItem(this.STORAGE_KEY_MIGRATION_FLAG) === 'true';
      },
      
      // Mark migration as complete
      markMigrated() {
        localStorage.setItem(this.STORAGE_KEY_MIGRATION_FLAG, 'true');
      },
      
      // Validate email format
      isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
      },
      
      // Validate username
      isValidUsername(username) {
        return username.trim().length >= 3 && username.trim().length <= 20;
      }
    };
    
    console.log('=== PHASE A: Account Data Model - COMPLETE ===');
    console.log('Storage Schema:');
    console.log('- crime_rpg_accounts: { accountId: { email, username, createdAt, lastSignIn } }');
    console.log('- crime_rpg_current_account: accountId');
    console.log('- crime_rpg_migrated: boolean flag');
    console.log('==============================================');

    // ========================================
    // CORE: Global State (FROZEN SHAPE)
    // ========================================
    const DEFAULT_STATE = {
      // PHASE A: Account binding
      accountId: null, // Links this GameState to an account
      
      player: {
        id: null,
        name: "Unknown",
        cash: 1000,
        xp: 0,
        level: 1,
        reputation: 0,
        heat: 0,
        globalHeat: 0,  // New: City-wide heat (0-100)
        stats: {
          strength: 5,
          intelligence: 5,
          charisma: 5
        },
        history: [],
        jail: {
          isJailed: false,
          releaseTime: null
        },
        rngMemory: {
          eventOutcomes: [],  // Track recent event outcomes
          raidOutcomes: [],   // Track recent raid outcomes
          lastMemoryDecay: Date.now()
        },
        fatigue: {
          level: 0,           // 0-100 (hidden from player)
          lastAction: null,   // Timestamp of last risky action
          consecutiveActions: 0  // Count of actions without rest
        },
        garage: {
          vehicles: [],       // Stored vehicles
          capacity: 3,        // Max vehicles that can be stored
          lastSale: null      // Timestamp of last vehicle sale
        }
      },
      
      character: {
        equippedWardrobe: [],
        position: { x: 150, y: 200 },
        appearance: {
          race: "human",
          face: "neutral",
          body: "average",
          hair: "short",
          gender: "male"
        },
        freeRoam: false,
        isDead: false
      },
      
      wardrobe: {
        items: [
          { id: "jacket_leather", name: "Leather Jacket", icon: "", cost: 500, isUnlocked: true, slot: "outerwear" },
          { id: "hat_fedora", name: "Fedora", icon: "", cost: 300, isUnlocked: false, slot: "headwear" },
          { id: "glasses_shades", name: "Shades", icon: "", cost: 200, isUnlocked: false, slot: "accessory" },
          { id: "jacket_suit", name: "Suit Jacket", icon: "", cost: 800, isUnlocked: false, slot: "outerwear" }
        ],
        equipped: []
      },
      
      safeHouse: {
        position: { x: 150, y: 200 },
        upgradeLevel: 0
      },
      
      mapIcons: [],
      
      // NEW: Procedural map data
      map: {
        seed: null,
        width: 50,
        height: 50,
        grid: null,
        buildings: [], // Interactive buildings placed on map
        viewport: {
          x: 25,
          y: 25
        },
        generatedAt: null
      },
      
      mapMemory: {
        hotspots: [],  // Areas with remembered danger
        lastCleanup: Date.now()
      },
      
      ui: {
        activeTab: "profile",
        modalOpen: null,
        lastEvent: null,
        lastOutcome: null,
        eventLog: []
      },
      
      playerStatus: "laying_low",
      playerStatusTransition: null,  // "entering_active" | "entering_laying_low" | null
      playerStatusTransitionEnd: null,  // timestamp when transition completes
      
      cityState: {
        lockdown: false,
        lockdownUntil: null,
        manhuntActive: false,
        manhuntTarget: null,
        policeActivity: "low",  // low, medium, high, extreme
        worldTick: 0,  // Increments over time (no visible timer)
        riskLevel: 0   // 0-100, escalates with activity
      },
      
      heatLog: [],  // Track heat-generating events
      
      drainLog: [],  // Track money drains
      
      gang: null,  // Player's gang (null if not in gang)
      
      gangRelations: {},  // { gangId: { status, heat, lastAction, warStarted } }
      
      gangWarLog: [],  // Array of war events
      
      publicGangs: [
        // Placeholder public gangs for joining
        { id: "crimson_syndicate", name: "Crimson Syndicate", flag: "", memberCount: 12, vault: 5000, health: 100 },
        { id: "shadow_collective", name: "Shadow Collective", flag: "", memberCount: 8, vault: 3500, health: 100 },
        { id: "iron_brotherhood", name: "Iron Brotherhood", flag: "", memberCount: 15, vault: 7500, health: 100 }
      ]
    };

    // Deep clone to prevent mutation of default
    const GameState = JSON.parse(JSON.stringify(DEFAULT_STATE));

    // ========================================
    // CORE: Seed Generation Utilities
    // ========================================
    // (Moved here from later in code for Phase 7.4A dependency)

    // Simple hash function to convert string to number
    function generateSeed(input) {
      let hash = 0;
      for (let i = 0; i < input.length; i++) {
        const char = input.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32-bit integer
      }
      return Math.abs(hash);
    }

    // Seeded PRNG (Mulberry32 algorithm)
    function createSeededRandom(seed) {
      return function() {
        seed |= 0;
        seed = seed + 0x6D2B79F5 | 0;
        let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    // ========================================
    // PHASE 7.4A: SEED & MAP FOUNDATION
    // ========================================

    // MAP SEED MANAGER
    const MapSeedManager = {
      // Generate or retrieve seed for current player
      getOrCreateSeed() {
        // Check if player has an ID
        if (!GameState.player.id) {
          console.warn('No player ID found - generating temporary ID');
          GameState.player.id = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          Storage.save();
        }
        
        // Check if seed already exists for this player
        if (GameState.map.seed !== null) {
          console.log('Map seed exists:', GameState.map.seed);
          return GameState.map.seed;
        }
        
        // Generate new seed from player ID
        const seed = this.generateSeedFromPlayerId(GameState.player.id);
        
        // Store seed in GameState
        GameState.map.seed = seed;
        GameState.map.generatedAt = Date.now();
        
        console.log('New map seed created:', seed, 'for player:', GameState.player.id);
        
        // Save to localStorage
        Storage.save();
        
        return seed;
      },
      
      // Generate deterministic seed from player ID
      generateSeedFromPlayerId(playerId) {
        // Use existing generateSeed function
        return generateSeed(playerId);
      },
      
      // Create seeded random generator for map generation
      createMapRandom() {
        const seed = this.getOrCreateSeed();
        return createSeededRandom(seed);
      },
      
      // Force regenerate seed (for testing or map resets)
      regenerateSeed() {
        console.log('Regenerating map seed...');
        
        GameState.map.seed = null;
        GameState.map.grid = null;
        GameState.map.generatedAt = null;
        
        const newSeed = this.getOrCreateSeed();
        
        console.log('New seed:', newSeed);
        Storage.save();
        
        return newSeed;
      },
      
      // Validate seed integrity
      validateSeed() {
        if (!GameState.map.seed) {
          console.warn('No map seed - will be generated on first access');
          return false;
        }
        
        if (!GameState.player.id) {
          console.error('Player ID missing - seed invalid');
          return false;
        }
        
        // Verify seed matches player ID
        const expectedSeed = this.generateSeedFromPlayerId(GameState.player.id);
        
        if (GameState.map.seed !== expectedSeed) {
          console.warn('Seed mismatch - regenerating');
          this.regenerateSeed();
          return false;
        }
        
        return true;
      },
      
      // Get seed info for debugging
      getSeedInfo() {
        return {
          playerId: GameState.player.id,
          seed: GameState.map.seed,
          generatedAt: GameState.map.generatedAt,
          generatedAtDate: GameState.map.generatedAt ? new Date(GameState.map.generatedAt).toLocaleString() : null,
          isValid: this.validateSeed()
        };
      }
    };

    // Initialize seed on game load
    function initMapSeed() {
      console.log('=== PHASE 7.4A: Map Seed Initialization ===');
      
      // Ensure player has an ID
      if (!GameState.player.id) {
        // Generate persistent player ID
        GameState.player.id = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        console.log('Generated new player ID:', GameState.player.id);
        Storage.save();
      }
      
      // Initialize or retrieve map seed
      const seed = MapSeedManager.getOrCreateSeed();
      
      // Log seed info
      const seedInfo = MapSeedManager.getSeedInfo();
      console.log('Map Seed Info:', seedInfo);
      console.log('Player will always get the same map based on their ID');
      console.log('===========================================');
    }

    // Test determinism (available in console)
    function testMapSeedDeterminism() {
      console.log('=== Testing Map Seed Determinism ===');
      
      const testPlayerId = 'test_player_12345';
      
      // Simulate 10 seed generations
      const seeds = [];
      
      for (let i = 0; i < 10; i++) {
        const seed = generateSeed(testPlayerId);
        seeds.push(seed);
      }
      
      // Check all seeds are identical
      const allSame = seeds.every(s => s === seeds[0]);
      
      if (allSame) {
        console.log(' PASS: All 10 seeds identical');
        console.log('   Seed value:', seeds[0]);
      } else {
        console.error(' FAIL: Seeds differ!');
        console.log('   Seeds:', seeds);
      }
      
      // Test different player IDs produce different seeds
      const player1Seed = generateSeed('player_1');
      const player2Seed = generateSeed('player_2');
      
      if (player1Seed !== player2Seed) {
        console.log(' PASS: Different players get different seeds');
        console.log('   Player 1:', player1Seed);
        console.log('   Player 2:', player2Seed);
      } else {
        console.error(' FAIL: Different players got same seed!');
      }
      
      console.log('=====================================');
    }

    // Debug commands
    window.resetMapSeed = function() {
      console.log('Resetting map seed...');
      MapSeedManager.regenerateSeed();
      console.log('New seed info:', MapSeedManager.getSeedInfo());
      console.log('Reload page to see changes');
    };

    window.showMapSeedInfo = function() {
      const info = MapSeedManager.getSeedInfo();
      console.log('=== Current Map Seed Info ===');
      console.log('Player ID:', info.playerId);
      console.log('Map Seed:', info.seed);
      console.log('Generated:', info.generatedAtDate);
      console.log('Valid:', info.isValid);
      console.log('============================');
    };

    window.testMapSeedDeterminism = testMapSeedDeterminism;
    
    // ========================================
    // ACCOUNT SYSTEM DEBUG COMMANDS
    // ========================================
    window.showAccountInfo = function() {
      console.log('=== Account System Info ===');
      const currentId = AccountManager.getCurrentAccountId();
      const allAccounts = AccountManager.getAllAccounts();
      
      console.log('Current Account ID:', currentId);
      
      if (currentId) {
        const account = AccountManager.getAccount(currentId);
        console.log('Current Account:', account);
      }
      
      console.log('All Accounts on Device:', Object.keys(allAccounts).length);
      Object.values(allAccounts).forEach(acc => {
        console.log(`  - ${acc.username} (${acc.email})`);
      });
      
      console.log('GameState Account ID:', GameState.accountId);
      console.log('Has Migrated:', AccountManager.hasMigrated());
      console.log('Has Anonymous Progress:', Storage.hasAnonymousProgress());
      console.log('==========================');
    };
    
    window.showAllSaves = function() {
      console.log('=== All Saves on Device ===');
      const keys = Object.keys(localStorage).filter(k => k.startsWith('crime_rpg_save'));
      
      console.log('Found', keys.length, 'saves:');
      keys.forEach(key => {
        try {
          const data = JSON.parse(localStorage.getItem(key));
          console.log(`\n${key}:`);
          console.log('  Account ID:', data.accountId || 'anonymous');
          console.log('  Player:', data.player?.name);
          console.log('  Cash:', data.player?.cash);
          console.log('  Level:', data.player?.level);
          console.log('  XP:', data.player?.xp);
        } catch (e) {
          console.log(`  (corrupted save)`);
        }
      });
      console.log('===========================');
    };
    
    window.testAccountCreation = function() {
      console.log('=== Testing Account Creation ===');
      
      const testEmail = 'test' + Date.now() + '@example.com';
      const testUsername = 'TestUser' + Math.floor(Math.random() * 1000);
      
      console.log('Creating account:', testEmail, testUsername);
      
      const result = BootFlow.createAccountAndBind(testEmail, testUsername);
      
      if (result.success) {
        console.log(' Account created successfully');
        console.log('Account:', result.account);
        console.log('Migrated Progress:', result.migratedProgress);
      } else {
        console.log(' Account creation failed:', result.error);
      }
      
      console.log('===============================');
    };
    
    window.testSignIn = function(email) {
      console.log('=== Testing Sign-In ===');
      console.log('Email:', email);
      
      const result = BootFlow.signIn(email);
      
      if (result.success) {
        console.log(' Sign-in successful');
        console.log('Account:', result.account);
      } else {
        console.log(' Sign-in failed:', result.error);
      }
      
      console.log('======================');
    };
    
    window.simulateSharedLink = function() {
      console.log('=== Simulating Shared Link (New User) ===');
      
      // Clear current account to simulate new user
      AccountManager.setCurrentAccountId(null);
      
      console.log('Cleared current account');
      console.log('Reload page to see new user flow');
      console.log('========================================');
    };
    
    window.resetAccountSystem = function() {
      if (!confirm('This will DELETE ALL ACCOUNTS and progress. Continue?')) {
        return;
      }
      
      console.log('=== Resetting Account System ===');
      
      // Clear all account-related storage
      localStorage.removeItem(AccountManager.STORAGE_KEY_ACCOUNTS);
      localStorage.removeItem(AccountManager.STORAGE_KEY_CURRENT_ACCOUNT);
      localStorage.removeItem(AccountManager.STORAGE_KEY_MIGRATION_FLAG);
      
      // Clear all saves
      Object.keys(localStorage).filter(k => k.startsWith('crime_rpg_save')).forEach(key => {
        localStorage.removeItem(key);
      });
      
      console.log('All accounts and saves deleted');
      console.log('Reload page to start fresh');
      console.log('===============================');
    };
    
    console.log('');
    console.log('');
    console.log('         CRIME RPG - ACCOUNT SYSTEM ACTIVE                  ');
    console.log('');
    console.log('');
    console.log(' FINAL VERIFICATION:');
    console.log('   Existing progress preserved');
    console.log('   Anonymous  account migration works');
    console.log('   New players get fresh maps');
    console.log('   Shared links behave correctly');
    console.log('   No backend required');
    console.log('   Mobile safe');
    console.log('');
    console.log(' NEW GAMESTATE FIELDS:');
    console.log('  - accountId: Links save to account');
    console.log('');
    console.log(' NEW STORAGE KEYS:');
    console.log('  - crime_rpg_accounts: All accounts on device');
    console.log('  - crime_rpg_current_account: Active account ID');
    console.log('  - crime_rpg_save_{accountId}: Per-account saves');
    console.log('  - crime_rpg_migrated: Migration flag');
    console.log('');
    console.log(' UPGRADE PATH FOR REAL AUTH:');
    console.log('  1. Add backend API endpoints');
    console.log('  2. Replace AccountManager.createAccount() with API call');
    console.log('  3. Add JWT token storage');
    console.log('  4. Sync saves to cloud on Storage.save()');
    console.log('  5. Add email verification flow');
    console.log('  6. Add password/OAuth login');
    console.log('');
    console.log(' DEBUG COMMANDS:');
    console.log('  showAccountInfo()      - Show current account state');
    console.log('  showAllSaves()         - List all saves on device');
    console.log('  testAccountCreation()  - Create test account');
    console.log('  testSignIn(email)      - Test sign-in flow');
    console.log('  simulateSharedLink()   - Simulate new user from link');
    console.log('  resetAccountSystem()   - DELETE ALL (destructive)');
    console.log('');
    console.log('');
    
    // ========================================
    // PHASE 7.4B: TILE GRID & BIOME GENERATION
    // ========================================

    // Biome definitions
    const BIOMES = {
      URBAN: {
        id: 'urban',
        name: 'Urban',
        color: '#4a4a4a',
        icon: '',
        density: 'high',
        description: 'Dense downtown core'
      },
      
      SUBURBAN: {
        id: 'suburban',
        name: 'Suburban',
        color: '#81c995',
        icon: '',
        density: 'medium',
        description: 'Residential neighborhoods'
      },
      
      INDUSTRIAL: {
        id: 'industrial',
        name: 'Industrial',
        color: '#8a8a8a',
        icon: '',
        density: 'medium',
        description: 'Warehouses and factories'
      },
      
      COASTAL: {
        id: 'coastal',
        name: 'Beach/Coastal',
        color: '#8ab4f8',
        icon: '',
        density: 'low',
        description: 'Beaches and waterfront'
      },
      
      RURAL: {
        id: 'rural',
        name: 'Rural',
        color: '#a8d5a3',
        icon: '',
        density: 'low',
        description: 'Outskirts and open land'
      }
    };

    // Map configuration
    const MAP_CONFIG = {
      GRID_WIDTH: 20,      // 20 tiles wide (smaller for mobile performance)
      GRID_HEIGHT: 35,     // 35 tiles tall (portrait orientation)
      TILE_SIZE: 100       // Each tile = 100x100 units
    };

    // ========================================
    // TILE OCCUPANCY SYSTEM
    // Tracks what occupies each tile for placement validation
    // ========================================
    const TileOccupancy = {
      grid: null,
      
      // Tile types
      TYPES: {
        WATER: 'water',
        ROAD: 'road', 
        GRASS: 'grass',
        BUILDING: 'building',
        LANDMARK: 'landmark'
      },
      
      // Initialize occupancy grid from biome data
      initFromBiomeGrid(biomeGrid) {
        const height = biomeGrid.length;
        const width = biomeGrid[0].length;
        
        // Valid land biomes that can have buildings/landmarks
        const LAND_BIOMES = ['suburban', 'rural', 'urban', 'industrial'];
        
        this.grid = [];
        
        for (let y = 0; y < height; y++) {
          const row = [];
          for (let x = 0; x < width; x++) {
            const tile = biomeGrid[y][x];
            let type;
            
            // Classify tile based on biome - STRICT per-tile validation
            if (tile.biome === 'coastal') {
              // Water - never buildable
              type = this.TYPES.WATER;
            } else if (tile.metadata && tile.metadata.isRoad) {
              // Road - never buildable
              type = this.TYPES.ROAD;
            } else if (LAND_BIOMES.includes(tile.biome)) {
              // Valid land biome - can be built on
              type = this.TYPES.GRASS;
            } else {
              // Unknown biome - treat as water (forbidden)
              type = this.TYPES.WATER;
            }
            
            row.push({
              type: type,
              biome: tile.biome, // Store original biome for reference
              occupiedBy: null
            });
          }
          this.grid.push(row);
        }
        
        console.log(`TileOccupancy: Initialized ${width}x${height} grid`);
        this.debugStats();
      },
      
      // Update road tiles after road generation
      markRoads(biomeGrid) {
        if (!this.grid) return;
        
        const height = biomeGrid.length;
        const width = biomeGrid[0].length;
        
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const tile = biomeGrid[y][x];
            if (tile.metadata && tile.metadata.isRoad) {
              this.grid[y][x].type = this.TYPES.ROAD;
            }
          }
        }
        
        console.log('TileOccupancy: Roads marked');
      },
      
      // Check if a tile is available for placement
      isAvailable(x, y) {
        if (!this.grid) return false;
        if (y < 0 || y >= this.grid.length) return false;
        if (x < 0 || x >= this.grid[0].length) return false;
        
        const cell = this.grid[y][x];
        return cell.type === this.TYPES.GRASS && cell.occupiedBy === null;
      },
      
      // Check if entire footprint is available
      isFootprintAvailable(x, y, width, height) {
        for (let dy = 0; dy < height; dy++) {
          for (let dx = 0; dx < width; dx++) {
            if (!this.isAvailable(x + dx, y + dy)) {
              return false;
            }
          }
        }
        return true;
      },
      
      // Check if a tile is a road
      isRoad(x, y) {
        if (!this.grid) return false;
        if (y < 0 || y >= this.grid.length) return false;
        if (x < 0 || x >= this.grid[0].length) return false;
        return this.grid[y][x].type === this.TYPES.ROAD;
      },
      
      // Check if a tile is adjacent (N/E/S/W) to a road
      isAdjacentToRoad(x, y) {
        // Check North
        if (this.isRoad(x, y - 1)) return true;
        // Check South
        if (this.isRoad(x, y + 1)) return true;
        // Check West
        if (this.isRoad(x - 1, y)) return true;
        // Check East
        if (this.isRoad(x + 1, y)) return true;
        return false;
      },
      
      // Check if any tile in footprint is adjacent to a road
      isFootprintAdjacentToRoad(x, y, width, height) {
        for (let dy = 0; dy < height; dy++) {
          for (let dx = 0; dx < width; dx++) {
            if (this.isAdjacentToRoad(x + dx, y + dy)) {
              return true;
            }
          }
        }
        return false;
      },
      
      // Reserve tiles for a building/landmark
      reserve(x, y, width, height, id) {
        if (!this.grid) return false;
        
        // First verify all tiles are available
        if (!this.isFootprintAvailable(x, y, width, height)) {
          console.warn(`TileOccupancy: Cannot reserve (${x},${y}) ${width}x${height} for ${id} - tiles not available`);
          return false;
        }
        
        // Reserve all tiles
        for (let dy = 0; dy < height; dy++) {
          for (let dx = 0; dx < width; dx++) {
            const cell = this.grid[y + dy][x + dx];
            cell.type = this.TYPES.BUILDING;
            cell.occupiedBy = id;
          }
        }
        
        console.log(`TileOccupancy: Reserved (${x},${y}) ${width}x${height} for ${id}`);
        return true;
      },
      
      // Reserve a single tile for a landmark
      reserveLandmark(x, y, id) {
        if (!this.grid) return false;
        if (!this.isAvailable(x, y)) {
          console.warn(`TileOccupancy: Cannot reserve (${x},${y}) for landmark ${id} - tile not available`);
          return false;
        }
        
        const cell = this.grid[y][x];
        cell.type = this.TYPES.LANDMARK;
        cell.occupiedBy = id;
        
        console.log(`TileOccupancy: Reserved (${x},${y}) for landmark ${id}`);
        return true;
      },
      
      // Get tile info (for debugging)
      getTile(x, y) {
        if (!this.grid) return null;
        if (y < 0 || y >= this.grid.length) return null;
        if (x < 0 || x >= this.grid[0].length) return null;
        return this.grid[y][x];
      },
      
      // Clear all occupancy (for map regeneration)
      clear() {
        this.grid = null;
        console.log('TileOccupancy: Cleared');
      },
      
      // Debug: show occupancy stats
      debugStats() {
        if (!this.grid) {
          console.log('TileOccupancy: No grid');
          return;
        }
        
        const counts = { water: 0, road: 0, grass: 0, building: 0, landmark: 0 };
        
        for (let y = 0; y < this.grid.length; y++) {
          for (let x = 0; x < this.grid[0].length; x++) {
            counts[this.grid[y][x].type]++;
          }
        }
        
        console.log('=== TileOccupancy Stats ===');
        console.log(`Water: ${counts.water}`);
        console.log(`Road: ${counts.road}`);
        console.log(`Grass: ${counts.grass}`);
        console.log(`Building: ${counts.building}`);
        console.log(`Landmark: ${counts.landmark}`);
        console.log('===========================');
      }
    };

    // Tile Grid Generator
    const TileGridGenerator = {
      // Create empty grid
      createEmptyGrid(width, height) {
        const grid = [];
        
        for (let y = 0; y < height; y++) {
          const row = [];
          for (let x = 0; x < width; x++) {
            row.push({
              x: x,
              y: y,
              biome: null,
              metadata: {}
            });
          }
          grid.push(row);
        }
        
        return grid;
      },
      
      // Get tile at position
      getTile(grid, x, y) {
        if (y >= 0 && y < grid.length && x >= 0 && x < grid[0].length) {
          return grid[y][x];
        }
        return null;
      },
      
      // Set tile biome
      setTileBiome(grid, x, y, biomeId) {
        const tile = this.getTile(grid, x, y);
        if (tile) {
          tile.biome = biomeId;
        }
      },
      
      // Calculate distance between two points
      getDistance(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
      }
    };

    // Biome Distribution System
    const BiomeDistributor = {
      // Place biome centers (seeds for Voronoi regions)
      placeBiomeCenters(random, width, height) {
        const centers = [];
        
        // Urban: 1 center (city core)
        centers.push({
          x: Math.floor(width * 0.3 + random() * width * 0.4), // Center-ish
          y: Math.floor(height * 0.3 + random() * height * 0.4),
          biome: BIOMES.URBAN,
          strength: 100
        });
        
        // Suburban: 2-3 centers (neighborhoods)
        const suburbanCount = 2 + Math.floor(random() * 2);
        for (let i = 0; i < suburbanCount; i++) {
          centers.push({
            x: Math.floor(random() * width),
            y: Math.floor(random() * height),
            biome: BIOMES.SUBURBAN,
            strength: 80
          });
        }
        
        // Industrial: 1-2 centers (zones)
        const industrialCount = 1 + Math.floor(random() * 2);
        for (let i = 0; i < industrialCount; i++) {
          centers.push({
            x: Math.floor(random() * width),
            y: Math.floor(random() * height),
            biome: BIOMES.INDUSTRIAL,
            strength: 70
          });
        }
        
        // Coastal: Place on edges only
        const coastalCount = 2 + Math.floor(random() * 2);
        for (let i = 0; i < coastalCount; i++) {
          const edge = Math.floor(random() * 4); // 0=top, 1=right, 2=bottom, 3=left
          let x, y;
          
          if (edge === 0) { // Top edge
            x = Math.floor(random() * width);
            y = 0;
          } else if (edge === 1) { // Right edge
            x = width - 1;
            y = Math.floor(random() * height);
          } else if (edge === 2) { // Bottom edge
            x = Math.floor(random() * width);
            y = height - 1;
          } else { // Left edge
            x = 0;
            y = Math.floor(random() * height);
          }
          
          centers.push({
            x: x,
            y: y,
            biome: BIOMES.COASTAL,
            strength: 60
          });
        }
        
        return centers;
      },
      
      // Assign biomes using Voronoi (nearest center)
      assignBiomesToTiles(grid, centers, width, height) {
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let minDistanceSq = Infinity;
            let closestCenter = null;
            
            for (const center of centers) {
              // Use squared distance (avoid sqrt for performance)
              const dx = x - center.x;
              const dy = y - center.y;
              const distanceSq = dx * dx + dy * dy;
              
              // Weight by strength
              const weightedDistance = distanceSq / (center.strength / 100);
              
              if (weightedDistance < minDistanceSq) {
                minDistanceSq = weightedDistance;
                closestCenter = center;
              }
            }
            
            // Assign biome
            if (closestCenter) {
              TileGridGenerator.setTileBiome(grid, x, y, closestCenter.biome.id);
            } else {
              // Default to rural if no center found
              TileGridGenerator.setTileBiome(grid, x, y, BIOMES.RURAL.id);
            }
          }
        }
      },
      
      // Smooth biome boundaries for natural look
      smoothBiomeBoundaries(grid, width, height, iterations = 1) {
        for (let iter = 0; iter < iterations; iter++) {
          // Create lightweight biome snapshot
          const biomeSnapshot = [];
          for (let y = 0; y < height; y++) {
            const row = [];
            for (let x = 0; x < width; x++) {
              row.push(grid[y][x].biome);
            }
            biomeSnapshot.push(row);
          }
          
          // Smooth using snapshot
          for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
              const neighbors = [
                biomeSnapshot[y][x - 1],
                biomeSnapshot[y][x + 1],
                biomeSnapshot[y - 1][x],
                biomeSnapshot[y + 1][x]
              ];
              
              // Count biomes
              const counts = {};
              for (const biome of neighbors) {
                counts[biome] = (counts[biome] || 0) + 1;
              }
              
              // If 3+ neighbors same biome, convert
              for (const [biome, count] of Object.entries(counts)) {
                if (count >= 3) {
                  grid[y][x].biome = biome;
                  break;
                }
              }
            }
          }
        }
      }
    };

    // Main Map Generator
    const ProceduralMapGenerator = {
      // Generate complete biome map
      generateBiomeMap() {
        console.log('=== Generating Procedural Biome Map ===');
        const startTime = performance.now();
        
        // Get seeded random
        const random = MapSeedManager.createMapRandom();
        
        // Create empty grid
        const width = MAP_CONFIG.GRID_WIDTH;
        const height = MAP_CONFIG.GRID_HEIGHT;
        const grid = TileGridGenerator.createEmptyGrid(width, height);
        
        console.log(`Created ${width}x${height} grid (${width * height} tiles)`);
        
        // Place biome centers
        const centers = BiomeDistributor.placeBiomeCenters(random, width, height);
        console.log(`Placed ${centers.length} biome centers`);
        
        // Assign biomes to all tiles
        BiomeDistributor.assignBiomesToTiles(grid, centers, width, height);
        console.log('Assigned biomes via Voronoi');
        
        // Smooth boundaries
        BiomeDistributor.smoothBiomeBoundaries(grid, width, height, 1);
        console.log('Smoothed biome boundaries');
        
        // Count biomes for verification
        const biomeCounts = this.countBiomes(grid);
        console.log('Biome distribution:', biomeCounts);
        
        const duration = performance.now() - startTime;
        console.log(`Map generation complete in ${duration.toFixed(1)}ms`);
        console.log('=======================================');
        
        return {
          grid: grid,
          width: width,
          height: height,
          centers: centers,
          biomeCounts: biomeCounts
        };
      },
      
      // Count tiles per biome
      countBiomes(grid) {
        const counts = {};
        
        for (let y = 0; y < grid.length; y++) {
          for (let x = 0; x < grid[y].length; x++) {
            const biome = grid[y][x].biome;
            counts[biome] = (counts[biome] || 0) + 1;
          }
        }
        
        return counts;
      },
      
      // Get or generate map (with caching)
      getOrGenerateMap() {
        // Check if map already generated
        if (GameState.map.grid !== null) {
          console.log('Using cached procedural map');
          return {
            grid: GameState.map.grid,
            width: GameState.map.width,
            height: GameState.map.height
          };
        }
        
        // Generate new map
        const mapData = this.generateBiomeMap();
        
        // Store in GameState
        GameState.map.grid = mapData.grid;
        GameState.map.width = mapData.width;
        GameState.map.height = mapData.height;
        
        // Save to localStorage
        Storage.save();
        
        return mapData;
      },
      
      // Force regenerate map
      regenerateMap() {
        console.log('Force regenerating map...');
        GameState.map.grid = null;
        return this.getOrGenerateMap();
      }
    };

    // Initialize map on first access
    function initProceduralMap() {
      console.log('=== PHASE 7.4B: Procedural Map Initialization ===');
      
      // Generate or load map
      const mapData = ProceduralMapGenerator.getOrGenerateMap();
      
      // Initialize tile occupancy grid from biome data
      TileOccupancy.initFromBiomeGrid(mapData.grid);
      
      console.log('Procedural map ready');
      console.log(`Grid size: ${mapData.width}x${mapData.height}`);
      console.log('================================================');
    }

    // Debug utilities
    window.showBiomeDistribution = function() {
      if (!GameState.map.grid) {
        console.log('No map generated yet');
        return;
      }
      
      const counts = ProceduralMapGenerator.countBiomes(GameState.map.grid);
      const total = GameState.map.width * GameState.map.height;
      
      console.log('=== Biome Distribution ===');
      for (const [biome, count] of Object.entries(counts)) {
        const percentage = (count / total * 100).toFixed(1);
        const biomeData = Object.values(BIOMES).find(b => b.id === biome);
        console.log(`${biomeData.icon} ${biomeData.name}: ${count} tiles (${percentage}%)`);
      }
      console.log('=========================');
    };
    
    window.showTileOccupancy = function() {
      TileOccupancy.debugStats();
    };

    window.regenerateProceduralMap = function() {
      ProceduralMapGenerator.regenerateMap();
      console.log('Map regenerated. Reload to see changes.');
    };

    window.showProceduralMapInfo = function() {
      console.log('=== Procedural Map Info ===');
      console.log('Size:', `${GameState.map.width}x${GameState.map.height}`);
      console.log('Total tiles:', GameState.map.width * GameState.map.height);
      console.log('Seed:', GameState.map.seed);
      console.log('Generated:', new Date(GameState.map.generatedAt).toLocaleString());
      showBiomeDistribution();
      console.log('==========================');
    };

    // ========================================
    // PHASE 7.4C: LANDMARK & ICON PLACEMENT
    // ========================================

    // Landmark definitions with placement rules
    const LANDMARK_TYPES = {
      SAFE_HOUSE: {
        id: 'safeHouse',
        name: 'Safe House',
        icon: '',
        count: 1,
        priority: 1, // Place first
        allowedBiomes: ['suburban', 'rural'],
        forbiddenBiomes: ['coastal', 'urban'],
        minDistanceFromOthers: 5,
        description: 'Player home base'
      },
      
      DEALER: {
        id: 'dealer',
        name: 'Drug Dealer',
        icon: '',
        count: 3,
        priority: 2,
        allowedBiomes: ['urban', 'industrial', 'suburban'],
        forbiddenBiomes: ['rural', 'coastal'],
        minDistanceFromOthers: 4,
        avoidLandmarks: ['police'],
        avoidRadius: 6,
        description: 'Drug deals'
      },
      
      GANG_HQ: {
        id: 'gang',
        name: 'Gang HQ',
        icon: '',
        count: 2,
        priority: 3,
        allowedBiomes: ['urban', 'industrial'],
        forbiddenBiomes: ['rural', 'coastal', 'suburban'],
        minDistanceFromOthers: 6,
        avoidLandmarks: ['police'],
        avoidRadius: 5,
        description: 'Rival gang territory'
      },
      
      POLICE: {
        id: 'police',
        name: 'Police Station',
        icon: '',
        count: 2,
        priority: 4,
        allowedBiomes: ['urban', 'suburban'],
        forbiddenBiomes: ['rural', 'coastal', 'industrial'],
        minDistanceFromOthers: 8,
        description: 'Law enforcement'
      },
      
      HOSPITAL: {
        id: 'hospital',
        name: 'Hospital',
        icon: '',
        count: 2,
        priority: 5,
        allowedBiomes: ['urban', 'suburban'],
        forbiddenBiomes: ['rural', 'coastal', 'industrial'],
        minDistanceFromOthers: 7,
        description: 'Medical center'
      }
    };

    // Landmark Placement System
    const LandmarkPlacer = {
      // Check if biome is allowed for landmark
      isBiomeAllowed(landmark, tile) {
        const tileBiome = tile.biome;
        
        // Check forbidden first
        if (landmark.forbiddenBiomes && landmark.forbiddenBiomes.includes(tileBiome)) {
          return false;
        }
        
        // Check allowed
        if (landmark.allowedBiomes && landmark.allowedBiomes.length > 0) {
          return landmark.allowedBiomes.includes(tileBiome);
        }
        
        return true;
      },
      
      // Check minimum distance from other landmarks
      isMinDistanceValid(x, y, placedLandmarks, minDistance) {
        for (const placed of placedLandmarks) {
          const distance = TileGridGenerator.getDistance(x, y, placed.x, placed.y);
          if (distance < minDistance) {
            return false;
          }
        }
        return true;
      },
      
      // Check avoidance rules
      isAvoidanceValid(landmark, x, y, placedLandmarks) {
        if (!landmark.avoidLandmarks || landmark.avoidLandmarks.length === 0) {
          return true;
        }
        
        const avoidRadius = landmark.avoidRadius || 5;
        
        for (const placed of placedLandmarks) {
          if (landmark.avoidLandmarks.includes(placed.type.id)) {
            const distance = TileGridGenerator.getDistance(x, y, placed.x, placed.y);
            if (distance < avoidRadius) {
              return false;
            }
          }
        }
        
        return true;
      },
      
      // Check if not on edge
      isNotOnEdge(x, y, width, height, buffer = 1) {
        return x >= buffer && 
               x < width - buffer && 
               y >= buffer && 
               y < height - buffer;
      },
      
      // Check if position not occupied
      isNotOccupied(x, y, placedLandmarks) {
        return !placedLandmarks.some(placed => placed.x === x && placed.y === y);
      },
      
      // Validate placement position using TileOccupancy
      isValidPlacement(landmark, x, y, tile, placedLandmarks, width, height) {
        // PRIMARY CHECK: Use TileOccupancy - tile must be grass and unoccupied
        if (!TileOccupancy.isAvailable(x, y)) {
          return false;
        }
        
        // Check biome rules for this landmark type
        if (!this.isBiomeAllowed(landmark, tile)) return false;
        if (!this.isNotOnEdge(x, y, width, height)) return false;
        if (!this.isNotOccupied(x, y, placedLandmarks)) return false;
        if (!this.isMinDistanceValid(x, y, placedLandmarks, landmark.minDistanceFromOthers)) return false;
        if (!this.isAvoidanceValid(landmark, x, y, placedLandmarks)) return false;
        
        return true;
      },
      
      // Generate candidate positions
      generateCandidates(random, grid, landmark, count) {
        const candidates = [];
        const width = grid[0].length;
        const height = grid.length;
        
        // Generate many candidates (adaptive based on biome rarity)
        const maxAttempts = count * 100;
        
        for (let i = 0; i < maxAttempts; i++) {
          const x = Math.floor(random() * width);
          const y = Math.floor(random() * height);
          
          // PRIMARY CHECK: TileOccupancy must show tile as grass and unoccupied
          if (!TileOccupancy.isAvailable(x, y)) {
            continue;
          }
          
          const tile = TileGridGenerator.getTile(grid, x, y);
          
          // SECONDARY CHECK: Biome rules for this landmark type
          if (this.isBiomeAllowed(landmark, tile)) {
            candidates.push({ x, y, tile });
          }
        }
        
        return candidates;
      },
      
      // Score candidate position
      scoreCandidate(candidate, landmark, placedLandmarks, width, height) {
        let score = 100;
        
        const { x, y } = candidate;
        
        // Bonus for center of map (avoid edges)
        const centerX = width / 2;
        const centerY = height / 2;
        const distanceFromCenter = TileGridGenerator.getDistance(x, y, centerX, centerY);
        const maxDistance = TileGridGenerator.getDistance(0, 0, centerX, centerY);
        const centrality = 1 - (distanceFromCenter / maxDistance);
        score += centrality * 20;
        
        // Penalty for crowding
        for (const placed of placedLandmarks) {
          const distance = TileGridGenerator.getDistance(x, y, placed.x, placed.y);
          const minDistance = landmark.minDistanceFromOthers;
          
          if (distance < minDistance * 2) {
            const proximity = 1 - (distance / (minDistance * 2));
            score -= proximity * 30;
          }
        }
        
        return score;
      },
      
      // Place all landmarks
      placeAllLandmarks(grid, random) {
        console.log('=== Placing Landmarks ===');
        const startTime = performance.now();
        
        const placedLandmarks = [];
        const width = grid[0].length;
        const height = grid.length;
        
        // Sort by priority
        const landmarkTypes = Object.values(LANDMARK_TYPES).sort((a, b) => a.priority - b.priority);
        
        for (const landmarkType of landmarkTypes) {
          console.log(`Placing ${landmarkType.name} (x${landmarkType.count})...`);
          
          for (let instance = 0; instance < landmarkType.count; instance++) {
            const landmarkId = `${landmarkType.id}_${instance}`;
            
            // Generate candidates
            const candidates = this.generateCandidates(random, grid, landmarkType, 1);
            
            if (candidates.length === 0) {
              console.warn(`No candidates for ${landmarkId}`);
              continue;
            }
            
            // Filter and score valid candidates
            const validCandidates = [];
            
            for (const candidate of candidates) {
              if (this.isValidPlacement(landmarkType, candidate.x, candidate.y, candidate.tile, placedLandmarks, width, height)) {
                const score = this.scoreCandidate(candidate, landmarkType, placedLandmarks, width, height);
                validCandidates.push({ ...candidate, score });
              }
            }
            
            if (validCandidates.length === 0) {
              console.warn(`No valid placements for ${landmarkId}`);
              continue;
            }
            
            // Sort by score and pick best
            validCandidates.sort((a, b) => b.score - a.score);
            const best = validCandidates[0];
            
            // Reserve tile in occupancy grid BEFORE creating landmark
            const reserved = TileOccupancy.reserveLandmark(best.x, best.y, landmarkId);
            
            if (!reserved) {
              console.warn(`Failed to reserve tile for landmark ${landmarkId}`);
              continue;
            }
            
            // Create landmark
            const landmark = {
              type: landmarkType,
              x: best.x,
              y: best.y,
              biome: best.tile.biome,
              id: landmarkId,
              icon: landmarkType.icon,
              label: landmarkType.name
            };
            
            placedLandmarks.push(landmark);
            console.log(`   Placed ${landmarkId} at (${best.x}, ${best.y}) in ${best.tile.biome}`);
          }
        }
        
        const duration = performance.now() - startTime;
        console.log(`Landmarks placed in ${duration.toFixed(1)}ms`);
        console.log('========================');
        
        return placedLandmarks;
      }
    };

    // Convert procedural landmarks to existing mapIcons format
    const LandmarkConverter = {
      // Convert procedural landmarks to legacy mapIcons format
      convertToMapIcons(proceduralLandmarks, gridWidth, gridHeight) {
        const mapIcons = [];
        
        for (const landmark of proceduralLandmarks) {
          // Convert grid coordinates to percentage (0-100)
          const xPercent = (landmark.x / gridWidth) * 100;
          const yPercent = (landmark.y / gridHeight) * 100;
          
          mapIcons.push({
            type: landmark.type.id,
            icon: landmark.icon,
            x: xPercent,
            y: yPercent,
            state: landmark.type.id === 'safeHouse' ? 'active' : 'dormant',
            label: landmark.label
          });
        }
        
        return mapIcons;
      },
      
      // Set character starting position at safe house
      setCharacterAtSafeHouse(proceduralLandmarks, gridWidth, gridHeight) {
        const safeHouse = proceduralLandmarks.find(l => l.type.id === 'safeHouse');
        
        if (safeHouse) {
          const xPercent = (safeHouse.x / gridWidth) * 100;
          const yPercent = (safeHouse.y / gridHeight) * 100;
          
          GameState.character.position = { x: xPercent, y: yPercent };
          GameState.safeHouse.position = { x: xPercent, y: yPercent };
          
          console.log(`Character positioned at Safe House: (${xPercent.toFixed(1)}%, ${yPercent.toFixed(1)}%)`);
        }
      }
    };

    // Main landmark initialization
    function initProceduralLandmarks() {
      console.log('=== PHASE 7.4C: Procedural Landmark Placement ===');
      
      // Check if map exists
      if (!GameState.map.grid) {
        console.error('Cannot place landmarks - map not generated');
        return;
      }
      
      // Check if landmarks already placed
      if (GameState.mapIcons && GameState.mapIcons.length > 0 && GameState.mapIcons[0].type !== 'safeHouse') {
        console.log('Landmarks already placed (using cached)');
        return;
      }
      
      // Get seeded random
      const random = MapSeedManager.createMapRandom();
      
      // Place landmarks
      const proceduralLandmarks = LandmarkPlacer.placeAllLandmarks(GameState.map.grid, random);
      
      // Convert to legacy mapIcons format
      const mapIcons = LandmarkConverter.convertToMapIcons(
        proceduralLandmarks, 
        GameState.map.width, 
        GameState.map.height
      );
      
      // Update GameState
      GameState.mapIcons = mapIcons;
      
      // Set character at safe house
      LandmarkConverter.setCharacterAtSafeHouse(
        proceduralLandmarks,
        GameState.map.width,
        GameState.map.height
      );
      
      // Save to localStorage
      Storage.save();
      
      console.log(`Placed ${mapIcons.length} landmarks`);
      console.log('================================================');
    }

    // Debug utilities
    window.showLandmarkPlacements = function() {
      console.log('=== Landmark Placements ===');
      
      if (!GameState.mapIcons || GameState.mapIcons.length === 0) {
        console.log('No landmarks placed');
        return;
      }
      
      for (const icon of GameState.mapIcons) {
        console.log(`${icon.icon} ${icon.label}: (${icon.x.toFixed(1)}%, ${icon.y.toFixed(1)}%) - ${icon.state}`);
      }
      
      console.log('==========================');
    };

    window.validateLandmarkRules = function() {
      console.log('=== Validating Landmark Rules ===');
      
      if (!GameState.mapIcons || !GameState.map.grid) {
        console.log('No landmarks or map to validate');
        return;
      }
      
      let violations = 0;
      const width = GameState.map.width;
      const height = GameState.map.height;
      
      // Check each landmark
      for (const icon of GameState.mapIcons) {
        // Convert percentage back to grid coords
        const gridX = Math.floor((icon.x / 100) * width);
        const gridY = Math.floor((icon.y / 100) * height);
        const tile = TileGridGenerator.getTile(GameState.map.grid, gridX, gridY);
        
        if (!tile) {
          console.warn(`${icon.label} out of bounds`);
          violations++;
          continue;
        }
        
        // Find landmark type
        const landmarkType = Object.values(LANDMARK_TYPES).find(lt => lt.id === icon.type);
        
        if (!landmarkType) continue;
        
        // Check biome rules
        if (landmarkType.forbiddenBiomes && landmarkType.forbiddenBiomes.includes(tile.biome)) {
          console.warn(`${icon.label} in forbidden biome: ${tile.biome}`);
          violations++;
        }
      }
      
      if (violations === 0) {
        console.log(' All landmarks follow placement rules');
      } else {
        console.warn(` Found ${violations} rule violations`);
      }
      
      console.log('================================');
    };

    // ========================================
    // PHASE 7.4D: RENDERING & PERFORMANCE OPTIMIZATION
    // ========================================

    // Render configuration
    const RENDER_CONFIG = {
      ENABLE_TILE_RENDERING: true,  // Toggle tile rendering on/off
      TILE_SIZE_PX: 30,              // Pixels per tile (30px = good for mobile)
      USE_CANVAS: false,             // Use divs (better for debugging, easier styling)
      SHOW_BIOME_LABELS: false,      // Show biome names on tiles
      CACHE_RENDERED_MAP: true       // Only render once
    };

    // Map Renderer
    const ProceduralMapRenderer = {
      rendered: false,
      
      // Main render function
      renderMap() {
        console.log(' ProceduralMapRenderer.renderMap() called');
        console.log(' RENDER_CONFIG.ENABLE_TILE_RENDERING:', RENDER_CONFIG.ENABLE_TILE_RENDERING);
        console.log(' this.rendered:', this.rendered);
        console.log(' GameState.map.grid exists:', GameState.map.grid !== null);
        
        if (!RENDER_CONFIG.ENABLE_TILE_RENDERING) {
          console.log('Tile rendering disabled');
          return;
        }
        
        // Check if already rendered - BUT allow re-render if grid exists and not rendered
        if (this.rendered && RENDER_CONFIG.CACHE_RENDERED_MAP) {
          // Double-check that the SVG actually exists
          const mapContainer = document.getElementById('city-map');
          if (mapContainer && mapContainer.querySelector('#unified-biome-layer')) {
            console.log('Map already rendered (using cache)');
            return;
          } else {
            console.log(' Cache says rendered but SVG missing - re-rendering');
            this.rendered = false;
          }
        }
        
        console.log('=== Rendering Procedural Map ===');
        const startTime = performance.now();
        
        // Check if map exists
        if (!GameState.map.grid) {
          console.error(' No map grid to render - GameState.map.grid is null');
          return;
        }
        
        console.log(' Grid dimensions:', GameState.map.width, 'x', GameState.map.height);
        
        // Get map container
        const mapContainer = document.getElementById('city-map');
        if (!mapContainer) {
          console.error(' Map container #city-map not found');
          return;
        }
        
        console.log(' Map container found:', mapContainer);
        
        // CRITICAL: Clear container completely to prevent stacking
        this.clearTileLayer(mapContainer);
        
        // Create tile layer
        const tileLayer = this.createTileLayer();
        
        // Render tiles
        this.renderTiles(tileLayer);
        
        // Add to map (behind existing elements)
        mapContainer.insertBefore(tileLayer, mapContainer.firstChild);
        
        // Mark as rendered
        this.rendered = true;
        
        const duration = performance.now() - startTime;
        console.log(` Map rendered in ${duration.toFixed(1)}ms`);
        console.log('===============================');
      },
      
      // Clear existing tile layer
      clearTileLayer(mapContainer) {
        const existing = document.getElementById('tile-layer');
        if (existing) {
          existing.remove();
        }
      },
      
      // Create tile layer container
      createTileLayer() {
        const layer = document.createElement('div');
        layer.id = 'tile-layer';
        layer.style.position = 'absolute';
        layer.style.top = '0';
        layer.style.left = '0';
        layer.style.width = '100%';
        layer.style.height = '100%';
        layer.style.pointerEvents = 'none';
        layer.style.zIndex = '0';
        
        return layer;
      },
      
      // Render all tiles using unified SVG biome rendering
      renderTiles(container) {
        console.log(' renderTiles() called');
        
        const grid = GameState.map.grid;
        const width = GameState.map.width;
        const height = GameState.map.height;
        const tileSize = RENDER_CONFIG.TILE_SIZE_PX;
        
        console.log(' Map dimensions:', width, 'x', height, '- Tile size:', tileSize);
        
        // Calculate container size
        const containerWidth = width * tileSize;
        const containerHeight = height * tileSize;
        
        // Set container size
        container.style.width = containerWidth + 'px';
        container.style.height = containerHeight + 'px';
        
        console.log(' Container size set to:', containerWidth, 'x', containerHeight);
        
        // CRITICAL: Remove ANY old rendering layers
        const oldUnified = container.querySelector('#unified-biome-layer');
        if (oldUnified) {
          console.log(' Removing old unified layer');
          oldUnified.remove();
        }
        
        // OPTION A: Unified SVG Biome Rendering with seamless water
        console.log(' Calling renderUnifiedBiomes...');
        this.renderUnifiedBiomes(container, grid, width, height, tileSize);
        
        // PHASE 7.5: Render roads and buildings on top
        console.log(' Rendering roads...');
        RoadBuildingRenderer.renderRoads(container);
        
        console.log(' Rendering buildings...');
        RoadBuildingRenderer.renderBuildings(container);
        
        console.log(` Rendered unified biome layer (${width}x${height})`);
      },
      
      // NEW: Unified SVG biome rendering - Seamless water, soft grass grid
      renderUnifiedBiomes(container, grid, width, height, tileSize) {
        console.log(' RENDERING UNIFIED BIOMES - Seamless water active');
        
        // CRITICAL: Remove any existing unified layer first
        const existingUnified = container.querySelector('#unified-biome-layer');
        if (existingUnified) {
          console.log(' Removing existing unified biome layer');
          existingUnified.remove();
        }
        
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("width", width * tileSize);
        svg.setAttribute("height", height * tileSize);
        svg.style.position = 'absolute';
        svg.style.top = '0';
        svg.style.left = '0';
        svg.style.pointerEvents = 'none';
        svg.style.zIndex = '0';
        svg.id = 'unified-biome-layer';
        
        // CRITICAL: Remove ALL borders
        svg.style.border = 'none';
        svg.style.outline = 'none';
        
        // Group tiles by biome type for unified rendering
        const biomeGroups = {};
        
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const tile = grid[y][x];
            const biomeId = tile.biome;
            
            if (!biomeGroups[biomeId]) {
              biomeGroups[biomeId] = [];
            }
            
            biomeGroups[biomeId].push({ x, y });
          }
        }
        
        console.log(' Biome groups:', Object.keys(biomeGroups).map(id => `${id}: ${biomeGroups[id].length} tiles`));
        
        // Create shared water gradient (once)
        const waterGradient = document.createElementNS(svgNS, "linearGradient");
        waterGradient.setAttribute("id", "shared-water-gradient");
        waterGradient.setAttribute("x1", "0%");
        waterGradient.setAttribute("y1", "0%");
        waterGradient.setAttribute("x2", "100%");
        waterGradient.setAttribute("y2", "100%");
        
        const waterStop1 = document.createElementNS(svgNS, "stop");
        waterStop1.setAttribute("offset", "0%");
        waterStop1.setAttribute("stop-color", "#1dd1c1");
        
        const waterStop2 = document.createElementNS(svgNS, "stop");
        waterStop2.setAttribute("offset", "50%");
        waterStop2.setAttribute("stop-color", "#2dd1c1");
        
        const waterStop3 = document.createElementNS(svgNS, "stop");
        waterStop3.setAttribute("offset", "100%");
        waterStop3.setAttribute("stop-color", "#1ad1c1");
        
        waterGradient.appendChild(waterStop1);
        waterGradient.appendChild(waterStop2);
        waterGradient.appendChild(waterStop3);
        svg.appendChild(waterGradient);
        
        // Render each biome group
        Object.entries(biomeGroups).forEach(([biomeId, tiles]) => {
          const biome = Object.values(BIOMES).find(b => b.id === biomeId);
          if (!biome) return;
          
          // WATER TILES: Seamless rendering with shared gradient
          if (biomeId === 'coastal') {
            tiles.forEach(({x, y}) => {
              const rectEl = document.createElementNS(svgNS, "rect");
              rectEl.setAttribute("x", x * tileSize);
              rectEl.setAttribute("y", y * tileSize);
              rectEl.setAttribute("width", tileSize);
              rectEl.setAttribute("height", tileSize);
              rectEl.setAttribute("fill", "url(#shared-water-gradient)");
              rectEl.setAttribute("opacity", "0.85");
              rectEl.setAttribute("stroke", "none");
              rectEl.setAttribute("stroke-width", "0");
              svg.appendChild(rectEl);
            });
          } 
          // LAND/GRASS TILES: Soft grid with minimal variance
          else {
            tiles.forEach(({x, y}) => {
              const rectEl = document.createElementNS(svgNS, "rect");
              rectEl.setAttribute("x", x * tileSize);
              rectEl.setAttribute("y", y * tileSize);
              rectEl.setAttribute("width", tileSize);
              rectEl.setAttribute("height", tileSize);
              
              // Parse base color
              const baseColor = biome.color;
              
              // Add subtle variance (2% luminance)
              const variance = (Math.random() - 0.5) * 0.04; // -2% to +2%
              const r = parseInt(baseColor.slice(1, 3), 16);
              const g = parseInt(baseColor.slice(3, 5), 16);
              const b = parseInt(baseColor.slice(5, 7), 16);
              
              const adjustedR = Math.max(0, Math.min(255, Math.floor(r * (1 + variance))));
              const adjustedG = Math.max(0, Math.min(255, Math.floor(g * (1 + variance))));
              const adjustedB = Math.max(0, Math.min(255, Math.floor(b * (1 + variance))));
              
              const adjustedColor = `#${adjustedR.toString(16).padStart(2, '0')}${adjustedG.toString(16).padStart(2, '0')}${adjustedB.toString(16).padStart(2, '0')}`;
              
              rectEl.setAttribute("fill", adjustedColor);
              rectEl.setAttribute("opacity", "0.6");
              
              // SOFT grid: extremely subtle stroke
              rectEl.setAttribute("stroke", "rgba(0, 0, 0, 0.03)");
              rectEl.setAttribute("stroke-width", "0.5");
              
              svg.appendChild(rectEl);
            });
          }
        });
        
        // HARD RESET: Clear container completely before adding new SVG
        const tileLayer = container.querySelector('#tile-layer');
        if (tileLayer) {
          tileLayer.innerHTML = '';
          tileLayer.appendChild(svg);
        } else {
          container.appendChild(svg);
        }
        
        console.log(' Seamless water + soft grass grid rendered');
      },
      

      
      // Force re-render
      forceRender() {
        this.rendered = false;
        this.renderMap();
      }
    };

    // Map Performance Manager
    const MapPerformanceManager = {
      // Performance metrics
      metrics: {
        seedGeneration: 0,
        biomeGeneration: 0,
        landmarkPlacement: 0,
        rendering: 0,
        totalInitTime: 0
      },
      
      // Measure and log performance
      measurePerformance() {
        console.log('=== Map Generation Performance ===');
        console.log('Seed Generation:', this.metrics.seedGeneration.toFixed(1) + 'ms');
        console.log('Biome Generation:', this.metrics.biomeGeneration.toFixed(1) + 'ms');
        console.log('Landmark Placement:', this.metrics.landmarkPlacement.toFixed(1) + 'ms');
        console.log('Rendering:', this.metrics.rendering.toFixed(1) + 'ms');
        console.log('Total Init Time:', this.metrics.totalInitTime.toFixed(1) + 'ms');
        console.log('=================================');
        
        // Performance check
        if (this.metrics.totalInitTime < 150) {
          console.log(' Excellent performance (<150ms)');
        } else if (this.metrics.totalInitTime < 250) {
          console.log(' Good performance (<250ms)');
        } else {
          console.warn(' Performance could be improved (>250ms)');
        }
      },
      
      // Get memory usage (if available)
      getMemoryUsage() {
        if (performance.memory) {
          const used = performance.memory.usedJSHeapSize;
          const total = performance.memory.totalJSHeapSize;
          const limit = performance.memory.jsHeapSizeLimit;
          
          console.log('=== Memory Usage ===');
          console.log('Used:', (used / 1024 / 1024).toFixed(1) + ' MB');
          console.log('Total:', (total / 1024 / 1024).toFixed(1) + ' MB');
          console.log('Limit:', (limit / 1024 / 1024).toFixed(1) + ' MB');
          console.log('===================');
        } else {
          console.log('Memory API not available');
        }
      },
      
      // Optimize map for low-end devices
      optimizeForLowEnd() {
        console.log('Applying low-end device optimizations...');
        
        // Reduce tile rendering quality
        RENDER_CONFIG.SHOW_BIOME_LABELS = false;
        
        // Disable non-essential features during generation
        // (Already optimized in Phase 7.4B and 7.4C)
        
        console.log('Optimizations applied');
      }
    };

    // Cache Manager
    const MapCacheManager = {
      // Check if map is cached
      isCached() {
        return GameState.map.grid !== null && 
               GameState.map.seed !== null && 
               GameState.mapIcons.length > 0;
      },
      
      // Clear cache (force regeneration)
      clearCache() {
        console.log('Clearing map cache...');
        GameState.map.grid = null;
        GameState.map.seed = null;
        GameState.map.generatedAt = null;
        GameState.mapIcons = [];
        ProceduralMapRenderer.rendered = false;
        Storage.save();
        console.log('Cache cleared');
      },
      
      // Get cache info
      getCacheInfo() {
        return {
          isCached: this.isCached(),
          seedExists: GameState.map.seed !== null,
          gridExists: GameState.map.grid !== null,
          landmarksExist: GameState.mapIcons.length > 0,
          rendered: ProceduralMapRenderer.rendered,
          generatedAt: GameState.map.generatedAt ? new Date(GameState.map.generatedAt).toLocaleString() : null
        };
      }
    };

    // Initialize rendering
    function initProceduralMapRendering() {
      console.log('=== PHASE 7.4D: Map Rendering ===');
      
      // Render the map
      ProceduralMapRenderer.renderMap();
      
      console.log('================================');
    }

    // Debug utilities
    window.renderProceduralMap = function() {
      ProceduralMapRenderer.forceRender();
    };

    window.toggleTileRendering = function(enabled) {
      RENDER_CONFIG.ENABLE_TILE_RENDERING = enabled;
      console.log('Tile rendering:', enabled ? 'ENABLED' : 'DISABLED');
      if (enabled) {
        ProceduralMapRenderer.forceRender();
      } else {
        const layer = document.getElementById('tile-layer');
        if (layer) layer.remove();
      }
    };

    window.showMapPerformance = function() {
      MapPerformanceManager.measurePerformance();
      MapPerformanceManager.getMemoryUsage();
    };

    window.showMapCacheInfo = function() {
      const info = MapCacheManager.getCacheInfo();
      console.log('=== Map Cache Info ===');
      console.log('Is Cached:', info.isCached ? 'YES' : 'NO');
      console.log('Seed Exists:', info.seedExists);
      console.log('Grid Exists:', info.gridExists);
      console.log('Landmarks Placed:', info.landmarksExist);
      console.log('Rendered:', info.rendered);
      console.log('Generated At:', info.generatedAt);
      console.log('=====================');
    };

    window.clearMapCache = function() {
      MapCacheManager.clearCache();
      console.log('Map cache cleared. Reload page to regenerate.');
    };

    window.optimizeForLowEnd = function() {
      MapPerformanceManager.optimizeForLowEnd();
    };

    // ========================================
    // INTERACTIVE BUILDINGS SYSTEM (Map-Embedded)
    // ========================================
    
    // Building type definitions
    const BUILDING_TYPES = {
      gun_shop: {
        id: 'gun_shop',
        name: 'Gun Shop',
        icon: '',
        footprint: { width: 1, height: 1 },
        allowedBiomes: ['urban', 'suburban'],
        forbiddenBiomes: ['coastal', 'rural'],
        avoidRoads: false,
        minSpacing: 5, // tiles between same type
        count: 2, // how many to place
        interactions: [
          { id: 'browse', label: ' Browse Weapons', action: 'shop' },
          { id: 'sell', label: ' Sell Items', action: 'coming_soon' }
        ]
      },
      
      chop_shop: {
        id: 'chop_shop',
        name: 'Chop Shop',
        icon: '',
        footprint: { width: 2, height: 1 },
        allowedBiomes: ['industrial', 'urban'],
        forbiddenBiomes: ['coastal', 'rural', 'suburban'],
        avoidRoads: false,
        minSpacing: 8,
        count: 1,
        interactions: [
          { id: 'sell_vehicle', label: ' Sell Vehicle', action: 'chop_shop' },
          { id: 'check_prices', label: ' Check Prices', action: 'chop_prices' }
        ]
      },
      
      casino: {
        id: 'casino',
        name: 'Casino',
        icon: '',
        footprint: { width: 2, height: 2 },
        allowedBiomes: ['urban'],
        forbiddenBiomes: ['coastal', 'rural', 'suburban', 'industrial'],
        avoidRoads: false,
        minSpacing: 10,
        count: 1,
        interactions: [
          { id: 'blackjack', label: ' Play Blackjack', action: 'blackjack' },
          { id: 'slots', label: ' Slot Machines', action: 'slots' }
        ]
      },
      
      nightclub: {
        id: 'nightclub',
        name: 'Nightclub',
        icon: '',
        footprint: { width: 1, height: 1 },
        allowedBiomes: ['urban', 'suburban'],
        forbiddenBiomes: ['coastal', 'rural', 'industrial'],
        avoidRoads: false,
        minSpacing: 6,
        count: 2,
        interactions: [
          { id: 'meet_contacts', label: ' Meet Contacts', action: 'contacts' },
          { id: 'gather_intel', label: ' Gather Intel', action: 'intel' }
        ]
      },
      
      safehouse: {
        id: 'safehouse',
        name: 'Safehouse',
        icon: '',
        footprint: { width: 1, height: 1 },
        allowedBiomes: ['suburban', 'rural'],
        forbiddenBiomes: ['coastal', 'urban', 'industrial'],
        avoidRoads: true,
        minSpacing: 12,
        count: 1,
        interactions: [
          { id: 'rest', label: ' Rest (Recover)', action: 'rest' },
          { id: 'stash', label: ' Access Stash', action: 'stash' }
        ]
      }
    };
    
    // Building Placement System
    const BuildingPlacer = {
      // Place all buildings using procedural generation
      placeBuildings(grid, random) {
        console.log('=== Placing Interactive Buildings ===');
        const startTime = performance.now();
        
        const placedBuildings = [];
        const width = grid[0].length;
        const height = grid.length;
        
        // Sort by priority (larger footprints first)
        const buildingTypes = Object.values(BUILDING_TYPES).sort((a, b) => {
          const areaA = a.footprint.width * a.footprint.height;
          const areaB = b.footprint.width * b.footprint.height;
          return areaB - areaA;
        });
        
        for (const buildingType of buildingTypes) {
          console.log(`Placing ${buildingType.name} (x${buildingType.count})...`);
          
          for (let instance = 0; instance < buildingType.count; instance++) {
            const buildingId = `${buildingType.id}_${instance}`;
            
            // Generate candidates using seeded random
            const candidates = this.generateCandidates(grid, buildingType, placedBuildings, 100, random, width, height);
            
            if (candidates.length === 0) {
              console.warn(`No candidates for ${buildingId}`);
              continue;
            }
            
            // Pick best candidate
            const best = candidates[0];
            
            // Reserve tiles in occupancy grid BEFORE creating building
            const reserved = TileOccupancy.reserve(
              best.x, 
              best.y, 
              buildingType.footprint.width, 
              buildingType.footprint.height, 
              buildingId
            );
            
            if (!reserved) {
              console.warn(`Failed to reserve tiles for ${buildingId}`);
              continue;
            }
            
            // Convert tile coordinates to percentage for map positioning
            const xPercent = (best.x / width) * 100;
            const yPercent = (best.y / height) * 100;
            
            // Create building
            const building = {
              id: buildingId,
              typeId: buildingType.id,
              x: best.x,           // Tile coordinates
              y: best.y,
              xPercent: xPercent,  // Percentage for rendering
              yPercent: yPercent,
              footprint: buildingType.footprint,
              biome: best.tile.biome,
              icon: buildingType.icon,
              name: buildingType.name,
              interactions: buildingType.interactions
            };
            
            placedBuildings.push(building);
            console.log(`   Placed ${buildingId} at tile (${best.x}, ${best.y}) = ${xPercent.toFixed(1)}%, ${yPercent.toFixed(1)}% in ${best.tile.biome}`);
          }
        }
        
        const duration = performance.now() - startTime;
        console.log(`Buildings placed in ${duration.toFixed(1)}ms`);
        console.log('=====================================');
        
        return placedBuildings;
      },
      
      // Generate candidate positions using seeded random
      generateCandidates(grid, buildingType, placedBuildings, maxAttempts, random, width, height) {
        const candidates = [];
        
        for (let i = 0; i < maxAttempts; i++) {
          const x = Math.floor(random() * (width - buildingType.footprint.width));
          const y = Math.floor(random() * (height - buildingType.footprint.height));
          
          // QUICK PRE-FILTER: Check if footprint is available in TileOccupancy
          if (!TileOccupancy.isFootprintAvailable(x, y, buildingType.footprint.width, buildingType.footprint.height)) {
            continue;
          }
          
          // FULL VALIDATION: Check all placement rules
          if (this.isValidPlacement(grid, buildingType, x, y, placedBuildings, width, height)) {
            const tile = TileGridGenerator.getTile(grid, x, y);
            const score = this.scoreCandidate(x, y, buildingType, placedBuildings, width, height);
            candidates.push({ x, y, tile, score });
          }
        }
        
        // Sort by score
        candidates.sort((a, b) => b.score - a.score);
        
        return candidates;
      },
      
      // Check if placement is valid using TileOccupancy
      isValidPlacement(grid, buildingType, x, y, placedBuildings, width, height) {
        // Check bounds
        if (x < 0 || y < 0) return false;
        if (x + buildingType.footprint.width > width || y + buildingType.footprint.height > height) {
          return false;
        }
        
        // PRIMARY CHECK: Use TileOccupancy to verify ALL tiles are grass and unoccupied
        if (!TileOccupancy.isFootprintAvailable(x, y, buildingType.footprint.width, buildingType.footprint.height)) {
          return false;
        }
        
        // ROAD ADJACENCY CHECK: At least one footprint tile must be adjacent to a road
        if (!TileOccupancy.isFootprintAdjacentToRoad(x, y, buildingType.footprint.width, buildingType.footprint.height)) {
          return false;
        }
        
        // BIOME CHECK: Verify biome rules for this building type
        for (let dy = 0; dy < buildingType.footprint.height; dy++) {
          for (let dx = 0; dx < buildingType.footprint.width; dx++) {
            const tile = TileGridGenerator.getTile(grid, x + dx, y + dy);
            if (!tile) return false;
            
            // Check specific biome rules for this building type
            if (buildingType.forbiddenBiomes && buildingType.forbiddenBiomes.includes(tile.biome)) return false;
            if (buildingType.allowedBiomes && buildingType.allowedBiomes.length > 0 && !buildingType.allowedBiomes.includes(tile.biome)) return false;
          }
        }
        
        // Check minimum spacing for same type
        for (const existing of placedBuildings) {
          if (existing.typeId === buildingType.id) {
            const distance = Math.sqrt(Math.pow(x - existing.x, 2) + Math.pow(y - existing.y, 2));
            if (distance < buildingType.minSpacing) {
              return false;
            }
          }
          
          // Minimum spacing between ANY buildings (prevent clustering)
          const minAnySpacing = 2;
          const distance = Math.sqrt(Math.pow(x - existing.x, 2) + Math.pow(y - existing.y, 2));
          if (distance < minAnySpacing) {
            return false;
          }
        }
        
        return true;
      },
      
      // Check if two footprints overlap
      checkOverlap(x1, y1, footprint1, x2, y2, footprint2) {
        return !(x1 + footprint1.width <= x2 ||
                 x2 + footprint2.width <= x1 ||
                 y1 + footprint1.height <= y2 ||
                 y2 + footprint2.height <= y1);
      },
      
      // Score candidate position
      scoreCandidate(x, y, buildingType, placedBuildings, width, height) {
        let score = 100;
        
        // Prefer center of map
        const centerX = width / 2;
        const centerY = height / 2;
        const distanceFromCenter = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
        const maxDistance = Math.sqrt(Math.pow(centerX, 2) + Math.pow(centerY, 2));
        const centrality = 1 - (distanceFromCenter / maxDistance);
        score += centrality * 20;
        
        // Penalty for crowding
        for (const existing of placedBuildings) {
          const distance = Math.sqrt(Math.pow(x - existing.x, 2) + Math.pow(y - existing.y, 2));
          if (distance < 5) {
            score -= (5 - distance) * 10;
          }
        }
        
        return score;
      }
    };
    
    // Building Interaction System
    const InteractiveBuildings = {
      
      // 2.5D Building Visual Configuration
      // Buildings sized to fit within 30px tile grid
      BUILDING_VISUALS: {
        // Tile size reference (must match RENDER_CONFIG.TILE_SIZE_PX)
        TILE_SIZE: 30,
        
        // Height tiers (in pixels) - proportional to tile size
        HEIGHT_TIERS: {
          small: 18,    // Fits in ~1 tile height
          medium: 26,   // Fits in ~1.5 tiles
          large: 36     // Fits in ~2 tiles (casino)
        },
        
        // Building type to height tier mapping
        TYPE_HEIGHT: {
          gun_shop: 'small',
          chop_shop: 'medium',
          casino: 'large',
          nightclub: 'medium',
          safehouse: 'small'
        },
        
        // Building colors (roof, front wall, side wall)
        TYPE_COLORS: {
          gun_shop: {
            roof: '#4a4a4a',
            front: '#3a3a3a',
            side: '#2a2a2a',
            accent: '#f28b82',  // Red accent
            windowColor: '#fdd663'
          },
          chop_shop: {
            roof: '#5a5a6a',
            front: '#4a4a5a',
            side: '#3a3a4a',
            accent: '#8ab4f8',  // Blue accent
            windowColor: '#81c995'
          },
          casino: {
            roof: '#6a5a7a',
            front: '#5a4a6a',
            side: '#4a3a5a',
            accent: '#fdd663',  // Gold accent
            windowColor: '#f28b82'
          },
          nightclub: {
            roof: '#5a4a6a',
            front: '#4a3a5a',
            side: '#3a2a4a',
            accent: '#ba82f5',  // Purple accent
            windowColor: '#8ab4f8'
          },
          safehouse: {
            roof: '#5a6a5a',
            front: '#4a5a4a',
            side: '#3a4a3a',
            accent: '#81c995',  // Green accent
            windowColor: '#fdd663'
          }
        },
        
        // Shadow settings (smaller for mobile)
        SHADOW_OFFSET_X: 2,
        SHADOW_OFFSET_Y: 3,
        SHADOW_BLUR: 4,
        SHADOW_COLOR: 'rgba(0, 0, 0, 0.35)'
      },
      
      // Create 2.5D building SVG element - sized to fit tile grid
      createBuildingSVG(building) {
        const config = this.BUILDING_VISUALS;
        const tileSize = config.TILE_SIZE;
        const typeId = building.typeId;
        const heightTier = config.TYPE_HEIGHT[typeId] || 'small';
        const height = config.HEIGHT_TIERS[heightTier];
        const colors = config.TYPE_COLORS[typeId] || config.TYPE_COLORS.gun_shop;
        
        // Building dimensions based on footprint (in tiles)
        const footprint = building.footprint || { width: 1, height: 1 };
        
        // Base dimensions fit within tile(s) with small margin
        const margin = 2;
        const baseWidth = (tileSize * footprint.width) - (margin * 2);
        const baseDepth = 8; // Isometric depth (fixed, small)
        
        // SVG dimensions
        const isoOffsetX = 4; // Small isometric offset
        const svgWidth = baseWidth + isoOffsetX + config.SHADOW_OFFSET_X + config.SHADOW_BLUR;
        const svgHeight = height + baseDepth + config.SHADOW_OFFSET_Y + config.SHADOW_BLUR + 4;
        
        // Create SVG element
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', svgWidth);
        svg.setAttribute('height', svgHeight);
        svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
        svg.style.overflow = 'visible';
        
        // Define filter for shadow
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
        filter.setAttribute('id', `shadow-${building.id}`);
        filter.setAttribute('x', '-50%');
        filter.setAttribute('y', '-50%');
        filter.setAttribute('width', '200%');
        filter.setAttribute('height', '200%');
        
        const feDropShadow = document.createElementNS('http://www.w3.org/2000/svg', 'feDropShadow');
        feDropShadow.setAttribute('dx', config.SHADOW_OFFSET_X);
        feDropShadow.setAttribute('dy', config.SHADOW_OFFSET_Y);
        feDropShadow.setAttribute('stdDeviation', config.SHADOW_BLUR / 2);
        feDropShadow.setAttribute('flood-color', config.SHADOW_COLOR);
        filter.appendChild(feDropShadow);
        defs.appendChild(filter);
        svg.appendChild(defs);
        
        // Building group with shadow filter
        const buildingGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        buildingGroup.setAttribute('filter', `url(#shadow-${building.id})`);
        
        // Starting position
        const startX = 1;
        const startY = 4;
        
        // 1. SIDE WALL (right side - creates depth illusion)
        const sideWall = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        const sidePoints = [
          `${startX + baseWidth},${startY}`,
          `${startX + baseWidth + isoOffsetX},${startY - 3}`,
          `${startX + baseWidth + isoOffsetX},${startY + height + baseDepth - 3}`,
          `${startX + baseWidth},${startY + height + baseDepth}`
        ].join(' ');
        sideWall.setAttribute('points', sidePoints);
        sideWall.setAttribute('fill', colors.side);
        buildingGroup.appendChild(sideWall);
        
        // 2. FRONT WALL (main face)
        const frontWall = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        frontWall.setAttribute('x', startX);
        frontWall.setAttribute('y', startY);
        frontWall.setAttribute('width', baseWidth);
        frontWall.setAttribute('height', height + baseDepth);
        frontWall.setAttribute('fill', colors.front);
        frontWall.setAttribute('rx', '1');
        buildingGroup.appendChild(frontWall);
        
        // 3. ROOF (top face - angled for depth)
        const roof = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        const roofPoints = [
          `${startX},${startY}`,
          `${startX + baseWidth},${startY}`,
          `${startX + baseWidth + isoOffsetX},${startY - 3}`,
          `${startX + isoOffsetX},${startY - 3}`
        ].join(' ');
        roof.setAttribute('points', roofPoints);
        roof.setAttribute('fill', colors.roof);
        buildingGroup.appendChild(roof);
        
        // 4. ACCENT STRIPE (building identity - at top)
        const accentStripe = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        accentStripe.setAttribute('x', startX);
        accentStripe.setAttribute('y', startY + 2);
        accentStripe.setAttribute('width', baseWidth);
        accentStripe.setAttribute('height', 3);
        accentStripe.setAttribute('fill', colors.accent);
        buildingGroup.appendChild(accentStripe);
        
        // 5. WINDOWS (scale with building size)
        const windowRows = heightTier === 'large' ? 2 : 1;
        const windowCols = Math.max(1, Math.floor(baseWidth / 12));
        const windowWidth = 3;
        const windowHeight = 4;
        const windowSpacingX = (baseWidth - windowCols * windowWidth) / (windowCols + 1);
        const windowStartY = startY + 8;
        const windowSpacingY = heightTier === 'large' ? 8 : 0;
        
        for (let row = 0; row < windowRows; row++) {
          for (let col = 0; col < windowCols; col++) {
            const windowEl = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            const wx = startX + windowSpacingX + col * (windowWidth + windowSpacingX);
            const wy = windowStartY + row * (windowHeight + windowSpacingY);
            
            windowEl.setAttribute('x', wx);
            windowEl.setAttribute('y', wy);
            windowEl.setAttribute('width', windowWidth);
            windowEl.setAttribute('height', windowHeight);
            windowEl.setAttribute('fill', colors.windowColor);
            windowEl.setAttribute('opacity', '0.8');
            windowEl.setAttribute('rx', '0.5');
            buildingGroup.appendChild(windowEl);
          }
        }
        
        // 6. DOOR (at bottom center)
        const doorWidth = Math.min(6, baseWidth * 0.3);
        const doorHeight = Math.min(8, height * 0.4);
        const door = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        door.setAttribute('x', startX + (baseWidth - doorWidth) / 2);
        door.setAttribute('y', startY + height + baseDepth - doorHeight);
        door.setAttribute('width', doorWidth);
        door.setAttribute('height', doorHeight);
        door.setAttribute('fill', '#1a1a1a');
        door.setAttribute('rx', '0.5');
        buildingGroup.appendChild(door);
        
        // 7. ICON BADGE (small circle with icon in corner) - for identification
        const badgeSize = 10;
        const badgeX = startX + baseWidth - badgeSize / 2 + 2;
        const badgeY = startY - 2;
        
        // Badge background
        const badge = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        badge.setAttribute('cx', badgeX);
        badge.setAttribute('cy', badgeY);
        badge.setAttribute('r', badgeSize / 2);
        badge.setAttribute('fill', colors.accent);
        badge.setAttribute('stroke', '#1a1a1a');
        badge.setAttribute('stroke-width', '1');
        buildingGroup.appendChild(badge);
        
        // Badge icon
        const iconText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        iconText.setAttribute('x', badgeX);
        iconText.setAttribute('y', badgeY + 3);
        iconText.setAttribute('font-size', '7');
        iconText.setAttribute('text-anchor', 'middle');
        iconText.textContent = building.icon;
        buildingGroup.appendChild(iconText);
        
        svg.appendChild(buildingGroup);
        
        return svg;
      },
      
      // Render all buildings inside the SVG map layer
      renderBuildings() {
        const buildings = GameState.map.buildings;
        if (!buildings || buildings.length === 0) {
          console.log(' No buildings to render');
          return;
        }
        
        // Find or create the buildings container inside map-icons
        const iconsContainer = document.getElementById('map-icons');
        if (!iconsContainer) {
          console.warn('Icons container not found for building rendering');
          return;
        }
        
        // Get tile size from RENDER_CONFIG
        const tileSize = RENDER_CONFIG.TILE_SIZE_PX; // 30px
        const gridWidth = GameState.map.width;
        const gridHeight = GameState.map.height;
        
        // Remove existing building elements
        iconsContainer.querySelectorAll('.building-icon').forEach(el => el.remove());
        
        // Sort buildings by Y position for proper layering (back to front)
        const sortedBuildings = [...buildings].sort((a, b) => a.y - b.y);
        
        // Render each building as a 2.5D element
        sortedBuildings.forEach((building, index) => {
          const buildingEl = document.createElement('div');
          buildingEl.className = 'building-icon building-3d';
          buildingEl.dataset.buildingId = building.id;
          buildingEl.dataset.type = building.typeId;
          
          // === TILE-SNAPPED POSITIONING ===
          // Building tile coordinates (x, y) represent top-left of footprint
          const col = building.x;
          const row = building.y;
          const footprintW = building.footprint.width;
          const footprintH = building.footprint.height;
          
          // Calculate center of the footprint in tile coordinates
          // For a 1x1 building at tile (5,5): center is (5.5, 5.5)
          // For a 2x2 building at tile (5,5): center is (6, 6)
          const centerCol = col + (footprintW / 2);
          const centerRow = row + (footprintH / 2);
          
          // Convert to pixel coordinates (snap to tile grid)
          const centerX = centerCol * tileSize;
          const centerY = centerRow * tileSize;
          
          // Position element at the center of the footprint
          buildingEl.style.left = `${centerX}px`;
          buildingEl.style.top = `${centerY}px`;
          buildingEl.style.position = 'absolute';
          
          // Transform to anchor the visual at bottom-center of the building sprite
          // -50% centers horizontally, -100% puts bottom of sprite at the position
          buildingEl.style.transform = 'translate(-50%, -100%)';
          buildingEl.style.cursor = 'pointer';
          buildingEl.style.zIndex = `${10 + row}`; // Layer by row for proper depth
          buildingEl.style.transition = 'transform 0.12s ease, filter 0.12s ease';
          
          // Create 2.5D SVG building
          const buildingSVG = this.createBuildingSVG(building);
          buildingEl.appendChild(buildingSVG);
          
          // Add tooltip-style label
          buildingEl.title = building.name;
          
          // Touch-friendly: larger hit area
          buildingEl.style.padding = '4px';
          buildingEl.style.margin = '-4px';
          
          // Add hover/touch effect
          buildingEl.addEventListener('mouseenter', () => {
            buildingEl.style.transform = 'translate(-50%, -100%) scale(1.1)';
            buildingEl.style.zIndex = '100';
          });
          
          buildingEl.addEventListener('mouseleave', () => {
            buildingEl.style.transform = 'translate(-50%, -100%) scale(1)';
            buildingEl.style.zIndex = `${10 + row}`;
          });
          
          // Touch events for mobile
          buildingEl.addEventListener('touchstart', (e) => {
            buildingEl.style.transform = 'translate(-50%, -100%) scale(1.1)';
            buildingEl.style.zIndex = '100';
          }, { passive: true });
          
          buildingEl.addEventListener('touchend', () => {
            setTimeout(() => {
              buildingEl.style.transform = 'translate(-50%, -100%) scale(1)';
              buildingEl.style.zIndex = `${10 + row}`;
            }, 150);
          }, { passive: true });
          
          // Click handler to show building menu
          buildingEl.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log(`Building clicked: ${building.name} (${building.id})`);
            this.showBuildingMenu(building);
          });
          
          iconsContainer.appendChild(buildingEl);
          
          // Debug log for verification
          console.log(` Rendered ${building.name} at tile (${col},${row}) -> pixel (${centerX},${centerY})`);
        });
        
        console.log(` Rendered ${buildings.length} 2.5D buildings on map`);
      },
      
      showBuildingMenu(building) {
        const modal = document.createElement('div');
        modal.className = 'event-modal';
        modal.id = 'building-modal';
        
        const interactionsHTML = building.interactions.map(interaction => `
          <button class="choice-btn" data-action="${interaction.action}">
            <span class="choice-icon">${interaction.label.split(' ')[0]}</span>
            <span class="choice-text">${interaction.label.substring(2)}</span>
          </button>
        `).join('');
        
        modal.innerHTML = `
          <div class="event-modal-content">
            <div class="event-modal-icon">${building.icon}</div>
            <div class="event-modal-title">${building.name}</div>
            <div class="event-modal-description">Interact with this building</div>
            
            <div class="event-choices">
              ${interactionsHTML}
            </div>
            
            <button class="outcome-btn" id="close-building-modal" style="margin-top: 12px;">
               Leave
            </button>
          </div>
        `;
        
        document.getElementById('app').appendChild(modal);
        
        // Action handlers
        modal.querySelectorAll('.choice-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const action = btn.dataset.action;
            this.handleBuildingAction(action, building, modal);
          });
        });
        
        // Close handler
        document.getElementById('close-building-modal')?.addEventListener('click', () => {
          modal.remove();
        });
      },
      
      handleBuildingAction(action, building, modal) {
        // Placeholder for future implementation
        modal.remove();
        
        const notification = document.createElement('div');
        notification.className = 'xp-notification';
        notification.innerHTML = '<span class="xp-positive"> Coming Soon!</span>';
        document.getElementById('app').appendChild(notification);
        setTimeout(() => notification.remove(), 2000);
      }
    };
    
    // ========================================
    // PHASE 7.5: ROADS & BUILDINGS
    // ========================================

    // Road system configuration
    const ROAD_CONFIG = {
      ENABLE_ROADS: true,
      MAIN_ROAD_WIDTH: 2,        // Tiles wide for main roads
      SIDE_ROAD_WIDTH: 1,        // Tiles wide for side streets
      MIN_ROAD_LENGTH: 3,        // Minimum road segment length
      ROAD_COLOR: '#2a2a2a',     // Dark gray
      ROAD_OPACITY: 0.8
    };

    // Building density configuration
    const BUILDING_CONFIG = {
      DENSITY_LEVELS: {
        none: { min: 0, max: 0, icon: '', description: 'Empty lot' },
        low: { min: 1, max: 2, icon: '', description: 'Sparse buildings' },
        medium: { min: 3, max: 5, icon: '', description: 'Moderate density' },
        high: { min: 6, max: 10, icon: '', description: 'Dense buildings' },
        extreme: { min: 11, max: 20, icon: '', description: 'Skyscrapers' }
      },
      
      // Biome-specific density ranges
      BIOME_DENSITY: {
        urban: { min: 'high', max: 'extreme' },
        suburban: { min: 'low', max: 'medium' },
        industrial: { min: 'medium', max: 'high' },
        coastal: { min: 'none', max: 'low' },
        rural: { min: 'none', max: 'low' }
      }
    };

    // Road Generator
    const RoadGenerator = {
      // Main road network generation
      generateRoadNetwork(grid, landmarks, random) {
        console.log('=== Generating Road Network ===');
        const startTime = performance.now();
        
        const width = grid[0].length;
        const height = grid.length;
        const roads = [];
        
        // 1. Generate modular grid system (avoids water)
        const gridRoads = this.generateModularGrid(grid, width, height);
        roads.push(...gridRoads);
        
        // 2. Connect landmarks with arterial roads (avoids water)
        const arterialRoads = this.connectLandmarks(grid, landmarks, random);
        roads.push(...arterialRoads);
        
        // 3. Mark road tiles in grid
        this.markRoadTiles(grid, roads);
        
        const duration = performance.now() - startTime;
        console.log(`Generated ${roads.length} road segments in ${duration.toFixed(1)}ms`);
        console.log('==============================');
        
        return roads;
      },
      
      // Generate modular grid system (avoids water, uses golden ratio)
      generateModularGrid(grid, width, height) {
        const roads = [];
        
        // Use golden ratio for main arterial spacing (  1.618)
        const goldenRatio = 1.618;
        const baseSpacing = 5; // Base grid spacing
        const majorSpacing = Math.round(baseSpacing * goldenRatio); // ~8 tiles
        
        // Vertical arterial roads (major roads)
        for (let x = 0; x < width; x += majorSpacing) {
          for (let y = 0; y < height; y++) {
            const tile = grid[y][x];
            // Skip if coastal/water biome
            if (tile && tile.biome !== 'coastal') {
              roads.push({ x, y, type: 'arterial' });
            }
          }
        }
        
        // Horizontal arterial roads (major roads)
        for (let y = 0; y < height; y += majorSpacing) {
          for (let x = 0; x < width; x++) {
            const tile = grid[y][x];
            // Skip if coastal/water biome
            if (tile && tile.biome !== 'coastal') {
              roads.push({ x, y, type: 'arterial' });
            }
          }
        }
        
        // Secondary grid roads (smaller streets) - only in urban/suburban
        for (let x = baseSpacing; x < width; x += baseSpacing) {
          for (let y = 0; y < height; y++) {
            const tile = grid[y][x];
            // Only place in urban/suburban, skip water
            if (tile && (tile.biome === 'urban' || tile.biome === 'suburban') && tile.biome !== 'coastal') {
              // Skip if already an arterial road
              const isArterial = (x % majorSpacing === 0);
              if (!isArterial) {
                roads.push({ x, y, type: 'street' });
              }
            }
          }
        }
        
        for (let y = baseSpacing; y < height; y += baseSpacing) {
          for (let x = 0; x < width; x++) {
            const tile = grid[y][x];
            // Only place in urban/suburban, skip water
            if (tile && (tile.biome === 'urban' || tile.biome === 'suburban') && tile.biome !== 'coastal') {
              // Skip if already an arterial road
              const isArterial = (y % majorSpacing === 0);
              if (!isArterial) {
                roads.push({ x, y, type: 'street' });
              }
            }
          }
        }
        
        return roads;
      },
      
      // Connect landmarks with roads (avoids water)
      connectLandmarks(grid, landmarks, random) {
        const roads = [];
        const width = grid[0].length;
        const height = grid.length;
        
        // Sort landmarks by importance (safe house, police, hospital priority)
        const priorityLandmarks = landmarks.filter(l => 
          l.type.id === 'safeHouse' || 
          l.type.id === 'police' || 
          l.type.id === 'hospital'
        );
        
        // Connect each landmark to nearest neighbor (avoid water)
        for (let i = 0; i < priorityLandmarks.length - 1; i++) {
          const from = priorityLandmarks[i];
          const to = priorityLandmarks[i + 1];
          
          // Create road path avoiding water
          const path = this.createPathAvoidingWater(grid, from.x, from.y, to.x, to.y);
          roads.push(...path);
        }
        
        return roads;
      },
      
      // Create path between two points (avoids water)
      createPathAvoidingWater(grid, x1, y1, x2, y2) {
        const roads = [];
        
        // Simple L-shaped path with water avoidance
        // Horizontal segment
        const minX = Math.min(x1, x2);
        const maxX = Math.max(x1, x2);
        for (let x = minX; x <= maxX; x++) {
          const tile = grid[y1] && grid[y1][x];
          // Skip water tiles
          if (tile && tile.biome !== 'coastal') {
            roads.push({ x, y: y1, type: 'connector' });
          }
        }
        
        // Vertical segment
        const minY = Math.min(y1, y2);
        const maxY = Math.max(y1, y2);
        for (let y = minY; y <= maxY; y++) {
          const tile = grid[y] && grid[y][x2];
          // Skip water tiles
          if (tile && tile.biome !== 'coastal') {
            roads.push({ x: x2, y, type: 'connector' });
          }
        }
        
        return roads;
      },
      
      // Mark tiles as roads
      markRoadTiles(grid, roads) {
        for (const road of roads) {
          const tile = TileGridGenerator.getTile(grid, road.x, road.y);
          if (tile) {
            tile.metadata.isRoad = true;
            tile.metadata.roadType = road.type;
          }
        }
      },
      
      // Check if tile is on a road
      isOnRoad(grid, x, y) {
        const tile = TileGridGenerator.getTile(grid, x, y);
        return tile && tile.metadata.isRoad === true;
      }
    };

    // Building Density Generator
    const BuildingGenerator = {
      // Assign building density to all tiles
      generateBuildingDensity(grid, random) {
        console.log('=== Generating Building Density ===');
        const startTime = performance.now();
        
        const width = grid[0].length;
        const height = grid.length;
        
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const tile = grid[y][x];
            
            // Skip roads
            if (tile.metadata.isRoad) {
              tile.metadata.buildingDensity = 'none';
              tile.metadata.buildingCount = 0;
              continue;
            }
            
            // Determine density based on biome
            const density = this.calculateDensity(tile, grid, x, y, random);
            tile.metadata.buildingDensity = density.level;
            tile.metadata.buildingCount = density.count;
          }
        }
        
        const duration = performance.now() - startTime;
        console.log(`Building density assigned in ${duration.toFixed(1)}ms`);
        console.log('==================================');
      },
      
      // Calculate building density for tile
      calculateDensity(tile, grid, x, y, random) {
        const biome = tile.biome;
        const densityRange = BUILDING_CONFIG.BIOME_DENSITY[biome];
        
        if (!densityRange) {
          return { level: 'none', count: 0 };
        }
        
        // Get min and max density levels for biome
        const minLevel = densityRange.min;
        const maxLevel = densityRange.max;
        
        // Select random level within range
        const levels = Object.keys(BUILDING_CONFIG.DENSITY_LEVELS);
        const minIndex = levels.indexOf(minLevel);
        const maxIndex = levels.indexOf(maxLevel);
        
        const selectedIndex = minIndex + Math.floor(random() * (maxIndex - minIndex + 1));
        const selectedLevel = levels[selectedIndex];
        
        // Get building count for level
        const levelConfig = BUILDING_CONFIG.DENSITY_LEVELS[selectedLevel];
        const count = levelConfig.min + Math.floor(random() * (levelConfig.max - levelConfig.min + 1));
        
        // Increase density near landmarks (cluster effect)
        const nearLandmark = this.isNearLandmark(grid, x, y);
        if (nearLandmark && selectedLevel !== 'none') {
          // Bump up one level
          const bumpedIndex = Math.min(selectedIndex + 1, levels.length - 1);
          return {
            level: levels[bumpedIndex],
            count: BUILDING_CONFIG.DENSITY_LEVELS[levels[bumpedIndex]].max
          };
        }
        
        return { level: selectedLevel, count };
      },
      
      // Check if tile is near a landmark
      isNearLandmark(grid, x, y, radius = 2) {
        // This is simplified - in real implementation would check landmark positions
        return false; // Placeholder
      },
      
      // Get building density level for tile
      getDensityLevel(grid, x, y) {
        const tile = TileGridGenerator.getTile(grid, x, y);
        return tile ? tile.metadata.buildingDensity : 'none';
      },
      
      // Get building count for tile
      getBuildingCount(grid, x, y) {
        const tile = TileGridGenerator.getTile(grid, x, y);
        return tile ? (tile.metadata.buildingCount || 0) : 0;
      }
    };

    // Zone Analytics (how roads and buildings affect gameplay)
    const ZoneAnalytics = {
      // Calculate crime difficulty modifier for position
      getCrimeDifficultyModifier(x, y) {
        if (!GameState.map.grid) return 1.0;
        
        const gridX = Math.floor((x / 100) * GameState.map.width);
        const gridY = Math.floor((y / 100) * GameState.map.height);
        const tile = TileGridGenerator.getTile(GameState.map.grid, gridX, gridY);
        
        if (!tile) return 1.0;
        
        let modifier = 1.0;
        
        // 1. Building density increases difficulty
        const density = tile.metadata.buildingDensity || 'none';
        const densityModifiers = {
          none: 0.8,      // Easier in empty areas
          low: 1.0,       // Normal
          medium: 1.1,    // Slightly harder
          high: 1.25,     // Much harder
          extreme: 1.5    // Very hard (many witnesses)
        };
        modifier *= densityModifiers[density] || 1.0;
        
        // 2. Roads provide escape routes (decrease difficulty)
        if (tile.metadata.isRoad) {
          modifier *= 0.9; // 10% easier on roads
        }
        
        // 3. Dense areas = more police
        const buildingCount = tile.metadata.buildingCount || 0;
        if (buildingCount > 10) {
          modifier *= 1.15; // +15% difficulty in very dense areas
        }
        
        return modifier;
      },
      
      // Calculate reward modifier for position
      getRewardModifier(x, y) {
        if (!GameState.map.grid) return 1.0;
        
        const gridX = Math.floor((x / 100) * GameState.map.width);
        const gridY = Math.floor((y / 100) * GameState.map.height);
        const tile = TileGridGenerator.getTile(GameState.map.grid, gridX, gridY);
        
        if (!tile) return 1.0;
        
        let modifier = 1.0;
        
        // 1. Higher density = more valuable targets
        const density = tile.metadata.buildingDensity || 'none';
        const rewardModifiers = {
          none: 0.5,      // Poor pickings
          low: 0.8,       // Below average
          medium: 1.0,    // Normal
          high: 1.3,      // Good targets
          extreme: 1.6    // Rich targets
        };
        modifier *= rewardModifiers[density] || 1.0;
        
        // 2. Urban areas = more cash
        if (tile.biome === 'urban') {
          modifier *= 1.2;
        }
        
        return modifier;
      },
      
      // Calculate escape chance modifier
      getEscapeModifier(x, y) {
        if (!GameState.map.grid) return 1.0;
        
        const gridX = Math.floor((x / 100) * GameState.map.width);
        const gridY = Math.floor((y / 100) * GameState.map.height);
        const tile = TileGridGenerator.getTile(GameState.map.grid, gridX, gridY);
        
        if (!tile) return 1.0;
        
        let modifier = 1.0;
        
        // On a road = better escape
        if (tile.metadata.isRoad) {
          modifier *= 1.15; // +15% escape chance
        }
        
        // Dense buildings = harder to escape
        const density = tile.metadata.buildingDensity || 'none';
        if (density === 'high' || density === 'extreme') {
          modifier *= 0.9; // -10% escape in crowded areas
        }
        
        // Rural/open areas = easier escape
        if (tile.biome === 'rural') {
          modifier *= 1.1; // +10% in open areas
        }
        
        return modifier;
      },
      
      // Calculate police presence level
      getPolicePresence(x, y) {
        if (!GameState.map.grid) return 'low';
        
        const gridX = Math.floor((x / 100) * GameState.map.width);
        const gridY = Math.floor((y / 100) * GameState.map.height);
        const tile = TileGridGenerator.getTile(GameState.map.grid, gridX, gridY);
        
        if (!tile) return 'low';
        
        const buildingCount = tile.metadata.buildingCount || 0;
        
        if (buildingCount >= 15) return 'extreme';
        if (buildingCount >= 10) return 'high';
        if (buildingCount >= 5) return 'medium';
        return 'low';
      },
      
      // Get zone description for UI
      getZoneDescription(x, y) {
        if (!GameState.map.grid) return 'Unknown area';
        
        const gridX = Math.floor((x / 100) * GameState.map.width);
        const gridY = Math.floor((y / 100) * GameState.map.height);
        const tile = TileGridGenerator.getTile(GameState.map.grid, gridX, gridY);
        
        if (!tile) return 'Unknown area';
        
        const biome = Object.values(BIOMES).find(b => b.id === tile.biome);
        const density = tile.metadata.buildingDensity || 'none';
        const densityConfig = BUILDING_CONFIG.DENSITY_LEVELS[density];
        const isRoad = tile.metadata.isRoad || false;
        
        let description = biome ? biome.name : 'Unknown';
        if (densityConfig && density !== 'none') {
          description += ` - ${densityConfig.description}`;
        }
        if (isRoad) {
          description += ' (Road)';
        }
        
        return description;
      }
    };

    // Initialize roads and buildings
    function initRoadsAndBuildings() {
      console.log('=== PHASE 7.5: Roads & Buildings ===');
      
      if (!GameState.map.grid) {
        console.error('Cannot generate roads/buildings - map not generated');
        return;
      }
      
      // Check if roads already generated
      const firstTile = GameState.map.grid[0][0];
      const roadsAlreadyGenerated = firstTile.metadata.isRoad !== undefined;
      
      if (roadsAlreadyGenerated) {
        console.log('Roads already generated');
        // Still need to mark roads in occupancy grid
        TileOccupancy.markRoads(GameState.map.grid);
      } else {
        // Get seeded random
        const random = MapSeedManager.createMapRandom();
        
        // Generate roads
        if (ROAD_CONFIG.ENABLE_ROADS) {
          const roads = RoadGenerator.generateRoadNetwork(
            GameState.map.grid,
            GameState.mapIcons.map((icon, i) => ({
              x: Math.floor((icon.x / 100) * GameState.map.width),
              y: Math.floor((icon.y / 100) * GameState.map.height),
              type: { id: icon.type }
            })),
            random
          );
        }
        
        // Mark roads in occupancy grid after generation
        TileOccupancy.markRoads(GameState.map.grid);
        
        // Generate building density
        BuildingGenerator.generateBuildingDensity(GameState.map.grid, random);
      }
      
      // ALWAYS try to place interactive buildings (handles migration from old saves)
      initInteractiveBuildings();
      
      // Save
      Storage.save();
      
      console.log('===================================');
    }
    
    // Initialize interactive buildings on the map
    function initInteractiveBuildings() {
      console.log('=== Initializing Interactive Buildings ===');
      
      // Check if buildings already placed
      if (GameState.map.buildings && GameState.map.buildings.length > 0) {
        console.log(`Buildings already placed: ${GameState.map.buildings.length}`);
        return;
      }
      
      if (!GameState.map.grid) {
        console.error('Cannot place buildings - map grid not generated');
        return;
      }
      
      // Use seeded random for deterministic placement
      const random = MapSeedManager.createMapRandom();
      
      // Place buildings
      const placedBuildings = BuildingPlacer.placeBuildings(GameState.map.grid, random);
      
      // Store in GameState
      GameState.map.buildings = placedBuildings;
      
      console.log(`Stored ${placedBuildings.length} buildings in GameState`);
      console.log('==========================================');
    }

    // Extend ProceduralMapRenderer to show roads and buildings
    const RoadBuildingRenderer = {
      // Render roads on tiles with realistic asphalt texture
      renderRoads(container) {
        if (!ROAD_CONFIG.ENABLE_ROADS) return;
        
        const grid = GameState.map.grid;
        const width = GameState.map.width;
        const height = GameState.map.height;
        const tileSize = RENDER_CONFIG.TILE_SIZE_PX;
        
        // Create single unified road layer
        const roadLayer = document.createElement('div');
        roadLayer.style.position = 'absolute';
        roadLayer.style.top = '0';
        roadLayer.style.left = '0';
        roadLayer.style.width = (width * tileSize) + 'px';
        roadLayer.style.height = (height * tileSize) + 'px';
        roadLayer.style.zIndex = '1';
        roadLayer.style.pointerEvents = 'none';
        
        // Unified asphalt texture across entire layer
        roadLayer.style.background = `
          radial-gradient(circle at 25% 30%, rgba(40, 44, 48, 0.3) 0%, transparent 50%),
          radial-gradient(circle at 75% 70%, rgba(35, 39, 42, 0.2) 0%, transparent 50%),
          radial-gradient(circle at 50% 50%, rgba(45, 48, 51, 0.2) 0%, transparent 50%),
          #2a2e30
        `;
        roadLayer.style.boxShadow = 'inset 0 0 2px rgba(0, 0, 0, 0.4)';
        roadLayer.style.opacity = '0.9';
        
        // Use CSS clip-path to create road shapes
        let roadPaths = [];
        
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const tile = grid[y][x];
            
            if (tile.metadata.isRoad) {
              // Add rectangular path for this tile
              const left = x * tileSize;
              const top = y * tileSize;
              const right = left + tileSize;
              const bottom = top + tileSize;
              
              roadPaths.push(`
                polygon(
                  ${left}px ${top}px,
                  ${right}px ${top}px,
                  ${right}px ${bottom}px,
                  ${left}px ${bottom}px
                )
              `);
            }
          }
        }
        
        // Create mask using SVG for perfect seamless roads
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("width", width * tileSize);
        svg.setAttribute("height", height * tileSize);
        svg.style.position = 'absolute';
        svg.style.top = '0';
        svg.style.left = '0';
        svg.style.pointerEvents = 'none';
        
        const mask = document.createElementNS(svgNS, "mask");
        mask.setAttribute("id", "road-mask");
        
        // White rectangles for road tiles (visible areas)
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const tile = grid[y][x];
            
            if (tile.metadata.isRoad) {
              const rect = document.createElementNS(svgNS, "rect");
              rect.setAttribute("x", x * tileSize);
              rect.setAttribute("y", y * tileSize);
              rect.setAttribute("width", tileSize);
              rect.setAttribute("height", tileSize);
              rect.setAttribute("fill", "white");
              mask.appendChild(rect);
            }
          }
        }
        
        svg.appendChild(mask);
        
        // Create road surface with mask
        const roadSurface = document.createElementNS(svgNS, "rect");
        roadSurface.setAttribute("width", "100%");
        roadSurface.setAttribute("height", "100%");
        roadSurface.setAttribute("fill", "#2a2e30");
        roadSurface.setAttribute("mask", "url(#road-mask)");
        
        svg.appendChild(roadSurface);
        
        // Add subtle texture overlay
        const pattern = document.createElementNS(svgNS, "pattern");
        pattern.setAttribute("id", "asphalt-texture");
        pattern.setAttribute("width", "4");
        pattern.setAttribute("height", "4");
        pattern.setAttribute("patternUnits", "userSpaceOnUse");
        
        for (let i = 0; i < 3; i++) {
          const circle = document.createElementNS(svgNS, "circle");
          circle.setAttribute("cx", Math.random() * 4);
          circle.setAttribute("cy", Math.random() * 4);
          circle.setAttribute("r", "0.5");
          circle.setAttribute("fill", `rgba(40, 44, 48, ${0.2 + Math.random() * 0.2})`);
          pattern.appendChild(circle);
        }
        
        svg.appendChild(pattern);
        
        const textureOverlay = document.createElementNS(svgNS, "rect");
        textureOverlay.setAttribute("width", "100%");
        textureOverlay.setAttribute("height", "100%");
        textureOverlay.setAttribute("fill", "url(#asphalt-texture)");
        textureOverlay.setAttribute("mask", "url(#road-mask)");
        textureOverlay.setAttribute("opacity", "0.3");
        
        svg.appendChild(textureOverlay);
        
        container.appendChild(svg);
        
        console.log(`Rendered seamless road surface with ${roadPaths.length} tiles`);
      },
      
      // Render building density indicators
      renderBuildings(container) {
        // DISABLED: Building grid icons removed for Phase 1
        // Interactive buildings will be added separately
        console.log(' Building grid disabled - using interactive buildings instead');
        return;
        
        /* OLD CODE - REMOVED
        const grid = GameState.map.grid;
        const width = GameState.map.width;
        const height = GameState.map.height;
        const tileSize = RENDER_CONFIG.TILE_SIZE_PX;
        
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const tile = grid[y][x];
            const density = tile.metadata.buildingDensity;
            const biome = tile.biome;
            
            // Skip if: no density, on road, or on coastal/water biome
            if (!density || density === 'none' || tile.metadata.isRoad || biome === 'coastal') {
              continue;
            }
            
            const buildingDiv = document.createElement('div');
            buildingDiv.className = 'building-indicator';
            buildingDiv.style.position = 'absolute';
            buildingDiv.style.left = (x * tileSize) + 'px';
            buildingDiv.style.top = (y * tileSize) + 'px';
            buildingDiv.style.width = tileSize + 'px';
            buildingDiv.style.height = tileSize + 'px';
            buildingDiv.style.pointerEvents = 'none';
            buildingDiv.style.display = 'flex';
            buildingDiv.style.alignItems = 'center';
            buildingDiv.style.justifyContent = 'center';
            buildingDiv.style.fontSize = '20px';
            buildingDiv.style.opacity = '0.7';
            buildingDiv.style.zIndex = '2';
            
            // Show icon based on density
            const densityConfig = BUILDING_CONFIG.DENSITY_LEVELS[density];
            if (densityConfig && densityConfig.icon) {
              buildingDiv.textContent = densityConfig.icon;
            }
            
            container.appendChild(buildingDiv);
          }
        }
        */
      }
    };

    // Debug utilities
    window.showZoneInfo = function(xPercent, yPercent) {
      console.log('=== Zone Information ===');
      console.log('Position:', `${xPercent.toFixed(1)}%, ${yPercent.toFixed(1)}%`);
      console.log('Description:', ZoneAnalytics.getZoneDescription(xPercent, yPercent));
      console.log('Crime Difficulty:', (ZoneAnalytics.getCrimeDifficultyModifier(xPercent, yPercent) * 100).toFixed(0) + '%');
      console.log('Reward Modifier:', (ZoneAnalytics.getRewardModifier(xPercent, yPercent) * 100).toFixed(0) + '%');
      console.log('Escape Chance:', (ZoneAnalytics.getEscapeModifier(xPercent, yPercent) * 100).toFixed(0) + '%');
      console.log('Police Presence:', ZoneAnalytics.getPolicePresence(xPercent, yPercent));
      console.log('=======================');
    };

    window.showCurrentZoneInfo = function() {
      const pos = GameState.character.position;
      showZoneInfo(pos.x, pos.y);
    };

    window.toggleRoadRendering = function(enabled) {
      ROAD_CONFIG.ENABLE_ROADS = enabled;
      ProceduralMapRenderer.forceRender();
      console.log('Road rendering:', enabled ? 'ENABLED' : 'DISABLED');
    };

    // Building debug utilities
    window.showBuildingInfo = function() {
      console.log('=== Interactive Buildings ===');
      const buildings = GameState.map.buildings || [];
      console.log('Total buildings:', buildings.length);
      buildings.forEach(b => {
        console.log(`  ${b.icon} ${b.name} (${b.id})`);
        console.log(`    Tile: (${b.x}, ${b.y})  ${b.xPercent.toFixed(1)}%, ${b.yPercent.toFixed(1)}%`);
        console.log(`    Biome: ${b.biome}`);
      });
      console.log('============================');
    };

    window.resetBuildings = function() {
      console.log('Resetting buildings...');
      GameState.map.buildings = [];
      initInteractiveBuildings();
      TurfTab.render();
      Storage.save();
      console.log('Buildings reset and re-placed.');
    };

    window.forceRenderBuildings = function() {
      InteractiveBuildings.renderBuildings();
    };
    
    window.debugMap = function() {
      console.log('=== MAP DEBUG INFO ===');
      console.log('GameState.map.seed:', GameState.map.seed);
      console.log('GameState.map.grid exists:', GameState.map.grid !== null);
      console.log('GameState.map.width:', GameState.map.width);
      console.log('GameState.map.height:', GameState.map.height);
      console.log('GameState.map.buildings:', GameState.map.buildings ? GameState.map.buildings.length : 'null/undefined');
      console.log('ProceduralMapRenderer.rendered:', ProceduralMapRenderer.rendered);
      
      const mapContainer = document.getElementById('city-map');
      console.log('city-map element exists:', mapContainer !== null);
      
      if (mapContainer) {
        const tileLayer = mapContainer.querySelector('#tile-layer');
        const unifiedLayer = mapContainer.querySelector('#unified-biome-layer');
        console.log('tile-layer exists:', tileLayer !== null);
        console.log('unified-biome-layer exists:', unifiedLayer !== null);
        console.log('city-map children:', mapContainer.children.length);
        Array.from(mapContainer.children).forEach((child, i) => {
          console.log(`  [${i}] ${child.tagName}#${child.id || '(no id)'}`);
        });
      }
      console.log('======================');
    };
    
    window.forceMapRender = function() {
      console.log('Forcing map render...');
      ProceduralMapRenderer.rendered = false;
      ProceduralMapRenderer.renderMap();
      InteractiveBuildings.renderBuildings();
    };
    
    window.placeBuildingsNow = function() {
      console.log('Manually placing buildings...');
      GameState.map.buildings = []; // Clear existing
      initInteractiveBuildings();
      InteractiveBuildings.renderBuildings();
      Storage.save();
      console.log('Buildings placed:', GameState.map.buildings.length);
    };

    // ========================================
    // PHASE 7.6: ENHANCED LANDMARK PLACEMENT
    // ========================================

    // Enhanced landmark placement rules (extends Phase 7.4C)
    const ENHANCED_LANDMARK_RULES = {
      safeHouse: {
        // Safe House favors low visibility
        preferredDensity: ['none', 'low'],      // Avoid crowded areas
        avoidDensity: ['high', 'extreme'],      // Never in very dense areas
        preferredBiomes: ['suburban', 'rural'], // Existing rule
        avoidRoads: true,                       // Prefer hidden locations
        visibilityWeight: -50,                  // Negative = prefer low visibility
        description: 'Prefers hidden, low-density areas'
      },
      
      dealer: {
        // Dealers favor medium density (customers but not too much police)
        preferredDensity: ['medium', 'high'],   // Need customers
        avoidDensity: ['none', 'extreme'],      // Not empty or too crowded
        preferredBiomes: ['urban', 'industrial', 'suburban'], // Existing
        preferRoads: true,                      // Quick escape routes
        visibilityWeight: 20,                   // Slight preference for visibility
        description: 'Prefers medium-density areas with road access'
      },
      
      gang: {
        // Gangs favor industrial with high density
        preferredDensity: ['medium', 'high'],   // Need territory
        avoidDensity: ['none', 'low'],          // Not isolated
        preferredBiomes: ['urban', 'industrial'], // Existing
        preferRoads: true,                      // Territory control
        visibilityWeight: 30,                   // Want to be seen
        description: 'Prefers dense industrial/urban zones'
      },
      
      police: {
        // Police favor high-density urban areas
        preferredDensity: ['high', 'extreme'],  // Where crime happens
        avoidDensity: ['none', 'low'],          // Not rural
        preferredBiomes: ['urban', 'suburban'], // Existing
        preferRoads: true,                      // Response time
        visibilityWeight: 50,                   // Maximum visibility
        description: 'Prefers dense urban areas with road access'
      },
      
      hospital: {
        // Hospitals favor accessible, dense areas
        preferredDensity: ['medium', 'high', 'extreme'], // Serve population
        avoidDensity: ['none'],                 // Not isolated
        preferredBiomes: ['urban', 'suburban'], // Existing
        preferRoads: true,                      // Emergency access critical
        visibilityWeight: 40,                   // High visibility
        description: 'Prefers dense areas with excellent road access'
      }
    };

    // Enhanced Landmark Placer (upgrades Phase 7.4C system)
    const EnhancedLandmarkPlacer = {
      // Score candidate using density and roads (extends existing scoring)
      scoreWithDensity(candidate, landmarkType, placedLandmarks, width, height) {
        // Start with base score from Phase 7.4C
        let score = 100;
        
        const { x, y, tile } = candidate;
        const rules = ENHANCED_LANDMARK_RULES[landmarkType.id];
        
        if (!rules) {
          // Fallback to basic scoring if no enhanced rules
          return LandmarkPlacer.scoreCandidate(candidate, landmarkType, placedLandmarks, width, height);
        }
        
        // 1. Building density preference
        const density = tile.metadata.buildingDensity || 'none';
        
        if (rules.preferredDensity && rules.preferredDensity.includes(density)) {
          score += 40; // Strong bonus for preferred density
        }
        
        if (rules.avoidDensity && rules.avoidDensity.includes(density)) {
          score -= 60; // Strong penalty for avoided density
        }
        
        // 2. Road proximity
        const isOnRoad = tile.metadata.isRoad || false;
        
        if (rules.preferRoads && isOnRoad) {
          score += 30; // Bonus for road access
        }
        
        if (rules.avoidRoads && isOnRoad) {
          score -= 40; // Penalty for road visibility
        }
        
        // 3. Visibility weight (based on building count)
        const buildingCount = tile.metadata.buildingCount || 0;
        const normalizedVisibility = buildingCount / 20; // 0-1 scale
        score += rules.visibilityWeight * normalizedVisibility;
        
        // 4. Biome preference (existing logic)
        const biome = tile.biome;
        if (rules.preferredBiomes && rules.preferredBiomes.includes(biome)) {
          score += 20;
        }
        
        // 5. Centrality bonus (from Phase 7.4C)
        const centerX = width / 2;
        const centerY = height / 2;
        const distanceFromCenter = TileGridGenerator.getDistance(x, y, centerX, centerY);
        const maxDistance = TileGridGenerator.getDistance(0, 0, centerX, centerY);
        const centrality = 1 - (distanceFromCenter / maxDistance);
        score += centrality * 15;
        
        // 6. Crowding penalty (from Phase 7.4C)
        for (const placed of placedLandmarks) {
          const distance = TileGridGenerator.getDistance(x, y, placed.x, placed.y);
          const minDistance = landmarkType.minDistanceFromOthers;
          
          if (distance < minDistance * 2) {
            const proximity = 1 - (distance / (minDistance * 2));
            score -= proximity * 30;
          }
        }
        
        return score;
      },
      
      // Enhanced placement with density awareness
      placeAllLandmarksEnhanced(grid, random) {
        console.log('=== Enhanced Landmark Placement ===');
        const startTime = performance.now();
        
        const placedLandmarks = [];
        const width = grid[0].length;
        const height = grid.length;
        
        // Sort by priority (same as Phase 7.4C)
        const landmarkTypes = Object.values(LANDMARK_TYPES).sort((a, b) => a.priority - b.priority);
        
        for (const landmarkType of landmarkTypes) {
          console.log(`Placing ${landmarkType.name} (x${landmarkType.count})...`);
          
          for (let instance = 0; instance < landmarkType.count; instance++) {
            const landmarkId = `${landmarkType.id}_${instance}`;
            
            // Generate candidates (from Phase 7.4C)
            const candidates = LandmarkPlacer.generateCandidates(random, grid, landmarkType, 1);
            
            if (candidates.length === 0) {
              console.warn(`No candidates for ${landmarkId}`);
              continue;
            }
            
            // Filter valid candidates
            const validCandidates = [];
            
            for (const candidate of candidates) {
              if (LandmarkPlacer.isValidPlacement(landmarkType, candidate.x, candidate.y, candidate.tile, placedLandmarks, width, height)) {
                // Use ENHANCED scoring
                const score = this.scoreWithDensity(candidate, landmarkType, placedLandmarks, width, height);
                validCandidates.push({ ...candidate, score });
              }
            }
            
            if (validCandidates.length === 0) {
              console.warn(`No valid placements for ${landmarkId}`);
              continue;
            }
            
            // Sort by enhanced score
            validCandidates.sort((a, b) => b.score - a.score);
            const best = validCandidates[0];
            
            // Reserve tile in occupancy grid BEFORE creating landmark
            const reserved = TileOccupancy.reserveLandmark(best.x, best.y, landmarkId);
            
            if (!reserved) {
              console.warn(`Failed to reserve tile for enhanced landmark ${landmarkId}`);
              continue;
            }
            
            // Create landmark
            const landmark = {
              type: landmarkType,
              x: best.x,
              y: best.y,
              biome: best.tile.biome,
              density: best.tile.metadata.buildingDensity || 'none',
              onRoad: best.tile.metadata.isRoad || false,
              id: landmarkId,
              icon: landmarkType.icon,
              label: landmarkType.name
            };
            
            placedLandmarks.push(landmark);
            
            const rules = ENHANCED_LANDMARK_RULES[landmarkType.id];
            const ruleDesc = rules ? rules.description : 'No enhanced rules';
            console.log(`   Placed ${landmarkId} at (${best.x}, ${best.y})`);
            console.log(`    Biome: ${best.tile.biome}, Density: ${landmark.density}, Road: ${landmark.onRoad}`);
            console.log(`    Rule: ${ruleDesc}`);
          }
        }
        
        const duration = performance.now() - startTime;
        console.log(`Enhanced placement complete in ${duration.toFixed(1)}ms`);
        console.log('==================================');
        
        return placedLandmarks;
      }
    };

    // Placement Validator
    const LandmarkPlacementValidator = {
      // Validate all landmark placements
      validateAllPlacements(landmarks) {
        console.log('=== Validating Landmark Placements ===');
        
        let violations = 0;
        
        for (const landmark of landmarks) {
          const issues = this.validateLandmark(landmark);
          
          if (issues.length > 0) {
            console.warn(`${landmark.label} at (${landmark.x}, ${landmark.y}):`);
            issues.forEach(issue => console.warn(`  - ${issue}`));
            violations += issues.length;
          }
        }
        
        if (violations === 0) {
          console.log(' All placements valid');
        } else {
          console.warn(` Found ${violations} placement issues`);
        }
        
        console.log('====================================');
        
        return violations === 0;
      },
      
      // Validate single landmark
      validateLandmark(landmark) {
        const issues = [];
        const rules = ENHANCED_LANDMARK_RULES[landmark.type.id];
        
        if (!rules) return issues;
        
        const density = landmark.density || 'none';
        const biome = landmark.biome;
        const onRoad = landmark.onRoad || false;
        
        // Check density rules
        if (rules.avoidDensity && rules.avoidDensity.includes(density)) {
          issues.push(`In avoided density zone: ${density}`);
        }
        
        // Check biome rules (from Phase 7.4C)
        const landmarkType = landmark.type;
        if (landmarkType.forbiddenBiomes && landmarkType.forbiddenBiomes.includes(biome)) {
          issues.push(`In forbidden biome: ${biome}`);
        }
        
        // Check road rules
        if (rules.avoidRoads && onRoad) {
          issues.push('Should not be on road');
        }
        
        if (rules.preferRoads && !onRoad) {
          // This is just a preference, not a hard rule
          // issues.push('Prefers road access (soft rule)');
        }
        
        return issues;
      },
      
      // Check for overlaps
      checkOverlaps(landmarks) {
        const positions = new Map();
        const overlaps = [];
        
        for (const landmark of landmarks) {
          const key = `${landmark.x},${landmark.y}`;
          
          if (positions.has(key)) {
            overlaps.push({
              position: key,
              landmarks: [positions.get(key), landmark.label]
            });
          } else {
            positions.set(key, landmark.label);
          }
        }
        
        if (overlaps.length > 0) {
          console.error('=== Overlap Detection ===');
          overlaps.forEach(overlap => {
            console.error(`Position ${overlap.position}: ${overlap.landmarks.join(' + ')}`);
          });
          console.error('========================');
        }
        
        return overlaps.length === 0;
      },
      
      // Generate placement report
      generatePlacementReport(landmarks) {
        console.log('=== Landmark Placement Report ===');
        
        const byBiome = {};
        const byDensity = {};
        const onRoads = [];
        
        for (const landmark of landmarks) {
          // By biome
          byBiome[landmark.biome] = byBiome[landmark.biome] || [];
          byBiome[landmark.biome].push(landmark.label);
          
          // By density
          const density = landmark.density || 'none';
          byDensity[density] = byDensity[density] || [];
          byDensity[density].push(landmark.label);
          
          // On roads
          if (landmark.onRoad) {
            onRoads.push(landmark.label);
          }
        }
        
        console.log('\nBy Biome:');
        for (const [biome, marks] of Object.entries(byBiome)) {
          console.log(`  ${biome}: ${marks.join(', ')}`);
        }
        
        console.log('\nBy Density:');
        for (const [density, marks] of Object.entries(byDensity)) {
          console.log(`  ${density}: ${marks.join(', ')}`);
        }
        
        console.log('\nOn Roads:', onRoads.length > 0 ? onRoads.join(', ') : 'None');
        
        console.log('================================');
      }
    };

    // Update Phase 7.4C initialization to use enhanced placement
    function initEnhancedProceduralLandmarks() {
      console.log('=== PHASE 7.6: Enhanced Procedural Landmarks ===');
      
      // Check if map exists
      if (!GameState.map.grid) {
        console.error('Cannot place landmarks - map not generated');
        return;
      }
      
      // Check if landmarks already placed (preserve existing accounts)
      if (GameState.mapIcons && GameState.mapIcons.length > 0) {
        const firstIcon = GameState.mapIcons[0];
        
        // Check if this is a fresh generation or existing placement
        if (firstIcon.type === 'safeHouse' && GameState.mapIcons.length === 10) {
          console.log('Landmarks already placed - preserving existing layout');
          
          // Validate existing placements
          const landmarks = GameState.mapIcons.map(icon => {
            const gridX = Math.floor((icon.x / 100) * GameState.map.width);
            const gridY = Math.floor((icon.y / 100) * GameState.map.height);
            const tile = TileGridGenerator.getTile(GameState.map.grid, gridX, gridY);
            
            return {
              type: Object.values(LANDMARK_TYPES).find(lt => lt.id === icon.type),
              x: gridX,
              y: gridY,
              biome: tile ? tile.biome : 'unknown',
              density: tile ? (tile.metadata.buildingDensity || 'none') : 'none',
              onRoad: tile ? (tile.metadata.isRoad || false) : false,
              label: icon.label
            };
          });
          
          LandmarkPlacementValidator.validateAllPlacements(landmarks);
          LandmarkPlacementValidator.generatePlacementReport(landmarks);
          
          return;
        }
      }
      
      // New account or regeneration - use enhanced placement
      console.log('Generating fresh landmark placements...');
      
      // Get seeded random
      const random = MapSeedManager.createMapRandom();
      
      // Place landmarks with enhanced scoring
      const proceduralLandmarks = EnhancedLandmarkPlacer.placeAllLandmarksEnhanced(GameState.map.grid, random);
      
      // Validate placements
      LandmarkPlacementValidator.validateAllPlacements(proceduralLandmarks);
      LandmarkPlacementValidator.checkOverlaps(proceduralLandmarks);
      LandmarkPlacementValidator.generatePlacementReport(proceduralLandmarks);
      
      // Convert to legacy mapIcons format
      const mapIcons = LandmarkConverter.convertToMapIcons(
        proceduralLandmarks, 
        GameState.map.width, 
        GameState.map.height
      );
      
      // Update GameState
      GameState.mapIcons = mapIcons;
      
      // Set character at safe house
      LandmarkConverter.setCharacterAtSafeHouse(
        proceduralLandmarks,
        GameState.map.width,
        GameState.map.height
      );
      
      // Save to localStorage
      Storage.save();
      
      console.log(`Placed ${mapIcons.length} enhanced landmarks`);
      console.log('===============================================');
    }

    // Debug utilities
    window.validateLandmarkPlacements = function() {
      if (!GameState.mapIcons || !GameState.map.grid) {
        console.log('No landmarks or map to validate');
        return;
      }
      
      const landmarks = GameState.mapIcons.map(icon => {
        const gridX = Math.floor((icon.x / 100) * GameState.map.width);
        const gridY = Math.floor((icon.y / 100) * GameState.map.height);
        const tile = TileGridGenerator.getTile(GameState.map.grid, gridX, gridY);
        
        return {
          type: Object.values(LANDMARK_TYPES).find(lt => lt.id === icon.type),
          x: gridX,
          y: gridY,
          biome: tile ? tile.biome : 'unknown',
          density: tile ? (tile.metadata.buildingDensity || 'none') : 'none',
          onRoad: tile ? (tile.metadata.isRoad || false) : false,
          label: icon.label
        };
      });
      
      LandmarkPlacementValidator.validateAllPlacements(landmarks);
      LandmarkPlacementValidator.checkOverlaps(landmarks);
    };

    window.showLandmarkReport = function() {
      if (!GameState.mapIcons || !GameState.map.grid) {
        console.log('No landmarks or map');
        return;
      }
      
      const landmarks = GameState.mapIcons.map(icon => {
        const gridX = Math.floor((icon.x / 100) * GameState.map.width);
        const gridY = Math.floor((icon.y / 100) * GameState.map.height);
        const tile = TileGridGenerator.getTile(GameState.map.grid, gridX, gridY);
        
        return {
          type: Object.values(LANDMARK_TYPES).find(lt => lt.id === icon.type),
          x: gridX,
          y: gridY,
          biome: tile ? tile.biome : 'unknown',
          density: tile ? (tile.metadata.buildingDensity || 'none') : 'none',
          onRoad: tile ? (tile.metadata.isRoad || false) : false,
          label: icon.label
        };
      });
      
      LandmarkPlacementValidator.generatePlacementReport(landmarks);
    };

    window.regenerateLandmarks = function() {
      console.log('Regenerating landmarks...');
      GameState.mapIcons = [];
      initEnhancedProceduralLandmarks();
      console.log('Landmarks regenerated. Refresh Turf tab to see changes.');
    };

    // ========================================
    // PHASE 7.7: BIOME GAMEPLAY MODIFIERS
    // ========================================

    // Comprehensive biome modifier system
    const BIOME_MODIFIERS = {
      urban: {
        id: 'urban',
        name: 'Urban',
        icon: '',
        
        // Crime modifiers
        crimeSuccess: 0.85,        // -15% success (crowded, witnesses)
        heatGain: 1.4,             // +40% heat (more cameras, witnesses)
        rewardMultiplier: 1.5,     // +50% rewards (wealthy targets)
        
        // Police response
        policeResponse: 'fast',    // 20-30 second response
        detectionChance: 0.35,     // 35% chance to be detected
        escapeMultiplier: 0.9,     // -10% escape (traffic, crowded)
        
        // Special modifiers
        witnessDensity: 'high',    // Many potential witnesses
        camerasCoverage: 'extensive', // Heavy surveillance
        gangTerritory: true,       // Gang wars common
        
        // Stat effectiveness
        statScaling: {
          strength: 0.8,           // Less useful (crowded, can't intimidate)
          intelligence: 1.3,       // Very useful (planning critical)
          charisma: 1.1            // Useful (blend in crowds)
        },
        
        description: 'High risk, high reward. Heavy police presence and surveillance. Planning is critical.',
        
        // Time-of-day modifiers (future expansion)
        timeModifiers: {
          day: { crimeSuccess: 0.8, heatGain: 1.6 },    // Harder during day
          night: { crimeSuccess: 1.0, heatGain: 1.2 }   // Easier at night
        }
      },
      
      suburban: {
        id: 'suburban',
        name: 'Suburban',
        icon: '',
        
        // Crime modifiers
        crimeSuccess: 1.0,         // Normal (baseline)
        heatGain: 1.0,             // Normal heat gain
        rewardMultiplier: 1.0,     // Normal rewards
        
        // Police response
        policeResponse: 'medium',  // 40-60 second response
        detectionChance: 0.20,     // 20% detection chance
        escapeMultiplier: 1.0,     // Normal escape
        
        // Special modifiers
        witnessDensity: 'medium',  // Moderate witnesses
        camerasCoverage: 'light',  // Some home cameras
        gangTerritory: false,      // Relatively safe from gangs
        
        // Stat effectiveness
        statScaling: {
          strength: 1.0,           // Normal effectiveness
          intelligence: 1.0,       // Normal effectiveness
          charisma: 1.2            // More useful (talking to neighbors)
        },
        
        description: 'Balanced zone. Moderate risk and rewards. Good for beginners.',
        
        timeModifiers: {
          day: { crimeSuccess: 0.9, heatGain: 1.2 },    // Neighbors home
          night: { crimeSuccess: 1.1, heatGain: 0.9 }   // Quieter
        }
      },
      
      industrial: {
        id: 'industrial',
        name: 'Industrial',
        icon: '',
        
        // Crime modifiers
        crimeSuccess: 1.15,        // +15% success (fewer witnesses)
        heatGain: 0.8,             // -20% heat (less police patrols)
        rewardMultiplier: 1.2,     // +20% rewards (valuable cargo)
        
        // Police response
        policeResponse: 'slow',    // 60-90 second response
        detectionChance: 0.15,     // 15% detection chance
        escapeMultiplier: 1.2,     // +20% escape (open spaces, loading docks)
        
        // Special modifiers
        witnessDensity: 'low',     // Few witnesses (workers only)
        camerasCoverage: 'moderate', // Security cameras at warehouses
        gangTerritory: true,       // Gang hideouts common
        
        // Stat effectiveness
        statScaling: {
          strength: 1.3,           // Very useful (intimidation, cargo)
          intelligence: 1.1,       // Useful (security systems)
          charisma: 0.8            // Less useful (fewer people)
        },
        
        description: 'Good for experienced criminals. Lower police presence, higher escape chance. Watch for gangs.',
        
        timeModifiers: {
          day: { crimeSuccess: 1.0, heatGain: 0.9 },    // Workers present
          night: { crimeSuccess: 1.3, heatGain: 0.7 }   // Empty, ideal
        }
      },
      
      coastal: {
        id: 'coastal',
        name: 'Beach/Coastal',
        icon: '',
        
        // Crime modifiers
        crimeSuccess: 0.9,         // -10% success (tourists, open space)
        heatGain: 1.2,             // +20% heat (tourists report)
        rewardMultiplier: 0.8,     // -20% rewards (fewer valuables)
        
        // Police response
        policeResponse: 'medium',  // 30-50 second response (tourist area)
        detectionChance: 0.25,     // 25% detection chance
        escapeMultiplier: 1.1,     // +10% escape (boats, open areas)
        
        // Special modifiers
        witnessDensity: 'medium',  // Tourists, beachgoers
        camerasCoverage: 'light',  // Limited cameras
        gangTerritory: false,      // Not gang territory
        
        // Stat effectiveness
        statScaling: {
          strength: 0.9,           // Slightly less useful
          intelligence: 1.0,       // Normal
          charisma: 1.3            // Very useful (tourists, scams)
        },
        
        description: 'Tourist area. Lower rewards but unique escape routes. Charisma-based crimes work well.',
        
        timeModifiers: {
          day: { crimeSuccess: 0.8, heatGain: 1.4 },    // Crowded with tourists
          night: { crimeSuccess: 1.0, heatGain: 1.0 }   // Empty beach
        }
      },
      
      rural: {
        id: 'rural',
        name: 'Rural',
        icon: '',
        
        // Crime modifiers
        crimeSuccess: 1.25,        // +25% success (isolated, no witnesses)
        heatGain: 0.6,             // -40% heat (slow police response)
        rewardMultiplier: 0.5,     // -50% rewards (poor area)
        
        // Police response
        policeResponse: 'very_slow', // 90-120 second response
        detectionChance: 0.05,     // 5% detection chance
        escapeMultiplier: 1.4,     // +40% escape (open roads, hideouts)
        
        // Special modifiers
        witnessDensity: 'none',    // Almost no witnesses
        camerasCoverage: 'none',   // No surveillance
        gangTerritory: false,      // No gang presence
        
        // Stat effectiveness
        statScaling: {
          strength: 1.2,           // Useful (intimidation works)
          intelligence: 0.9,       // Less useful (simple targets)
          charisma: 0.7            // Not very useful (few people)
        },
        
        description: 'Low risk, low reward. Perfect for laying low. Very slow police response.',
        
        timeModifiers: {
          day: { crimeSuccess: 1.2, heatGain: 0.7 },    // Still isolated
          night: { crimeSuccess: 1.3, heatGain: 0.5 }   // Completely isolated
        }
      }
    };

    // Biome Modifier Calculator
    const BiomeModifierCalculator = {
      // Get all modifiers for current player position
      getCurrentBiomeModifiers() {
        const pos = GameState.character.position;
        return this.getBiomeModifiersAt(pos.x, pos.y);
      },
      
      // Get modifiers for specific position
      getBiomeModifiersAt(xPercent, yPercent) {
        if (!GameState.map.grid) {
          return BIOME_MODIFIERS.suburban; // Safe default
        }
        
        const gridX = Math.floor((xPercent / 100) * GameState.map.width);
        const gridY = Math.floor((yPercent / 100) * GameState.map.height);
        const tile = TileGridGenerator.getTile(GameState.map.grid, gridX, gridY);
        
        if (!tile) {
          return BIOME_MODIFIERS.suburban;
        }
        
        return BIOME_MODIFIERS[tile.biome] || BIOME_MODIFIERS.suburban;
      },
      
      // Calculate final crime success chance with all modifiers
      calculateCrimeSuccess(baseCrime, playerStats, position) {
        let successChance = baseCrime.baseSuccessChance || 0.7;
        
        // 1. Biome modifier
        const biomeModifiers = this.getBiomeModifiersAt(position.x, position.y);
        successChance *= biomeModifiers.crimeSuccess;
        
        // 2. Player stat bonuses (scaled by biome)
        for (const [stat, value] of Object.entries(playerStats)) {
          const statBonus = value * 0.02; // 2% per stat point
          const biomeScaling = biomeModifiers.statScaling[stat] || 1.0;
          successChance += (statBonus * biomeScaling);
        }
        
        // 3. Building density (from Phase 7.5)
        const densityModifier = ZoneAnalytics.getCrimeDifficultyModifier(position.x, position.y);
        successChance /= densityModifier;
        
        // 4. Road bonus (from Phase 7.5)
        const escapeModifier = ZoneAnalytics.getEscapeModifier(position.x, position.y);
        successChance *= Math.sqrt(escapeModifier); // Partial effect
        
        // 5. Fatigue penalty
        const fatiguePenalty = FatigueSystem.getSuccessPenalty();
        successChance -= fatiguePenalty;
        
        // 6. Suspicion penalty
        const suspicion = GameState.player.suspicion || 0;
        const suspicionPenalty = (suspicion / 100) * 0.15; // Up to -15%
        successChance -= suspicionPenalty;
        
        // Clamp
        return Math.max(0.05, Math.min(0.95, successChance));
      },
      
      // Calculate heat gain with biome modifiers
      calculateHeatGain(baseHeat, position) {
        let heatGain = baseHeat;
        
        // 1. Biome modifier
        const biomeModifiers = this.getBiomeModifiersAt(position.x, position.y);
        heatGain *= biomeModifiers.heatGain;
        
        // 2. Building density (from Phase 7.5)
        const gridX = Math.floor((position.x / 100) * GameState.map.width);
        const gridY = Math.floor((position.y / 100) * GameState.map.height);
        const tile = TileGridGenerator.getTile(GameState.map.grid, gridX, gridY);
        
        if (tile) {
          const buildingCount = tile.metadata.buildingCount || 0;
          const densityMultiplier = 1 + (buildingCount / 30); // Up to +67% in extreme density
          heatGain *= densityMultiplier;
        }
        
        // 3. Detection chance (random)
        if (Math.random() < biomeModifiers.detectionChance) {
          heatGain *= 1.5; // +50% if detected
          console.log(' DETECTED! Heat increased');
        }
        
        return heatGain;
      },
      
      // Calculate reward with biome modifiers
      calculateReward(baseReward, position) {
        let reward = baseReward;
        
        // 1. Biome modifier
        const biomeModifiers = this.getBiomeModifiersAt(position.x, position.y);
        reward *= biomeModifiers.rewardMultiplier;
        
        // 2. Building density (from Phase 7.5)
        const zoneReward = ZoneAnalytics.getRewardModifier(position.x, position.y);
        reward *= zoneReward;
        
        return Math.floor(reward);
      },
      
      // Get police response time in milliseconds
      getPoliceResponseTime(position) {
        const biomeModifiers = this.getBiomeModifiersAt(position.x, position.y);
        
        const responseTimes = {
          fast: { min: 20000, max: 30000 },        // 20-30s
          medium: { min: 40000, max: 60000 },      // 40-60s
          slow: { min: 60000, max: 90000 },        // 60-90s
          very_slow: { min: 90000, max: 120000 }   // 90-120s
        };
        
        const timeRange = responseTimes[biomeModifiers.policeResponse] || responseTimes.medium;
        return timeRange.min + Math.random() * (timeRange.max - timeRange.min);
      }
    };

    // Biome Comparison Tool
    const BiomeComparisonTool = {
      // Compare all biomes for a specific crime type
      compareBiomesForCrime(crimeType, playerStats) {
        console.log(`=== Biome Comparison for ${crimeType} ===`);
        console.log('Player Stats:', playerStats);
        console.log('');
        
        const results = [];
        
        for (const [biomeId, biome] of Object.entries(BIOME_MODIFIERS)) {
          // Mock position in center of map for this biome
          const mockPos = { x: 50, y: 50 };
          
          // Calculate modifiers
          const baseCrime = { baseSuccessChance: 0.7 };
          const successChance = BiomeModifierCalculator.calculateCrimeSuccess(baseCrime, playerStats, mockPos);
          const heatGain = BiomeModifierCalculator.calculateHeatGain(10, mockPos);
          const reward = BiomeModifierCalculator.calculateReward(100, mockPos);
          
          results.push({
            biome: biome.name,
            icon: biome.icon,
            success: (successChance * 100).toFixed(1) + '%',
            heat: heatGain.toFixed(1),
            reward: '$' + reward,
            response: biome.policeResponse,
            rating: this.rateBiome(successChance, heatGain, reward)
          });
        }
        
        // Sort by rating
        results.sort((a, b) => b.rating - a.rating);
        
        // Display
        results.forEach((r, i) => {
          console.log(`${i + 1}. ${r.icon} ${r.biome}`);
          console.log(`   Success: ${r.success}, Heat: ${r.heat}, Reward: ${r.reward}`);
          console.log(`   Police: ${r.response}, Overall: ${r.rating.toFixed(1)}/10`);
          console.log('');
        });
        
        console.log('==========================================');
      },
      
      // Rate biome overall (0-10 scale)
      rateBiome(success, heat, reward) {
        const successScore = success * 5; // 0-5 points
        const heatScore = (1 - (heat / 20)) * 2; // 0-2 points (lower is better)
        const rewardScore = (reward / 100) * 3; // 0-3 points
        
        return successScore + heatScore + rewardScore;
      },
      
      // Generate biome modifier table
      generateModifierTable() {
        console.log('=== BIOME MODIFIER TABLE ===');
        console.log('');
        console.log('Biome         | Success | Heat  | Reward | Police   | Detection');
        console.log('------------- | ------- | ----- | ------ | -------- | ---------');
        
        for (const biome of Object.values(BIOME_MODIFIERS)) {
          const success = (biome.crimeSuccess * 100).toFixed(0) + '%';
          const heat = (biome.heatGain * 100).toFixed(0) + '%';
          const reward = (biome.rewardMultiplier * 100).toFixed(0) + '%';
          const police = biome.policeResponse.padEnd(9);
          const detection = (biome.detectionChance * 100).toFixed(0) + '%';
          
          console.log(`${biome.icon} ${biome.name.padEnd(10)} | ${success.padEnd(7)} | ${heat.padEnd(5)} | ${reward.padEnd(6)} | ${police} | ${detection}`);
        }
        
        console.log('');
        console.log('============================');
      }
    };

    // Debug utilities
    window.showBiomeModifiers = function(biomeName) {
      const biome = Object.values(BIOME_MODIFIERS).find(b => 
        b.name.toLowerCase() === biomeName.toLowerCase() || b.id === biomeName
      );
      
      if (!biome) {
        console.log('Biome not found. Available:', Object.keys(BIOME_MODIFIERS).join(', '));
        return;
      }
      
      console.log(`=== ${biome.icon} ${biome.name} Biome ===`);
      console.log('');
      console.log('Crime Modifiers:');
      console.log('  Success Chance:', (biome.crimeSuccess * 100).toFixed(0) + '%');
      console.log('  Heat Gain:', (biome.heatGain * 100).toFixed(0) + '%');
      console.log('  Reward Multiplier:', (biome.rewardMultiplier * 100).toFixed(0) + '%');
      console.log('');
      console.log('Police Response:');
      console.log('  Speed:', biome.policeResponse);
      console.log('  Detection Chance:', (biome.detectionChance * 100).toFixed(0) + '%');
      console.log('  Escape Modifier:', (biome.escapeMultiplier * 100).toFixed(0) + '%');
      console.log('');
      console.log('Environment:');
      console.log('  Witnesses:', biome.witnessDensity);
      console.log('  Cameras:', biome.camerasCoverage);
      console.log('  Gang Territory:', biome.gangTerritory ? 'Yes' : 'No');
      console.log('');
      console.log('Stat Effectiveness:');
      console.log('  Strength:', (biome.statScaling.strength * 100).toFixed(0) + '%');
      console.log('  Intelligence:', (biome.statScaling.intelligence * 100).toFixed(0) + '%');
      console.log('  Charisma:', (biome.statScaling.charisma * 100).toFixed(0) + '%');
      console.log('');
      console.log('Description:', biome.description);
      console.log('===========================');
    };

    window.showCurrentBiomeModifiers = function() {
      const biomeModifiers = BiomeModifierCalculator.getCurrentBiomeModifiers();
      showBiomeModifiers(biomeModifiers.id);
      
      console.log('');
      console.log('Current Position Analysis:');
      const pos = GameState.character.position;
      console.log('  Zone:', ZoneAnalytics.getZoneDescription(pos.x, pos.y));
      console.log('  Crime Difficulty:', (ZoneAnalytics.getCrimeDifficultyModifier(pos.x, pos.y) * 100).toFixed(0) + '%');
      console.log('  Reward Potential:', (ZoneAnalytics.getRewardModifier(pos.x, pos.y) * 100).toFixed(0) + '%');
      console.log('  Escape Chance:', (ZoneAnalytics.getEscapeModifier(pos.x, pos.y) * 100).toFixed(0) + '%');
    };

    window.compareBiomes = function() {
      BiomeComparisonTool.compareBiomesForCrime('Generic Crime', GameState.player.stats);
    };

    window.showBiomeTable = function() {
      BiomeComparisonTool.generateModifierTable();
    };

    // ========================================
    // PHASE 7.8: NON-BINARY FAILURE SYSTEM
    // ========================================

    // Crime outcome system (replaces simple success/fail)
    const CRIME_OUTCOMES = {
      // Critical success (15% chance when succeeding)
      CRITICAL_SUCCESS: {
        id: 'critical_success',
        name: 'Critical Success',
        icon: '',
        tier: 5,
        
        cashMultiplier: 2.0,      // 200% base reward
        xpMultiplier: 1.5,        // 150% XP
        heatMultiplier: 0.5,      // 50% heat (clean job)
        
        reputationChange: 10,     // +10 reputation
        storyEventChance: 0.05,   // 5% chance of special event
        
        consequences: {
          type: 'positive',
          effects: ['witnessed_by_admirer', 'clean_getaway', 'legendary_score']
        },
        
        narratives: [
          "Perfect execution. Not a trace left behind. This job will be talked about for years.",
          "Everything went exactly as planned. You're a natural.",
          "The target never knew what hit them. Masterful work.",
          "Clean, professional, and profitable. This is what you were born to do."
        ]
      },
      
      // Standard success (60% chance when succeeding)
      SUCCESS: {
        id: 'success',
        name: 'Success',
        icon: '',
        tier: 4,
        
        cashMultiplier: 1.0,      // 100% base reward
        xpMultiplier: 1.0,        // 100% XP
        heatMultiplier: 1.0,      // Normal heat
        
        reputationChange: 2,      // +2 reputation
        storyEventChance: 0.01,   // 1% chance of event
        
        consequences: {
          type: 'neutral',
          effects: ['clean_escape', 'normal_operation']
        },
        
        narratives: [
          "You got away with the goods. Nothing fancy, but it worked.",
          "Job done. Time to lay low for a bit.",
          "Smooth operation. No complications.",
          "Another successful score under your belt."
        ]
      },
      
      // Messy success (25% chance when succeeding)
      MESSY_SUCCESS: {
        id: 'messy_success',
        name: 'Messy Success',
        icon: '',
        tier: 3,
        
        cashMultiplier: 0.7,      // 70% reward (lost/damaged goods)
        xpMultiplier: 0.8,        // 80% XP
        heatMultiplier: 1.5,      // 150% heat (witnesses, noise)
        
        reputationChange: -1,     // -1 reputation (sloppy work)
        storyEventChance: 0.08,   // 8% chance of complication
        
        consequences: {
          type: 'mixed',
          effects: ['left_evidence', 'witness_spotted_you', 'damaged_goods', 'noise_complaint']
        },
        
        narratives: [
          "You got the score, but it wasn't pretty. Someone definitely saw you.",
          "Things got messy. You made it out, but you left a trail.",
          "Success... technically. But this is going to come back to haunt you.",
          "You got paid, but at what cost? This one felt wrong."
        ]
      },
      
      // Partial failure (40% chance when failing)
      PARTIAL_FAILURE: {
        id: 'partial_failure',
        name: 'Partial Failure',
        icon: '',
        tier: 2,
        
        cashMultiplier: 0.3,      // 30% reward (grabbed something small)
        xpMultiplier: 0.5,        // 50% XP (learned something)
        heatMultiplier: 2.0,      // 200% heat (botched job)
        
        reputationChange: -5,     // -5 reputation (amateur hour)
        storyEventChance: 0.15,   // 15% chance of consequence
        
        consequences: {
          type: 'negative',
          effects: ['victim_fought_back', 'alarm_triggered', 'dropped_wallet', 'injury_minor']
        },
        
        narratives: [
          "You grabbed what you could and ran. The police are going to hear about this.",
          "Barely escaped. You got something, but it cost you.",
          "The target fought back harder than expected. You're bruised and the heat is on.",
          "Amateur mistake. You got away, but empty-handed isn't far from where you are."
        ]
      },
      
      // Complete failure (40% chance when failing)
      COMPLETE_FAILURE: {
        id: 'complete_failure',
        name: 'Complete Failure',
        icon: '',
        tier: 1,
        
        cashMultiplier: 0,        // No reward
        xpMultiplier: 0.2,        // 20% XP (learned from mistakes)
        heatMultiplier: 3.0,      // 300% heat (major incident)
        
        reputationChange: -10,    // -10 reputation (word spreads)
        storyEventChance: 0.25,   // 25% chance of major consequence
        
        consequences: {
          type: 'severe',
          effects: ['caught_on_camera', 'victim_injured', 'police_chase', 'bounty_posted']
        },
        
        narratives: [
          "Complete disaster. You barely made it out alive. Every cop in the city knows your face now.",
          "Everything that could go wrong, did. You're lucky to be breathing.",
          "Catastrophic failure. This is going to follow you for a long time.",
          "You weren't just unsuccessfulyou made everything worse. Lie low. Now."
        ]
      },
      
      // Catastrophic failure (20% chance when failing badly)
      CATASTROPHIC_FAILURE: {
        id: 'catastrophic_failure',
        name: 'Catastrophic Failure',
        icon: '',
        tier: 0,
        
        cashMultiplier: -0.2,     // Lose 20% of current cash (costs money)
        xpMultiplier: 0,          // No XP gain
        heatMultiplier: 5.0,      // 500% heat (manhunt level)
        
        reputationChange: -20,    // -20 reputation (pariah status)
        storyEventChance: 0.50,   // 50% chance of permanent consequence
        
        consequences: {
          type: 'catastrophic',
          effects: ['permanent_injury', 'gang_vendetta', 'federal_attention', 'safe_house_compromised']
        },
        
        narratives: [
          "You've made a terrible mistake. People died. The city wants your head.",
          "This isn't just a failed job. You've started a war you can't win.",
          "Everything is on fire. Your face is on every news channel. Run.",
          "You crossed a line you can't uncross. There's no coming back from this."
        ]
      }
    };

    // Long-term consequence system
    const ConsequenceSystem = {
      // Apply consequences to game state
      applyConsequences(outcome, crime, position) {
        const consequences = [];
        const effects = outcome.consequences.effects;
        
        // Roll for each possible effect
        for (const effect of effects) {
          if (Math.random() < 0.4) { // 40% chance per effect
            const consequence = this.triggerConsequence(effect, crime, position);
            if (consequence) {
              consequences.push(consequence);
            }
          }
        }
        
        // Check for story event
        if (Math.random() < outcome.storyEventChance) {
          const storyEvent = this.triggerStoryEvent(outcome, crime, position);
          if (storyEvent) {
            consequences.push(storyEvent);
          }
        }
        
        return consequences;
      },
      
      // Trigger individual consequence
      triggerConsequence(effectId, crime, position) {
        const effects = {
          // Positive effects
          witnessed_by_admirer: {
            type: 'positive',
            message: "Someone saw your work. They were impressed.",
            apply: () => {
              GameState.player.reputation += 5;
              console.log(' Witnessed by admirer: +5 reputation');
            }
          },
          
          clean_getaway: {
            type: 'positive',
            message: "No evidence left behind. The cops have nothing.",
            apply: () => {
              GameState.player.heat = Math.max(0, GameState.player.heat - 5);
              console.log(' Clean getaway: -5% heat');
            }
          },
          
          legendary_score: {
            type: 'positive',
            message: "This job is going to be legendary. Word is spreading.",
            apply: () => {
              GameState.player.reputation += 10;
              console.log(' Legendary score: +10 reputation');
            }
          },
          
          // Negative effects
          left_evidence: {
            type: 'negative',
            message: "You left something behind. Fingerprints? DNA? The cops have it.",
            apply: () => {
              GameState.player.heat += 10;
              GameState.player.suspicion = Math.min(100, GameState.player.suspicion + 15);
              console.log(' Left evidence: +10% heat, +15 suspicion');
            }
          },
          
          witness_spotted_you: {
            type: 'negative',
            message: "A witness got a good look at you. Descriptions are circulating.",
            apply: () => {
              GameState.player.heat += 8;
              GameState.player.suspicion = Math.min(100, GameState.player.suspicion + 10);
              console.log(' Witness: +8% heat, +10 suspicion');
            }
          },
          
          damaged_goods: {
            type: 'negative',
            message: "The merchandise got damaged in the chaos. Worth less now.",
            apply: () => {
              // Cash penalty already applied by outcome multiplier
              console.log(' Damaged goods: reduced reward');
            }
          },
          
          noise_complaint: {
            type: 'negative',
            message: "You made too much noise. Police got called to the area.",
            apply: () => {
              GameState.player.heat += 5;
              console.log(' Noise complaint: +5% heat');
            }
          },
          
          victim_fought_back: {
            type: 'negative',
            message: "The victim fought back. You're injured and they can identify you.",
            apply: () => {
              const cashLoss = Math.floor(Math.random() * 100) + 50;
              GameState.player.cash = Math.max(0, GameState.player.cash - cashLoss);
              GameState.player.heat += 12;
              console.log(` Victim fought back: -$${cashLoss}, +12% heat`);
            }
          },
          
          alarm_triggered: {
            type: 'negative',
            message: "Silent alarm tripped. Police response was immediate.",
            apply: () => {
              GameState.player.heat += 15;
              GameState.player.globalHeat = Math.min(100, GameState.player.globalHeat + 5);
              console.log(' Alarm: +15% heat, +5% global heat');
            }
          },
          
          dropped_wallet: {
            type: 'negative',
            message: "You dropped your wallet in the panic. They have your ID now.",
            apply: () => {
              GameState.player.heat += 20;
              GameState.player.suspicion = 100; // Fully identified
              console.log(' Dropped wallet: +20% heat, suspicion maxed');
            }
          },
          
          injury_minor: {
            type: 'negative',
            message: "You took a hit. Nothing serious, but you're bleeding.",
            apply: () => {
              const medicalCost = Math.floor(Math.random() * 150) + 100;
              GameState.player.cash = Math.max(0, GameState.player.cash - medicalCost);
              console.log(` Minor injury: -$${medicalCost} medical costs`);
            }
          },
          
          // Severe effects
          caught_on_camera: {
            type: 'severe',
            message: "Security cameras caught everything. Your face is on the news.",
            apply: () => {
              GameState.player.heat += 30;
              GameState.player.globalHeat = Math.min(100, GameState.player.globalHeat + 15);
              GameState.player.suspicion = 100;
              console.log(' Caught on camera: +30% heat, +15% global heat, identified');
            }
          },
          
          victim_injured: {
            type: 'severe',
            message: "The victim is in the hospital. This is now a felony investigation.",
            apply: () => {
              GameState.player.heat += 25;
              GameState.player.globalHeat = Math.min(100, GameState.player.globalHeat + 20);
              GameState.player.reputation -= 15;
              console.log(' Victim injured: +25% heat, +20% global heat, -15 rep');
            }
          },
          
          police_chase: {
            type: 'severe',
            message: "High-speed chase through the city. Every cop knows your description.",
            apply: () => {
              GameState.player.heat += 35;
              GameState.player.globalHeat = Math.min(100, GameState.player.globalHeat + 25);
              console.log(' Police chase: +35% heat, +25% global heat');
            }
          },
          
          bounty_posted: {
            type: 'severe',
            message: "There's a bounty on your head now. Rival gangs are hunting you.",
            apply: () => {
              GameState.player.bounty = (GameState.player.bounty || 0) + 5000;
              GameState.player.reputation -= 20;
              console.log(' Bounty posted: $5,000 on your head, -20 rep');
            }
          },
          
          // Catastrophic effects
          permanent_injury: {
            type: 'catastrophic',
            message: "You're hurt bad. This is going to affect you permanently.",
            apply: () => {
              // Permanent stat penalty
              const stat = ['strength', 'intelligence', 'charisma'][Math.floor(Math.random() * 3)];
              GameState.player.stats[stat] = Math.max(1, GameState.player.stats[stat] - 1);
              console.log(` Permanent injury: -1 ${stat}`);
            }
          },
          
          gang_vendetta: {
            type: 'catastrophic',
            message: "You crossed the wrong people. A gang has put a hit out on you.",
            apply: () => {
              GameState.player.vendetta = true;
              GameState.player.bounty = (GameState.player.bounty || 0) + 10000;
              console.log(' Gang vendetta: $10,000 bounty, permanent hostile status');
            }
          },
          
          federal_attention: {
            type: 'catastrophic',
            message: "The Feds are involved now. This is bigger than local police.",
            apply: () => {
              GameState.player.federalHeat = (GameState.player.federalHeat || 0) + 50;
              GameState.player.globalHeat = 100;
              console.log(' Federal attention: Federal heat activated, global heat maxed');
            }
          },
          
          safe_house_compromised: {
            type: 'catastrophic',
            message: "They found your safe house. You need to relocate immediately.",
            apply: () => {
              GameState.player.safeHouseCompromised = true;
              const relocateCost = 5000;
              GameState.player.cash = Math.max(0, GameState.player.cash - relocateCost);
              console.log(' Safe house compromised: -$5,000 relocation cost');
            }
          }
        };
        
        const effect = effects[effectId];
        if (effect) {
          effect.apply();
          return {
            id: effectId,
            type: effect.type,
            message: effect.message
          };
        }
        
        return null;
      },
      
      // Trigger rare story events
      triggerStoryEvent(outcome, crime, position) {
        const tier = outcome.tier;
        
        // Different events based on outcome tier
        const events = {
          5: [ // Critical success events
            {
              id: 'mysterious_offer',
              message: "A mysterious figure approaches with a job offer. This could change everything.",
              effect: () => console.log(' Story event unlocked: Mysterious Offer')
            },
            {
              id: 'gang_recruitment',
              message: "Your work caught the eye of a major gang. They want you in.",
              effect: () => console.log(' Story event unlocked: Gang Recruitment')
            }
          ],
          0: [ // Catastrophic failure events
            {
              id: 'witness_protection',
              message: "The victim is entering witness protection. The trial is coming.",
              effect: () => console.log(' Story event unlocked: The Trial')
            },
            {
              id: 'revenge_plot',
              message: "The victim's family is planning revenge. Watch your back.",
              effect: () => console.log(' Story event unlocked: Revenge')
            }
          ],
          2: [ // Partial failure events
            {
              id: 'informant_spotted',
              message: "Someone you know saw you fail. They might talk.",
              effect: () => console.log(' Story event unlocked: The Informant')
            }
          ]
        };
        
        const tierEvents = events[tier];
        if (tierEvents && tierEvents.length > 0) {
          const event = tierEvents[Math.floor(Math.random() * tierEvents.length)];
          event.effect();
          return {
            id: event.id,
            type: 'story',
            message: event.message
          };
        }
        
        return null;
      }
    };

    // Outcome Determiner
    const OutcomeDeterminer = {
      // Determine outcome based on success roll and modifiers
      determineOutcome(succeeded, successChance, crimeType, position) {
        if (succeeded) {
          // Success tier - determine quality
          const roll = Math.random();
          
          if (roll < 0.15) {
            return CRIME_OUTCOMES.CRITICAL_SUCCESS;
          } else if (roll < 0.75) {
            return CRIME_OUTCOMES.SUCCESS;
          } else {
            return CRIME_OUTCOMES.MESSY_SUCCESS;
          }
        } else {
          // Failure tier - determine severity
          const roll = Math.random();
          const failureMargin = 1.0 - successChance; // How badly did we miss?
          
          // Higher failure margin = worse outcome
          if (failureMargin > 0.7 && roll < 0.2) {
            return CRIME_OUTCOMES.CATASTROPHIC_FAILURE;
          } else if (roll < 0.4) {
            return CRIME_OUTCOMES.COMPLETE_FAILURE;
          } else {
            return CRIME_OUTCOMES.PARTIAL_FAILURE;
          }
        }
      },
      
      // Apply outcome to game state
      applyOutcome(outcome, baseCrime, position) {
        const result = {
          outcome: outcome.name,
          tier: outcome.tier,
          narrative: outcome.narratives[Math.floor(Math.random() * outcome.narratives.length)],
          consequences: []
        };
        
        // Calculate rewards
        const baseReward = (baseCrime.rewards?.cash?.min || 50) + 
                          Math.random() * ((baseCrime.rewards?.cash?.max || 150) - (baseCrime.rewards?.cash?.min || 50));
        
        const finalReward = BiomeModifierCalculator.calculateReward(
          baseReward * outcome.cashMultiplier,
          position
        );
        
        // Calculate XP
        const baseXP = 10 + Math.random() * 20;
        const finalXP = Math.floor(baseXP * outcome.xpMultiplier);
        
        // Calculate heat
        const baseHeat = 10;
        const finalHeat = BiomeModifierCalculator.calculateHeatGain(
          baseHeat * outcome.heatMultiplier,
          position
        );
        
        // Apply to game state
        GameState.player.cash = Math.max(0, GameState.player.cash + finalReward);
        GameState.player.xp += finalXP;
        GameState.player.heat = Math.min(100, GameState.player.heat + finalHeat);
        GameState.player.reputation += outcome.reputationChange;
        
        // Apply consequences
        result.consequences = ConsequenceSystem.applyConsequences(outcome, baseCrime, position);
        
        // Store result
        result.cash = finalReward;
        result.xp = finalXP;
        result.heat = finalHeat;
        result.reputation = outcome.reputationChange;
        
        return result;
      }
    };

    // Debug utilities
    window.testCrimeOutcomes = function(iterations = 100) {
      console.log('=== Testing Crime Outcomes ===');
      console.log(`Running ${iterations} simulations...`);
      console.log('');
      
      const results = {};
      for (const outcome of Object.values(CRIME_OUTCOMES)) {
        results[outcome.id] = 0;
      }
      
      for (let i = 0; i < iterations; i++) {
        const succeeded = Math.random() < 0.6; // 60% base success
        const outcome = OutcomeDeterminer.determineOutcome(succeeded, 0.6, 'test', {x: 50, y: 50});
        results[outcome.id]++;
      }
      
      console.log('Outcome Distribution:');
      for (const [id, count] of Object.entries(results)) {
        const pct = (count / iterations * 100).toFixed(1);
        const outcome = Object.values(CRIME_OUTCOMES).find(o => o.id === id);
        console.log(`${outcome.icon} ${outcome.name}: ${count} (${pct}%)`);
      }
      
      console.log('');
      console.log('============================');
    };

    window.showOutcomeDetails = function(outcomeName) {
      const outcome = Object.values(CRIME_OUTCOMES).find(o => 
        o.name.toLowerCase().includes(outcomeName.toLowerCase()) || o.id === outcomeName
      );
      
      if (!outcome) {
        console.log('Outcome not found. Available:', Object.values(CRIME_OUTCOMES).map(o => o.name).join(', '));
        return;
      }
      
      console.log(`=== ${outcome.icon} ${outcome.name} ===`);
      console.log('');
      console.log('Tier:', outcome.tier, '/ 5');
      console.log('');
      console.log('Rewards:');
      console.log('  Cash:', (outcome.cashMultiplier * 100).toFixed(0) + '%');
      console.log('  XP:', (outcome.xpMultiplier * 100).toFixed(0) + '%');
      console.log('  Heat:', (outcome.heatMultiplier * 100).toFixed(0) + '%');
      console.log('  Reputation:', outcome.reputationChange > 0 ? '+' + outcome.reputationChange : outcome.reputationChange);
      console.log('');
      console.log('Story Event Chance:', (outcome.storyEventChance * 100).toFixed(0) + '%');
      console.log('');
      console.log('Possible Effects:', outcome.consequences.effects.join(', '));
      console.log('');
      console.log('Example Narrative:');
      console.log('"' + outcome.narratives[0] + '"');
      console.log('');
      console.log('===========================');
    };

    // ========================================
    // CRIMES SYSTEM: Data Structure
    // ========================================
    const CrimesDatabase = {
      categories: {
        street: {
          id: 'street',
          name: 'Street Crimes',
          icon: '',
          description: 'Low-risk, low-reward crimes for quick cash',
          unlockLevel: 0
        },
        theft: {
          id: 'theft',
          name: 'Grand Theft',
          icon: '',
          description: 'Vehicle and property theft operations',
          unlockLevel: 3
        },
        organized: {
          id: 'organized',
          name: 'Organized Crime',
          icon: '',
          description: 'High-risk, high-reward coordinated operations',
          unlockLevel: 5
        },
        heists: {
          id: 'heists',
          name: 'Heists',
          icon: '',
          description: 'Complex multi-stage operations',
          unlockLevel: 8,
          comingSoon: true
        }
      },
      
      crimes: {
        // STREET CRIMES
        pickpocket: {
          id: 'pickpocket',
          category: 'street',
          name: 'Pickpocket',
          description: 'Steal from unsuspecting pedestrians',
          icon: '',
          riskLevel: 'low',
          baseSuccessChance: 0.75,
          rewards: {
            cash: { min: 50, max: 150 },
            xp: { min: 5, max: 15 },
            reputation: { min: 1, max: 3 }
          },
          costs: {
            heatGain: { min: 2, max: 5 },
            fatigueCost: 8,
            cooldown: 30000 // 30 seconds
          },
          requirements: {
            minLevel: 0,
            stats: { charisma: 0 }
          },
          statModifiers: {
            charisma: 0.15,  // +15% per point above min
            intelligence: 0.05
          },
          outcomes: {
            critical_success: {
              probability: 0.15,
              cashMultiplier: 2.0,
              xpMultiplier: 1.5,
              heatMultiplier: 0.5,
              message: 'Perfect execution! Grabbed a fat wallet without anyone noticing.'
            },
            success: {
              probability: 0.60,
              cashMultiplier: 1.0,
              xpMultiplier: 1.0,
              heatMultiplier: 1.0,
              message: 'Clean snatch. Got away unnoticed.'
            },
            partial_failure: {
              probability: 0.20,
              cashMultiplier: 0.3,
              xpMultiplier: 0.5,
              heatMultiplier: 1.5,
              message: 'Target noticed, but you grabbed something small and ran.'
            },
            failure: {
              probability: 0.05,
              cashMultiplier: 0,
              xpMultiplier: 0,
              heatMultiplier: 2.0,
              injuryChance: 0.1,
              message: 'Caught red-handed! Had to bolt before getting anything.'
            }
          }
        },
        
        mugging: {
          id: 'mugging',
          category: 'street',
          name: 'Mugging',
          description: 'Forcefully rob someone in an alley',
          icon: '',
          riskLevel: 'medium',
          baseSuccessChance: 0.65,
          rewards: {
            cash: { min: 100, max: 300 },
            xp: { min: 10, max: 25 },
            reputation: { min: 2, max: 5 }
          },
          costs: {
            heatGain: { min: 5, max: 12 },
            fatigueCost: 12,
            cooldown: 60000 // 1 minute
          },
          requirements: {
            minLevel: 1,
            stats: { strength: 3 }
          },
          statModifiers: {
            strength: 0.12,
            charisma: 0.08
          },
          outcomes: {
            critical_success: {
              probability: 0.10,
              cashMultiplier: 2.5,
              xpMultiplier: 2.0,
              heatMultiplier: 0.7,
              message: 'Victim too scared to resist. Big score!'
            },
            success: {
              probability: 0.55,
              cashMultiplier: 1.0,
              xpMultiplier: 1.0,
              heatMultiplier: 1.0,
              message: 'Quick and efficient. Victim handed over the goods.'
            },
            partial_failure: {
              probability: 0.25,
              cashMultiplier: 0.4,
              xpMultiplier: 0.3,
              heatMultiplier: 1.8,
              injuryChance: 0.2,
              message: 'Victim fought back. Got something but took a hit.'
            },
            failure: {
              probability: 0.10,
              cashMultiplier: 0,
              xpMultiplier: 0,
              heatMultiplier: 3.0,
              injuryChance: 0.4,
              message: 'Target turned out to be armed! Had to run for your life.'
            }
          }
        },
        
        dealerRobbery: {
          id: 'dealerRobbery',
          category: 'street',
          name: 'Rob Drug Dealer',
          description: 'Steal cash and product from a street dealer',
          icon: '',
          riskLevel: 'high',
          baseSuccessChance: 0.55,
          rewards: {
            cash: { min: 200, max: 500 },
            xp: { min: 20, max: 40 },
            reputation: { min: 5, max: 10 }
          },
          costs: {
            heatGain: { min: 10, max: 20 },
            fatigueCost: 18,
            cooldown: 120000 // 2 minutes
          },
          requirements: {
            minLevel: 2,
            stats: { strength: 5, intelligence: 3 }
          },
          statModifiers: {
            strength: 0.10,
            intelligence: 0.12,
            charisma: 0.05
          },
          outcomes: {
            critical_success: {
              probability: 0.08,
              cashMultiplier: 3.0,
              xpMultiplier: 2.5,
              heatMultiplier: 0.8,
              message: 'Dealer was holding serious weight. Massive score!'
            },
            success: {
              probability: 0.47,
              cashMultiplier: 1.0,
              xpMultiplier: 1.0,
              heatMultiplier: 1.0,
              message: 'Took the stash and cash. Dealer won\'t report it.'
            },
            partial_failure: {
              probability: 0.30,
              cashMultiplier: 0.5,
              xpMultiplier: 0.4,
              heatMultiplier: 2.0,
              injuryChance: 0.3,
              message: 'Backup showed up. Grabbed what you could and fought your way out.'
            },
            failure: {
              probability: 0.15,
              cashMultiplier: 0,
              xpMultiplier: 0,
              heatMultiplier: 4.0,
              injuryChance: 0.6,
              gangHeatGain: 15,
              message: 'Wrong dealer. His crew is now hunting you.'
            }
          }
        },
        
        // GRAND THEFT
        carTheft: {
          id: 'carTheft',
          category: 'theft',
          name: 'Steal Car',
          description: 'Hotwire and boost a parked vehicle',
          icon: '',
          riskLevel: 'medium',
          baseSuccessChance: 0.70,
          rewards: {
            cash: { min: 300, max: 800 },
            xp: { min: 15, max: 35 },
            reputation: { min: 3, max: 8 }
          },
          costs: {
            heatGain: { min: 8, max: 15 },
            fatigueCost: 15,
            cooldown: 90000 // 1.5 minutes
          },
          requirements: {
            minLevel: 3,
            stats: { intelligence: 5 }
          },
          statModifiers: {
            intelligence: 0.15,
            strength: 0.05
          },
          outcomes: {
            critical_success: {
              probability: 0.12,
              cashMultiplier: 2.5,
              xpMultiplier: 2.0,
              heatMultiplier: 0.6,
              message: 'High-end luxury car! Chop shop paid premium.'
            },
            success: {
              probability: 0.58,
              cashMultiplier: 1.0,
              xpMultiplier: 1.0,
              heatMultiplier: 1.0,
              message: 'Smooth boost. Car delivered to fence.'
            },
            partial_failure: {
              probability: 0.22,
              cashMultiplier: 0.4,
              xpMultiplier: 0.6,
              heatMultiplier: 2.0,
              message: 'Alarm went off. Ditched the car but got partial payment.'
            },
            failure: {
              probability: 0.08,
              cashMultiplier: 0,
              xpMultiplier: 0,
              heatMultiplier: 3.5,
              injuryChance: 0.2,
              message: 'Owner had GPS tracker. Cops almost caught you.'
            }
          }
        },
        
        stealJunker: {
          id: 'stealJunker',
          category: 'theft',
          name: 'Steal Junker',
          description: 'Boost an old beat-up car. Low risk, low reward.',
          icon: '',
          riskLevel: 'low',
          vehicleTier: 'junker',
          baseSuccessChance: 0.80,
          rewards: {
            cash: { min: 200, max: 400 },
            xp: { min: 10, max: 20 },
            reputation: { min: 1, max: 3 }
          },
          costs: {
            heatGain: { min: 3, max: 8 },
            fatigueCost: 10,
            cooldown: 45000 // 45 seconds
          },
          requirements: {
            minLevel: 2,
            stats: { intelligence: 3 }
          },
          statModifiers: {
            intelligence: 0.12,
            strength: 0.08
          },
          specialEvents: {
            cleanGetaway: {
              probability: 0.25,
              cashBonus: 100,
              heatReduction: 2,
              message: ' Clean getaway! Nobody even noticed.',
              canStore: true
            },
            policeChase: {
              probability: 0.08,
              heatIncrease: 10,
              injuryChance: 0.15,
              message: ' Patrol car spotted you! High-speed chase ensued.',
              canStore: false
            }
          },
          outcomes: {
            critical_success: {
              probability: 0.15,
              cashMultiplier: 1.8,
              xpMultiplier: 1.5,
              heatMultiplier: 0.4,
              canStore: true,
              message: 'Found cash in the glove box! Easy score.'
            },
            success: {
              probability: 0.65,
              cashMultiplier: 1.0,
              xpMultiplier: 1.0,
              heatMultiplier: 1.0,
              canStore: true,
              message: 'Old beater delivered. Quick flip to the chop shop.'
            },
            partial_failure: {
              probability: 0.15,
              cashMultiplier: 0.5,
              xpMultiplier: 0.6,
              heatMultiplier: 1.5,
              canStore: false,
              message: 'Car died mid-boost. Stripped it for parts.'
            },
            failure: {
              probability: 0.05,
              cashMultiplier: 0,
              xpMultiplier: 0,
              heatMultiplier: 2.5,
              injuryChance: 0.1,
              canStore: false,
              message: 'Alarm system was upgraded. Had to abandon it.'
            }
          }
        },
        
        stealSedan: {
          id: 'stealSedan',
          category: 'theft',
          name: 'Steal Sedan',
          description: 'Boost a modern sedan. Balanced risk and reward.',
          icon: '',
          riskLevel: 'medium',
          vehicleTier: 'sedan',
          baseSuccessChance: 0.70,
          rewards: {
            cash: { min: 500, max: 1000 },
            xp: { min: 20, max: 40 },
            reputation: { min: 4, max: 8 }
          },
          costs: {
            heatGain: { min: 8, max: 15 },
            fatigueCost: 15,
            cooldown: 90000 // 1.5 minutes
          },
          requirements: {
            minLevel: 3,
            stats: { intelligence: 5 }
          },
          statModifiers: {
            intelligence: 0.15,
            strength: 0.05
          },
          specialEvents: {
            cleanGetaway: {
              probability: 0.18,
              cashBonus: 200,
              heatReduction: 3,
              message: ' Slick job! No witnesses, no trace.',
              canStore: true
            },
            policeChase: {
              probability: 0.12,
              heatIncrease: 15,
              injuryChance: 0.25,
              message: ' Cops on your tail! Intense pursuit through downtown.',
              canStore: false
            },
            botchedTheft: {
              probability: 0.10,
              cashPenalty: 150,
              heatIncrease: 8,
              message: ' Broke the ignition. Had to ditch and run.',
              canStore: false
            }
          },
          outcomes: {
            critical_success: {
              probability: 0.12,
              cashMultiplier: 2.2,
              xpMultiplier: 2.0,
              heatMultiplier: 0.5,
              canStore: true,
              message: 'Pristine condition! Buyer paid top dollar.'
            },
            success: {
              probability: 0.58,
              cashMultiplier: 1.0,
              xpMultiplier: 1.0,
              heatMultiplier: 1.0,
              canStore: true,
              message: 'Clean boost. Delivered to the fence without issues.'
            },
            partial_failure: {
              probability: 0.22,
              cashMultiplier: 0.4,
              xpMultiplier: 0.6,
              heatMultiplier: 1.8,
              canStore: false,
              message: 'Security was tighter than expected. Got spooked and bailed early.'
            },
            failure: {
              probability: 0.08,
              cashMultiplier: 0,
              xpMultiplier: 0,
              heatMultiplier: 3.0,
              injuryChance: 0.2,
              canStore: false,
              message: 'LoJack system activated! Barely escaped the cops.'
            }
          }
        },
        
        stealLuxury: {
          id: 'stealLuxury',
          category: 'theft',
          name: 'Steal Luxury Car',
          description: 'High-end vehicle theft. Big rewards, big risks.',
          icon: '',
          riskLevel: 'high',
          vehicleTier: 'luxury',
          baseSuccessChance: 0.55,
          rewards: {
            cash: { min: 1500, max: 3000 },
            xp: { min: 40, max: 80 },
            reputation: { min: 10, max: 20 }
          },
          costs: {
            heatGain: { min: 15, max: 30 },
            fatigueCost: 25,
            cooldown: 180000 // 3 minutes
          },
          requirements: {
            minLevel: 5,
            stats: { intelligence: 8, strength: 5 }
          },
          statModifiers: {
            intelligence: 0.18,
            strength: 0.08,
            charisma: 0.06
          },
          specialEvents: {
            cleanGetaway: {
              probability: 0.12,
              cashBonus: 500,
              heatReduction: 5,
              repBonus: 5,
              message: ' Masterful execution! VIP buyer already waiting.',
              canStore: true
            },
            policeChase: {
              probability: 0.20,
              heatIncrease: 25,
              injuryChance: 0.35,
              globalHeatGain: 10,
              message: ' High-speed pursuit! Multiple units responding!',
              canStore: false
            },
            botchedTheft: {
              probability: 0.15,
              cashPenalty: 300,
              heatIncrease: 12,
              message: ' Advanced security system. Barely escaped.',
              canStore: false
            },
            ownerConfrontation: {
              probability: 0.08,
              injuryChance: 0.40,
              heatIncrease: 18,
              message: ' Owner caught you! Had to fight your way out.',
              canStore: false
            }
          },
          outcomes: {
            critical_success: {
              probability: 0.08,
              cashMultiplier: 2.5,
              xpMultiplier: 2.5,
              heatMultiplier: 0.6,
              canStore: true,
              message: 'Mint condition luxury vehicle! Collector paid premium.'
            },
            success: {
              probability: 0.47,
              cashMultiplier: 1.0,
              xpMultiplier: 1.0,
              heatMultiplier: 1.0,
              canStore: true,
              message: 'Smooth operation. High-end buyer secured.'
            },
            partial_failure: {
              probability: 0.30,
              cashMultiplier: 0.35,
              xpMultiplier: 0.5,
              heatMultiplier: 2.0,
              injuryChance: 0.2,
              canStore: false,
              message: 'Security arrived. Grabbed what you could and ran.'
            },
            failure: {
              probability: 0.15,
              cashMultiplier: 0,
              xpMultiplier: 0,
              heatMultiplier: 4.0,
              injuryChance: 0.4,
              globalHeatGain: 15,
              canStore: false,
              message: 'High-tech security and armed response. Complete failure.'
            }
          }
        },
        
        stealExotic: {
          id: 'stealExotic',
          category: 'theft',
          name: 'Steal Exotic Car',
          description: 'Ultra high-end supercar theft. Maximum risk, maximum reward.',
          icon: '',
          riskLevel: 'extreme',
          vehicleTier: 'exotic',
          baseSuccessChance: 0.40,
          rewards: {
            cash: { min: 3000, max: 6000 },
            xp: { min: 80, max: 150 },
            reputation: { min: 20, max: 40 }
          },
          costs: {
            heatGain: { min: 30, max: 50 },
            fatigueCost: 35,
            cooldown: 300000 // 5 minutes
          },
          requirements: {
            minLevel: 7,
            stats: { intelligence: 10, strength: 8, charisma: 6 }
          },
          statModifiers: {
            intelligence: 0.20,
            strength: 0.10,
            charisma: 0.08
          },
          specialEvents: {
            cleanGetaway: {
              probability: 0.08,
              cashBonus: 1000,
              heatReduction: 8,
              repBonus: 10,
              message: ' LEGENDARY! International buyer. Massive payday!',
              canStore: true
            },
            policeChase: {
              probability: 0.30,
              heatIncrease: 40,
              injuryChance: 0.45,
              globalHeatGain: 20,
              message: ' CITYWIDE MANHUNT! Every cop in the city is after you!',
              canStore: false
            },
            botchedTheft: {
              probability: 0.20,
              cashPenalty: 500,
              heatIncrease: 20,
              injuryChance: 0.3,
              message: ' Military-grade security. Narrowly escaped with your life.',
              canStore: false
            },
            ownerConfrontation: {
              probability: 0.12,
              injuryChance: 0.55,
              heatIncrease: 25,
              globalHeatGain: 10,
              message: ' Armed owner and private security! Firefight ensued!',
              canStore: false
            }
          },
          outcomes: {
            critical_success: {
              probability: 0.05,
              cashMultiplier: 3.0,
              xpMultiplier: 3.0,
              heatMultiplier: 0.7,
              canStore: true,
              message: 'LEGENDARY HEIST! Supercar delivered to offshore buyer. You\'re famous now.'
            },
            success: {
              probability: 0.35,
              cashMultiplier: 1.0,
              xpMultiplier: 1.0,
              heatMultiplier: 1.0,
              canStore: true,
              message: 'Incredible job. Elite buyer secured. This will be talked about for years.'
            },
            partial_failure: {
              probability: 0.35,
              cashMultiplier: 0.25,
              xpMultiplier: 0.4,
              heatMultiplier: 2.5,
              injuryChance: 0.35,
              globalHeatGain: 10,
              canStore: false,
              message: 'Heavy resistance. Damaged the vehicle but salvaged some value.'
            },
            failure: {
              probability: 0.25,
              cashMultiplier: 0,
              xpMultiplier: 0,
              heatMultiplier: 5.0,
              injuryChance: 0.6,
              globalHeatGain: 25,
              canStore: false,
              message: 'CATASTROPHIC FAILURE! Armed guards, choppers, tactical units. You\'re lucky to be alive.'
            }
          }
        },
        
        // ORGANIZED CRIME
        armoryHeist: {
          id: 'armoryHeist',
          category: 'organized',
          name: 'Armory Heist',
          description: 'Raid a weapons depot with your crew',
          icon: '',
          riskLevel: 'extreme',
          baseSuccessChance: 0.45,
          rewards: {
            cash: { min: 1000, max: 3000 },
            xp: { min: 50, max: 120 },
            reputation: { min: 15, max: 30 }
          },
          costs: {
            heatGain: { min: 25, max: 50 },
            fatigueCost: 30,
            cooldown: 300000 // 5 minutes
          },
          requirements: {
            minLevel: 5,
            stats: { strength: 8, intelligence: 8 },
            gang: true
          },
          statModifiers: {
            strength: 0.08,
            intelligence: 0.12,
            charisma: 0.08
          },
          gangModifiers: {
            health: 0.10,  // +10% per 10 gang health
            members: 0.05  // +5% per member
          },
          outcomes: {
            critical_success: {
              probability: 0.05,
              cashMultiplier: 4.0,
              xpMultiplier: 3.0,
              heatMultiplier: 0.5,
              gangVaultBonus: 1000,
              message: 'Military-grade haul! Your reputation soars.'
            },
            success: {
              probability: 0.40,
              cashMultiplier: 1.0,
              xpMultiplier: 1.0,
              heatMultiplier: 1.0,
              gangVaultBonus: 500,
              message: 'Clean operation. Weapons secured and sold.'
            },
            partial_failure: {
              probability: 0.35,
              cashMultiplier: 0.3,
              xpMultiplier: 0.5,
              heatMultiplier: 2.5,
              injuryChance: 0.5,
              gangHealthLoss: 10,
              message: 'Security was tougher than expected. Crew took casualties.'
            },
            failure: {
              probability: 0.20,
              cashMultiplier: 0,
              xpMultiplier: 0,
              heatMultiplier: 5.0,
              injuryChance: 0.7,
              gangHealthLoss: 20,
              globalHeatGain: 30,
              message: 'SWAT team ambushed you. Major losses.'
            }
          }
        }
      },
      
      // Crime cooldowns (separate from crime definitions for runtime tracking)
      cooldowns: {}
    };

    // ========================================
    // CRIMES SYSTEM: Core Logic
    // ========================================
    const MapMemory = {
      // How long hotspots last (in milliseconds)
      HOTSPOT_DURATION: 5 * 60 * 1000, // 5 minutes
      
      // Decay rate per interval
      DECAY_RATE: 2, // Risk points per 10 seconds
      
      // Risk levels and their effects
      RISK_LEVELS: {
        low: { threshold: 20, color: 'rgba(255, 180, 130, 0.3)', glow: 0 },
        medium: { threshold: 40, color: 'rgba(255, 150, 100, 0.5)', glow: 2 },
        high: { threshold: 60, color: 'rgba(255, 120, 80, 0.7)', glow: 4 },
        extreme: { threshold: 80, color: 'rgba(255, 90, 60, 0.9)', glow: 6 }
      },
      
      // Area of effect radius (percentage)
      HOTSPOT_RADIUS: 15,
      
      createHotspot(x, y, intensity, reason) {
        const hotspot = {
          x: x,
          y: y,
          intensity: intensity, // 0-100
          createdAt: Date.now(),
          reason: reason,
          id: `hotspot_${Date.now()}_${Math.random()}`
        };
        
        GameState.mapMemory.hotspots.push(hotspot);
        
        // Keep only recent hotspots (max 20)
        if (GameState.mapMemory.hotspots.length > 20) {
          GameState.mapMemory.hotspots = GameState.mapMemory.hotspots.slice(-20);
        }
        
        Storage.save();
        
        console.log(`Hotspot created at ${x.toFixed(1)}%, ${y.toFixed(1)}% - ${reason} (intensity: ${intensity})`);
        
        return hotspot;
      },
      
      getAreaRisk(x, y) {
        let totalRisk = 0;
        
        GameState.mapMemory.hotspots.forEach(hotspot => {
          // Calculate distance
          const dx = x - hotspot.x;
          const dy = y - hotspot.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // If within radius, add risk (falls off with distance)
          if (distance < this.HOTSPOT_RADIUS) {
            const falloff = 1 - (distance / this.HOTSPOT_RADIUS);
            const contribution = hotspot.intensity * falloff;
            totalRisk += contribution;
          }
        });
        
        return Math.min(100, totalRisk);
      },
      
      getRiskLevel(risk) {
        if (risk < this.RISK_LEVELS.low.threshold) return null;
        if (risk < this.RISK_LEVELS.medium.threshold) return 'low';
        if (risk < this.RISK_LEVELS.high.threshold) return 'medium';
        if (risk < this.RISK_LEVELS.extreme.threshold) return 'high';
        return 'extreme';
      },
      
      decayHotspots() {
        const now = Date.now();
        let decayed = false;
        
        GameState.mapMemory.hotspots = GameState.mapMemory.hotspots.filter(hotspot => {
          // Reduce intensity over time
          const age = now - hotspot.createdAt;
          const decayAmount = (age / 10000) * this.DECAY_RATE; // Every 10 seconds
          hotspot.intensity = Math.max(0, hotspot.intensity - (decayAmount * 0.1));
          
          // Remove if too old or too weak
          if (age > this.HOTSPOT_DURATION || hotspot.intensity < 5) {
            decayed = true;
            return false;
          }
          
          return true;
        });
        
        if (decayed) {
          GameState.mapMemory.lastCleanup = now;
          Storage.save();
        }
      },
      
      getHotspotsNearPosition(x, y, radius) {
        return GameState.mapMemory.hotspots.filter(hotspot => {
          const dx = x - hotspot.x;
          const dy = y - hotspot.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < radius;
        });
      },
      
      visualizeHotspots() {
        // Create visual overlays for hotspots
        const container = document.getElementById('map-hotspot-overlays');
        if (!container) {
          const newContainer = document.createElement('div');
          newContainer.id = 'map-hotspot-overlays';
          newContainer.style.position = 'absolute';
          newContainer.style.top = '0';
          newContainer.style.left = '0';
          newContainer.style.width = '100%';
          newContainer.style.height = '100%';
          newContainer.style.pointerEvents = 'none';
          newContainer.style.zIndex = '1';
          
          const mapContainer = document.getElementById('city-map');
          if (mapContainer) {
            mapContainer.appendChild(newContainer);
          }
          return;
        }
        
        // Clear existing overlays
        container.innerHTML = '';
        
        // Create overlay for each hotspot
        GameState.mapMemory.hotspots.forEach(hotspot => {
          const riskLevel = this.getRiskLevel(hotspot.intensity);
          if (!riskLevel) return;
          
          const style = this.RISK_LEVELS[riskLevel];
          
          const overlay = document.createElement('div');
          overlay.style.position = 'absolute';
          overlay.style.left = `${hotspot.x}%`;
          overlay.style.top = `${hotspot.y}%`;
          overlay.style.transform = 'translate(-50%, -50%)';
          overlay.style.width = `${this.HOTSPOT_RADIUS * 2}%`;
          overlay.style.height = `${this.HOTSPOT_RADIUS * 2}%`;
          overlay.style.borderRadius = '50%';
          overlay.style.background = `radial-gradient(circle, ${style.color} 0%, transparent 70%)`;
          overlay.style.boxShadow = style.glow > 0 ? `0 0 ${style.glow}px ${style.color}` : 'none';
          overlay.style.opacity = hotspot.intensity / 100;
          overlay.style.pointerEvents = 'none';
          overlay.style.transition = 'opacity 1s ease';
          
          container.appendChild(overlay);
        });
      }
    };

    // ========================================
    // CRIMES SYSTEM: Core Logic
    // ========================================
    const CrimesSystem = {
      calculateSuccessChance(crimeId) {
        const crime = CrimesDatabase.crimes[crimeId];
        if (!crime) return 0;
        
        let successChance = crime.baseSuccessChance;
        
        // 1. Player stat modifiers
        Object.keys(crime.statModifiers || {}).forEach(stat => {
          const statValue = GameState.player.stats[stat] || 0;
          const minRequired = crime.requirements.stats?.[stat] || 0;
          const statBonus = Math.max(0, statValue - minRequired);
          successChance += statBonus * crime.statModifiers[stat];
        });
        
        // 2. Gang modifiers (if required)
        if (crime.requirements.gang && GameState.gang) {
          if (crime.gangModifiers?.health) {
            const healthBonus = (GameState.gang.health / 100) * crime.gangModifiers.health;
            successChance += healthBonus;
          }
          if (crime.gangModifiers?.members) {
            const memberBonus = GameState.gang.members.length * crime.gangModifiers.members;
            successChance += memberBonus;
          }
        }
        
        // 3. Heat penalty (personal + global)
        const totalHeat = GameState.player.heat + (GameState.player.globalHeat * 0.5);
        const heatPenalty = (totalHeat / 100) * 0.25; // Up to -25% at max heat
        successChance -= heatPenalty;
        
        // 4. Fatigue penalty
        const fatiguePenalty = FatigueSystem.getSuccessPenalty();
        successChance -= fatiguePenalty;
        
        // 5. Area difficulty (from map memory)
        const pos = GameState.character.position;
        const areaRisk = MapMemory.getAreaRisk(pos.x, pos.y);
        const areaPenalty = (areaRisk / 100) * 0.15; // Up to -15% in hot zones
        successChance -= areaPenalty;
        
        // 6. Equipment bonuses (future expansion)
        // successChance += this.getEquipmentBonus(crimeId);
        
        // Clamp between 5% and 95%
        return Math.max(0.05, Math.min(0.95, successChance));
      },
      
      canAttemptCrime(crimeId) {
        const crime = CrimesDatabase.crimes[crimeId];
        if (!crime) return { canAttempt: false, reason: 'Crime not found' };
        
        // Check level requirement
        if (GameState.player.level < crime.requirements.minLevel) {
          return { 
            canAttempt: false, 
            reason: `Requires level ${crime.requirements.minLevel}` 
          };
        }
        
        // Check stat requirements
        for (const [stat, minValue] of Object.entries(crime.requirements.stats || {})) {
          if (GameState.player.stats[stat] < minValue) {
            return { 
              canAttempt: false, 
              reason: `Requires ${stat} ${minValue}` 
            };
          }
        }
        
        // Check gang requirement
        if (crime.requirements.gang && !GameState.gang) {
          return { 
            canAttempt: false, 
            reason: 'Requires gang membership' 
          };
        }
        
        // Check cooldown
        const cooldownEnd = CrimesDatabase.cooldowns[crimeId];
        if (cooldownEnd && Date.now() < cooldownEnd) {
          const remaining = Math.ceil((cooldownEnd - Date.now()) / 1000);
          return { 
            canAttempt: false, 
            reason: `Cooldown: ${remaining}s` 
          };
        }
        
        // Check if in jail/dead
        if (GameState.player.jail.isJailed) {
          return { canAttempt: false, reason: 'Currently incarcerated' };
        }
        
        if (GameState.character.isDead) {
          return { canAttempt: false, reason: 'Currently dead' };
        }
        
        return { canAttempt: true };
      },
      
      attemptCrime(crimeId) {
        const canAttempt = this.canAttemptCrime(crimeId);
        if (!canAttempt.canAttempt) {
          console.log(`Cannot attempt ${crimeId}: ${canAttempt.reason}`);
          return null;
        }
        
        const crime = CrimesDatabase.crimes[crimeId];
        
        // Calculate success chance
        const successChance = this.calculateSuccessChance(crimeId);
        
        // Roll with fairness system
        const roll = RNGFairness.rollWithFairness(successChance, 'event');
        
        // Determine outcome tier
        const outcome = this.determineOutcome(crime, roll, successChance);
        
        // Check for special events (GTA crimes only)
        const specialEvent = this.checkSpecialEvent(crime, outcome);
        
        // Apply consequences
        const result = this.applyOutcome(crime, outcome, specialEvent);
        
        // Set cooldown
        CrimesDatabase.cooldowns[crimeId] = Date.now() + crime.costs.cooldown;
        
        // Add fatigue
        FatigueSystem.addFatigue('event', crime.name);
        
        // Create map hotspot
        const pos = GameState.character.position;
        const hotspotIntensity = this.getHotspotIntensity(outcome.tier);
        MapMemory.createHotspot(pos.x, pos.y, hotspotIntensity, crime.name);
        
        // Save state
        Storage.save();
        
        return result;
      },
      
      determineOutcome(crime, succeeded, successChance) {
        const outcomes = crime.outcomes;
        
        if (succeeded) {
          // Success - determine if critical
          const criticalRoll = Math.random();
          if (criticalRoll < outcomes.critical_success.probability) {
            return { tier: 'critical_success', data: outcomes.critical_success };
          }
          return { tier: 'success', data: outcomes.success };
        } else {
          // Failure - determine severity
          const failureRoll = Math.random();
          const partialThreshold = outcomes.partial_failure.probability;
          
          if (failureRoll < partialThreshold) {
            return { tier: 'partial_failure', data: outcomes.partial_failure };
          }
          return { tier: 'failure', data: outcomes.failure };
        }
      },
      
      checkSpecialEvent(crime, outcome) {
        // Only applies to GTA crimes with special events
        if (!crime.specialEvents) return null;
        
        // Special events only trigger on success or partial failure
        if (outcome.tier === 'failure') return null;
        
        const roll = Math.random();
        let cumulative = 0;
        
        // Check each special event
        for (const [eventId, eventData] of Object.entries(crime.specialEvents)) {
          cumulative += eventData.probability;
          if (roll < cumulative) {
            return {
              id: eventId,
              data: eventData
            };
          }
        }
        
        return null;
      },
      
      applyOutcome(crime, outcome, specialEvent) {
        const outcomeData = outcome.data;
        
        // Calculate base rewards
        let cashReward = this.calculateReward(
          crime.rewards.cash.min, 
          crime.rewards.cash.max, 
          outcomeData.cashMultiplier
        );
        
        const xpReward = this.calculateReward(
          crime.rewards.xp.min, 
          crime.rewards.xp.max, 
          outcomeData.xpMultiplier
        );
        
        let repReward = Math.floor(
          this.calculateReward(
            crime.rewards.reputation.min, 
            crime.rewards.reputation.max, 
            outcomeData.cashMultiplier
          )
        );
        
        // Calculate base heat
        let heatGain = this.calculateReward(
          crime.costs.heatGain.min,
          crime.costs.heatGain.max,
          outcomeData.heatMultiplier
        );
        
        // Apply special event modifiers (GTA crimes)
        let specialEventMessage = null;
        let vehicleStored = false;
        
        if (specialEvent) {
          const eventData = specialEvent.data;
          specialEventMessage = eventData.message;
          
          // Apply event bonuses/penalties
          if (eventData.cashBonus) cashReward += eventData.cashBonus;
          if (eventData.cashPenalty) cashReward = Math.max(0, cashReward - eventData.cashPenalty);
          if (eventData.heatReduction) heatGain = Math.max(0, heatGain - eventData.heatReduction);
          if (eventData.heatIncrease) heatGain += eventData.heatIncrease;
          if (eventData.repBonus) repReward += eventData.repBonus;
          
          // Check for vehicle storage (clean getaway)
          if (eventData.canStore && crime.vehicleTier) {
            vehicleStored = this.storeVehicle(crime);
          }
          
          // Apply global heat from special events
          if (eventData.globalHeatGain) {
            TurfTab.addGlobalHeat(eventData.globalHeatGain, `${crime.name} - ${specialEvent.id}`);
          }
          
          // Handle special event injuries
          if (eventData.injuryChance && Math.random() < eventData.injuryChance) {
            const injuryPenalty = Math.floor(Math.random() * 150) + 100;
            cashReward = Math.max(0, cashReward - injuryPenalty);
          }
        } else if (!specialEvent && outcomeData.canStore && crime.vehicleTier) {
          // Standard storage check for successful GTA crimes
          vehicleStored = this.storeVehicle(crime);
        }
        
        // Apply changes
        GameState.player.cash += cashReward;
        GameState.player.xp += xpReward;
        GameState.player.reputation += repReward;
        GameState.player.heat = Math.min(100, GameState.player.heat + heatGain);
        
        // Apply suspicion gain (affected by fatigue)
        const baseSuspicionGain = heatGain * 0.5;
        const fatigueMultiplier = FatigueSystem.getSuspicionMultiplier();
        TurfTab.addSuspicion(baseSuspicionGain * fatigueMultiplier, crime.name);
        
        // Apply global heat if specified in outcome
        if (outcomeData.globalHeatGain) {
          TurfTab.addGlobalHeat(outcomeData.globalHeatGain, `${crime.name} - ${outcome.tier}`);
        }
        
        // Handle standard injury
        let injured = false;
        if (outcomeData.injuryChance && Math.random() < outcomeData.injuryChance) {
          injured = true;
          const injuryPenalty = Math.floor(Math.random() * 100) + 50;
          GameState.player.cash = Math.max(0, GameState.player.cash - injuryPenalty);
        }
        
        // Handle gang bonuses/penalties
        if (GameState.gang) {
          if (outcomeData.gangVaultBonus) {
            GameState.gang.vault += outcomeData.gangVaultBonus;
          }
          if (outcomeData.gangHealthLoss) {
            GameState.gang.health = Math.max(0, GameState.gang.health - outcomeData.gangHealthLoss);
          }
          if (outcomeData.gangHeatGain) {
            const relations = Object.keys(GameState.gangRelations);
            if (relations.length > 0) {
              const randomRelation = relations[Math.floor(Math.random() * relations.length)];
              GameState.gangRelations[randomRelation].heat = Math.min(
                100,
                GameState.gangRelations[randomRelation].heat + outcomeData.gangHeatGain
              );
            }
          }
        }
        
        // Update UI
        TurfTab.updateHeatIndicator();
        TurfTab.updateGlobalHeatDisplay();
        ProfileTab.render();
        if (GameState.gang) GangTab.render();
        
        // Sync to leaderboard after significant changes
        Storage.updateLeaderboard();
        
        // Return result summary
        return {
          crimeId: crime.id,
          crimeName: crime.name,
          outcome: outcome.tier,
          message: outcomeData.message,
          specialEvent: specialEventMessage,
          rewards: {
            cash: cashReward,
            xp: xpReward,
            reputation: repReward
          },
          costs: {
            heat: heatGain,
            injured: injured
          },
          vehicleStored: vehicleStored
        };
      },
      
      calculateReward(min, max, multiplier) {
        const base = Math.floor(Math.random() * (max - min + 1)) + min;
        return Math.floor(base * multiplier);
      },
      
      getHotspotIntensity(outcomeTier) {
        const intensityMap = {
          critical_success: 15,
          success: 25,
          partial_failure: 45,
          failure: 70
        };
        return intensityMap[outcomeTier] || 30;
      },
      
      getCrimesByCategory(categoryId) {
        return Object.values(CrimesDatabase.crimes).filter(
          crime => crime.category === categoryId
        );
      },
      
      getAvailableCrimes() {
        return Object.values(CrimesDatabase.crimes).filter(crime => {
          const check = this.canAttemptCrime(crime.id);
          return check.canAttempt || 
                 check.reason.includes('Cooldown') || 
                 check.reason.includes('Requires level');
        });
      },
      
      // Vehicle storage system
      storeVehicle(crime) {
        const garage = GameState.player.garage;
        
        // Check if garage is full
        if (garage.vehicles.length >= garage.capacity) {
          console.log('Garage full - vehicle sold instead');
          return false;
        }
        
        // Create vehicle object
        const vehicle = {
          id: `${crime.vehicleTier}_${Date.now()}`,
          tier: crime.vehicleTier,
          name: this.generateVehicleName(crime.vehicleTier),
          storedAt: Date.now(),
          sellValue: this.calculateVehicleSellValue(crime)
        };
        
        garage.vehicles.push(vehicle);
        console.log(`Vehicle stored: ${vehicle.name} (worth $${vehicle.sellValue})`);
        
        return true;
      },
      
      generateVehicleName(tier) {
        const names = {
          junker: ['Rusty Civic', 'Beat-up Corolla', 'Old Camry', 'Weathered Accord'],
          sedan: ['Honda Accord', 'Toyota Camry', 'Nissan Altima', 'Ford Fusion'],
          luxury: ['Mercedes S-Class', 'BMW 7-Series', 'Audi A8', 'Lexus LS'],
          exotic: ['Ferrari 488', 'Lamborghini Huracn', 'McLaren 720S', 'Porsche 911 Turbo']
        };
        
        const tierNames = names[tier] || names.sedan;
        return tierNames[Math.floor(Math.random() * tierNames.length)];
      },
      
      calculateVehicleSellValue(crime) {
        const baseValue = (crime.rewards.cash.min + crime.rewards.cash.max) / 2;
        const multiplier = 0.6; // Can sell for 60% of average reward
        return Math.floor(baseValue * multiplier);
      },
      
      sellVehicle(vehicleId) {
        const garage = GameState.player.garage;
        const vehicleIndex = garage.vehicles.findIndex(v => v.id === vehicleId);
        
        if (vehicleIndex === -1) {
          console.log('Vehicle not found');
          return null;
        }
        
        const vehicle = garage.vehicles[vehicleIndex];
        
        // Check cooldown (can only sell one vehicle per 2 minutes)
        if (garage.lastSale && Date.now() - garage.lastSale < 120000) {
          const remaining = Math.ceil((120000 - (Date.now() - garage.lastSale)) / 1000);
          return {
            success: false,
            reason: `Sale cooldown: ${remaining}s`
          };
        }
        
        // Remove vehicle and add cash
        garage.vehicles.splice(vehicleIndex, 1);
        GameState.player.cash += vehicle.sellValue;
        garage.lastSale = Date.now();
        
        // Update UI
        ProfileTab.render();
        Storage.save();
        
        console.log(`Sold ${vehicle.name} for $${vehicle.sellValue}`);
        
        return {
          success: true,
          vehicle: vehicle,
          value: vehicle.sellValue
        };
      },
      
      getGarageStatus() {
        const garage = GameState.player.garage;
        return {
          vehicles: garage.vehicles,
          count: garage.vehicles.length,
          capacity: garage.capacity,
          totalValue: garage.vehicles.reduce((sum, v) => sum + v.sellValue, 0),
          canSell: !garage.lastSale || Date.now() - garage.lastSale >= 120000
        };
      }
    };

    // ========================================
    // CORE: Fatigue System
    // ========================================
    const FatigueSystem = {
      // Thresholds
      LOW_FATIGUE: 30,
      MEDIUM_FATIGUE: 60,
      HIGH_FATIGUE: 85,
      
      // How much fatigue each action type adds
      ACTION_COSTS: {
        event: 15,        // Random events
        raid: 20,         // Gang raids
        freeRoam: 2       // Per free roam movement (slower buildup)
      },
      
      // Recovery rates (per interval)
      RECOVERY_RATES: {
        idle_laying_low: 3,      // Laying low + not moving (best)
        laying_low: 2,           // Just laying low
        idle: 1                  // Not doing anything risky
      },
      
      // Time window for "consecutive" (actions within this are consecutive)
      CONSECUTIVE_WINDOW: 60 * 1000, // 60 seconds
      
      // Maximum penalty
      MAX_SUCCESS_PENALTY: 0.20,    // -20% max
      MAX_SUSPICION_MULTIPLIER: 1.5, // +50% max
      
      addFatigue(actionType, reason) {
        const fatigue = GameState.player.fatigue;
        const now = Date.now();
        
        // Check if this is consecutive (within window)
        const isConsecutive = fatigue.lastAction && (now - fatigue.lastAction) < this.CONSECUTIVE_WINDOW;
        
        if (isConsecutive) {
          fatigue.consecutiveActions++;
        } else {
          fatigue.consecutiveActions = 1;
        }
        
        // Base cost
        let cost = this.ACTION_COSTS[actionType] || 10;
        
        // Increase cost for consecutive actions
        if (fatigue.consecutiveActions > 2) {
          const consecutiveMultiplier = 1 + ((fatigue.consecutiveActions - 2) * 0.2); // +20% per action after 2nd
          cost *= consecutiveMultiplier;
        }
        
        // Add fatigue (capped at 100)
        const oldLevel = fatigue.level;
        fatigue.level = Math.min(100, fatigue.level + cost);
        fatigue.lastAction = now;
        
        Storage.save();
        
        // Log significant fatigue changes
        if (Math.floor(oldLevel / 20) !== Math.floor(fatigue.level / 20)) {
          console.log(`Fatigue: ${oldLevel.toFixed(1)}  ${fatigue.level.toFixed(1)} (${reason}, consecutive: ${fatigue.consecutiveActions})`);
        }
      },
      
      recoverFatigue(recoveryType) {
        const fatigue = GameState.player.fatigue;
        const rate = this.RECOVERY_RATES[recoveryType] || 0;
        
        if (rate > 0 && fatigue.level > 0) {
          const oldLevel = fatigue.level;
          fatigue.level = Math.max(0, fatigue.level - rate);
          
          // Reset consecutive counter when significantly recovered
          if (fatigue.level < 20) {
            fatigue.consecutiveActions = 0;
          }
          
          Storage.save();
          
          // Log recovery
          if (Math.floor(oldLevel / 20) !== Math.floor(fatigue.level / 20)) {
            console.log(`Fatigue recovery: ${oldLevel.toFixed(1)}  ${fatigue.level.toFixed(1)} (${recoveryType})`);
          }
        }
      },
      
      getSuccessPenalty() {
        const level = GameState.player.fatigue.level;
        
        if (level < this.LOW_FATIGUE) return 0;
        
        // Linear scaling from low to max
        const penalty = ((level - this.LOW_FATIGUE) / (100 - this.LOW_FATIGUE)) * this.MAX_SUCCESS_PENALTY;
        return Math.min(this.MAX_SUCCESS_PENALTY, penalty);
      },
      
      getSuspicionMultiplier() {
        const level = GameState.player.fatigue.level;
        
        if (level < this.LOW_FATIGUE) return 1.0;
        
        // Linear scaling from 1.0 to max
        const multiplier = 1.0 + ((level - this.LOW_FATIGUE) / (100 - this.LOW_FATIGUE)) * (this.MAX_SUSPICION_MULTIPLIER - 1.0);
        return Math.min(this.MAX_SUSPICION_MULTIPLIER, multiplier);
      },
      
      getFatigueLevel() {
        const level = GameState.player.fatigue.level;
        
        if (level < this.LOW_FATIGUE) return 'rested';
        if (level < this.MEDIUM_FATIGUE) return 'tired';
        if (level < this.HIGH_FATIGUE) return 'exhausted';
        return 'drained';
      },
      
      shouldWarnPlayer() {
        // Warn when reaching high fatigue
        return GameState.player.fatigue.level >= this.HIGH_FATIGUE;
      }
    };

    // ========================================
    // CORE: RNG Fairness System
    // ========================================
    const RNGFairness = {
      // Decay memory every 5 minutes
      DECAY_INTERVAL: 5 * 60 * 1000,
      
      // Maximum memory size (keep last N outcomes)
      MAX_MEMORY: 10,
      
      // How much to nudge probability based on streak
      NUDGE_FACTOR: 0.05, // 5% per outcome in streak
      
      // Maximum nudge allowed
      MAX_NUDGE: 0.25, // Cap at 25%
      
      recordOutcome(type, success) {
        const memory = GameState.player.rngMemory;
        const outcomes = type === 'event' ? memory.eventOutcomes : memory.raidOutcomes;
        
        // Add new outcome
        outcomes.push({
          success: success,
          timestamp: Date.now()
        });
        
        // Keep only recent outcomes
        if (outcomes.length > this.MAX_MEMORY) {
          outcomes.shift();
        }
        
        Storage.save();
      },
      
      getFairnessModifier(type) {
        const memory = GameState.player.rngMemory;
        const outcomes = type === 'event' ? memory.eventOutcomes : memory.raidOutcomes;
        
        if (outcomes.length < 2) return 0; // Need at least 2 outcomes for pattern
        
        // Count recent streak
        let streak = 0;
        let lastResult = outcomes[outcomes.length - 1].success;
        
        // Count backwards from most recent
        for (let i = outcomes.length - 1; i >= 0; i--) {
          if (outcomes[i].success === lastResult) {
            streak++;
          } else {
            break;
          }
        }
        
        // Calculate modifier
        let modifier = 0;
        
        if (lastResult === false && streak >= 2) {
          // Recent failures -> increase success chance
          modifier = Math.min(this.MAX_NUDGE, streak * this.NUDGE_FACTOR);
        } else if (lastResult === true && streak >= 3) {
          // Recent successes -> increase failure chance
          modifier = -Math.min(this.MAX_NUDGE, (streak - 1) * this.NUDGE_FACTOR);
        }
        
        return modifier;
      },
      
      decayMemory() {
        const memory = GameState.player.rngMemory;
        const now = Date.now();
        
        // Check if enough time passed
        if (now - memory.lastMemoryDecay < this.DECAY_INTERVAL) return;
        
        // Remove oldest outcome from each category
        if (memory.eventOutcomes.length > 0) {
          memory.eventOutcomes.shift();
        }
        
        if (memory.raidOutcomes.length > 0) {
          memory.raidOutcomes.shift();
        }
        
        memory.lastMemoryDecay = now;
        Storage.save();
        
        console.log('RNG memory decayed');
      },
      
      rollWithFairness(baseChance, type) {
        const modifier = this.getFairnessModifier(type);
        const adjustedChance = Math.max(0, Math.min(1, baseChance + modifier));
        const roll = Math.random();
        const success = roll < adjustedChance;
        
        // Record outcome
        this.recordOutcome(type, success);
        
        // Log for debugging (only when modifier is active)
        if (Math.abs(modifier) > 0.01) {
          console.log(`RNG ${type}: base ${(baseChance*100).toFixed(1)}%  adjusted ${(adjustedChance*100).toFixed(1)}% (modifier: ${modifier > 0 ? '+' : ''}${(modifier*100).toFixed(1)}%) = ${success ? 'SUCCESS' : 'FAIL'}`);
        }
        
        return success;
      }
    };

    // ========================================
    // CORE: Initialize Map Icons
    // ========================================
    function initializeMapIcons() {
      if (GameState.mapIcons.length === 0) {
        GameState.mapIcons = [
          { type: "safeHouse", icon: "", x: 30, y: 50, state: "active", label: "Safe House" },
          { type: "hospital", icon: "", x: 75, y: 25, state: "dormant", label: "Hospital" },
          { type: "dealer", icon: "", x: 20, y: 75, state: "dormant", label: "Dealer" },
          { type: "gang", icon: "", x: 70, y: 60, state: "dormant", label: "Gang HQ" },
          { type: "police", icon: "", x: 50, y: 20, state: "dormant", label: "Police Station" }
        ];
        
        // Update character and safe house positions to match safe house icon
        GameState.character.position = { x: 30, y: 50 };
        GameState.safeHouse.position = { x: 30, y: 50 };
      }
    }

    // ========================================
    // LEADERBOARD: Global Player Rankings (Firebase)
    // ========================================
    const GlobalLeaderboard = {
      LEADERBOARD_KEY: 'crime_rpg_leaderboard',
      listeners: new Set(),
      cachedLeaderboard: [],
      isListening: false,
      
      // Initialize Firebase listener
      initFirebaseListener() {
        if (this.isListening) return;
        
        if (!database) {
          console.error('Firebase not initialized');
          return;
        }
        
        const leaderboardRef = database.ref('leaderboard');
        
        // Listen for real-time updates
        leaderboardRef.on('value', (snapshot) => {
          const data = snapshot.val();
          
          if (data) {
            // Convert object to array
            this.cachedLeaderboard = Object.values(data);
            console.log(' Leaderboard updated from Firebase:', this.cachedLeaderboard.length, 'players');
          } else {
            this.cachedLeaderboard = [];
            console.log(' Leaderboard empty');
          }
          
          // Trigger render if modal is open
          if (document.getElementById('leaderboard-modal')) {
            this.renderLeaderboard();
          }
        });
        
        this.isListening = true;
        console.log(' Firebase leaderboard listener active');
      },
      
      // Get all player entries from Firebase (cached)
      getAllEntries() {
        return this.cachedLeaderboard;
      },
      
      // Update or add player entry to Firebase
      updatePlayer(accountId, username, level, cash, reputation, heat, position, status) {
        console.log(' updatePlayer called with:', { accountId, username, level, cash, reputation, heat, position, status });
        
        if (!database) {
          console.error(' Firebase not initialized - database is null');
          return;
        }
        
        console.log(' Database exists, preparing entry...');
        
        // Determine zone name from position
        const zoneName = this.getZoneName(position);
        
        const entry = {
          accountId: accountId,
          username: username,
          level: level,
          cash: cash,
          reputation: reputation,
          heat: Math.round(heat),
          lastKnownZone: zoneName,
          status: status, // 'laying_low' or 'active'
          lastUpdated: Date.now()
        };
        
        console.log(' Entry to write:', entry);
        console.log(' Firebase path: leaderboard/' + accountId);
        
        const playerRef = database.ref(`leaderboard/${accountId}`);
        console.log(' Firebase reference created:', playerRef.toString());
        
        playerRef.set(entry)
          .then(() => {
            console.log(' Leaderboard updated for:', username);
            console.log(' Data written to Firebase successfully!');
          })
          .catch((error) => {
            console.error(' Failed to update leaderboard:', error);
            console.error(' Error details:', error.message, error.code);
          });
      },
      
      // Get zone name from position
      getZoneName(position) {
        if (!GameState.map.grid) return 'Unknown';
        
        const gridX = Math.floor((position.x / 100) * GameState.map.width);
        const gridY = Math.floor((position.y / 100) * GameState.map.height);
        const tile = TileGridGenerator.getTile(GameState.map.grid, gridX, gridY);
        
        if (!tile) return 'Unknown';
        
        const biome = Object.values(BIOMES).find(b => b.id === tile.biome);
        return biome ? biome.name : 'Unknown';
      },
      
      // Get sorted leaderboard (by reputation, then level, then cash)
      getSortedLeaderboard() {
        const entries = this.getAllEntries();
        
        return entries.sort((a, b) => {
          // Primary: Reputation (descending)
          if (b.reputation !== a.reputation) {
            return b.reputation - a.reputation;
          }
          
          // Secondary: Level (descending)
          if (b.level !== a.level) {
            return b.level - a.level;
          }
          
          // Tertiary: Cash (descending)
          return b.cash - a.cash;
        });
      },
      
      // Render leaderboard into modal
      renderLeaderboard() {
        const leaderboard = this.getSortedLeaderboard();
        const currentAccountId = GameState.accountId;
        
        // Find modal if it exists
        const existingModal = document.getElementById('leaderboard-modal');
        if (!existingModal) return; // Not open yet
        
        // If empty leaderboard, show empty state
        if (leaderboard.length === 0) {
          this.showEmptyLeaderboard();
          return;
        }
        
        // Create content container if it doesn't exist
        let content = existingModal.querySelector('.event-modal-content');
        if (!content) {
          content = document.createElement('div');
          content.className = 'event-modal-content';
          existingModal.appendChild(content);
        }
        
        // Store scroll position
        const scrollContainer = content.querySelector('.leaderboard-list');
        const scrollPos = scrollContainer ? scrollContainer.scrollTop : 0;
        
        let entriesHTML = '';
        
        leaderboard.forEach((entry, index) => {
          const rank = index + 1;
          const isCurrentPlayer = entry.accountId === currentAccountId;
          
          let rankIcon = '';
          if (rank === 1) rankIcon = '';
          else if (rank === 2) rankIcon = '';
          else if (rank === 3) rankIcon = '';
          
          const highlightClass = isCurrentPlayer ? 'leaderboard-current-player' : '';
          const badge = isCurrentPlayer ? '<span class="player-badge">YOU</span>' : '';
          
          entriesHTML += `
            <div class="leaderboard-entry ${highlightClass}">
              <div class="leaderboard-rank">${rankIcon}</div>
              <div class="leaderboard-player-info">
                <div class="leaderboard-username">
                  ${entry.username}
                  ${badge}
                </div>
                <div class="leaderboard-stats">
                  <span class="leaderboard-stat">
                    <span class="leaderboard-stat-icon"></span>
                    <span>Lvl ${entry.level}</span>
                  </span>
                  <span class="leaderboard-stat">
                    <span class="leaderboard-stat-icon"></span>
                    <span>$${entry.cash.toLocaleString()}</span>
                  </span>
                  <span class="leaderboard-stat">
                    <span class="leaderboard-stat-icon"></span>
                    <span>${entry.reputation}</span>
                  </span>
                </div>
              </div>
            </div>
          `;
        });
        
        content.innerHTML = `
          <div class="event-modal-icon"></div>
          <div class="event-modal-title">Global Leaderboard</div>
          <div class="event-modal-description">
            Top criminals ranked by reputation, level, and wealth.
          </div>
          
          <div class="leaderboard-container">
            <div class="leaderboard-list">
              ${entriesHTML}
            </div>
          </div>
          
          <button class="outcome-btn" id="close-leaderboard-modal">Close</button>
        `;
        
        // Restore scroll position
        const newScrollContainer = content.querySelector('.leaderboard-list');
        if (newScrollContainer) {
          newScrollContainer.scrollTop = scrollPos;
        }
        
        // Re-attach close button
        document.getElementById('close-leaderboard-modal')?.addEventListener('click', () => {
          existingModal.remove();
        });
      },
      
      // Show empty leaderboard message
      showEmptyLeaderboard() {
        const existingModal = document.getElementById('leaderboard-modal');
        if (!existingModal) return;
        
        // Create content container if it doesn't exist
        let content = existingModal.querySelector('.event-modal-content');
        if (!content) {
          content = document.createElement('div');
          content.className = 'event-modal-content';
          existingModal.appendChild(content);
        }
        
        content.innerHTML = `
          <div class="event-modal-icon"></div>
          <div class="event-modal-title">Global Leaderboard</div>
          <div class="event-modal-description">
            Be the first to rise to the top! 
          </div>
          
          <div class="leaderboard-container">
            <div class="leaderboard-empty">
              <div class="leaderboard-empty-icon"></div>
              <div class="leaderboard-empty-text">Be the first to rise</div>
              <div class="leaderboard-empty-subtext">Start building your criminal empire</div>
            </div>
          </div>
          
          <button class="outcome-btn" id="close-leaderboard-modal">Close</button>
        `;
        
        document.getElementById('close-leaderboard-modal')?.addEventListener('click', () => {
          existingModal.remove();
        });
      }
    };

    // ========================================
    // CORE: Storage Manager (PHASE A/B Enhanced)
    // ========================================
    const Storage = {
      SAVE_KEY: "crime_rpg_save",
      SAVE_KEY_PREFIX: "crime_rpg_save_", // Per-account saves
      
      // Get the correct save key for current account
      getSaveKey() {
        const accountId = AccountManager.getCurrentAccountId();
        if (accountId) {
          return this.SAVE_KEY_PREFIX + accountId;
        }
        return this.SAVE_KEY; // Legacy/anonymous key
      },
      
      save() {
        try {
          const saveKey = this.getSaveKey();
          localStorage.setItem(saveKey, JSON.stringify(GameState));
          console.log('Game saved to:', saveKey);
          
          // Update leaderboard when saving
          this.updateLeaderboard();
        } catch (e) {
          console.warn("Save failed:", e);
        }
      },
      
      // Update leaderboard entry for current player
      updateLeaderboard() {
        console.log(' Storage.updateLeaderboard() called');
        console.log(' Firebase ready?', firebaseReady);
        console.log(' Database exists?', database !== null);
        console.log(' GameState.accountId:', GameState.accountId);
        
        if (!GameState.accountId) {
          console.warn(' No accountId - skipping leaderboard update');
          return;
        }
        
        // If Firebase isn't ready yet, retry in 2 seconds
        if (!firebaseReady || !database) {
          console.log(' Firebase not ready yet, retrying in 2 seconds...');
          setTimeout(() => {
            console.log(' Retry attempt - Firebase ready?', firebaseReady, 'Database?', database !== null);
            this.updateLeaderboard();
          }, 2000);
          return;
        }
        
        const account = AccountManager.getAccount(GameState.accountId);
        console.log(' Account retrieved:', account ? account.username : 'NULL');
        
        if (!account) {
          console.warn(' Account not found - skipping leaderboard update');
          return;
        }
        
        console.log(' Calling GlobalLeaderboard.updatePlayer...');
        GlobalLeaderboard.updatePlayer(
          GameState.accountId,
          GameState.player.name || account.username,
          GameState.player.level,
          GameState.player.cash,
          GameState.player.reputation,
          GameState.player.heat,
          GameState.character.position,
          GameState.playerStatus
        );
      },
      
      load() {
        try {
          const saveKey = this.getSaveKey();
          const data = localStorage.getItem(saveKey);
          if (data) {
            const loaded = JSON.parse(data);
            // Merge loaded data into GameState, preserving new fields
            this.mergeState(GameState, loaded);
            console.log('Game loaded from:', saveKey);
          }
        } catch (e) {
          console.warn("Load failed:", e);
        }
      },
      
      // Check if anonymous progress exists
      hasAnonymousProgress() {
        try {
          const data = localStorage.getItem(this.SAVE_KEY);
          if (!data) return false;
          
          const save = JSON.parse(data);
          // Consider it "progress" if they have XP, cash, or are past level 1
          return save.player && (
            save.player.xp > 0 || 
            save.player.cash !== 1000 || 
            save.player.level > 1 ||
            save.player.reputation > 0
          );
        } catch (e) {
          return false;
        }
      },
      
      // Migrate anonymous progress to new account
      migrateToAccount(accountId) {
        try {
          console.log('Migrating anonymous progress to account:', accountId);
          
          // Load anonymous save
          const anonymousData = localStorage.getItem(this.SAVE_KEY);
          if (!anonymousData) {
            console.log('No anonymous data to migrate');
            return false;
          }
          
          // Save to account-specific key
          const accountSaveKey = this.SAVE_KEY_PREFIX + accountId;
          localStorage.setItem(accountSaveKey, anonymousData);
          
          // Update GameState accountId
          const loaded = JSON.parse(anonymousData);
          loaded.accountId = accountId;
          
          // Save updated state
          localStorage.setItem(accountSaveKey, JSON.stringify(loaded));
          
          // Clear anonymous save (migration complete)
          localStorage.removeItem(this.SAVE_KEY);
          
          console.log('Migration successful');
          return true;
        } catch (e) {
          console.error('Migration failed:', e);
          return false;
        }
      },
      
      // Load specific account's save
      loadAccountSave(accountId) {
        try {
          const saveKey = this.SAVE_KEY_PREFIX + accountId;
          const data = localStorage.getItem(saveKey);
          
          if (data) {
            const loaded = JSON.parse(data);
            this.mergeState(GameState, loaded);
            console.log('Loaded account save:', accountId);
            return true;
          }
          
          return false;
        } catch (e) {
          console.error('Failed to load account save:', e);
          return false;
        }
      },
      
      // Deep merge that preserves GameState structure
      mergeState(target, source) {
        for (const key in source) {
          if (source.hasOwnProperty(key)) {
            if (target[key] && typeof target[key] === 'object' && !Array.isArray(target[key])) {
              this.mergeState(target[key], source[key]);
            } else {
              target[key] = source[key];
            }
          }
        }
      }
    };
    
    console.log('=== PHASE A: Storage Enhanced - COMPLETE ===');

    // ========================================
    // UI: Tab System
    // ========================================
    const TabSystem = {
      init() {
        const tabs = document.querySelectorAll('.tab');
        tabs.forEach(tab => {
          tab.addEventListener('click', () => {
            this.switchTab(tab.dataset.tab);
          });
        });
        
        // Load saved tab state
        this.switchTab(GameState.ui.activeTab);
      },
      
      switchTab(tabId) {
        // Update UI state
        GameState.ui.activeTab = tabId;
        
        // Update tab bar
        document.querySelectorAll('.tab').forEach(tab => {
          tab.classList.toggle('active', tab.dataset.tab === tabId);
        });
        
        // Update content area
        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.toggle('active', content.id === `${tabId}-tab`);
        });
        
        // Trigger active tab render
        this.renderActiveTab(tabId);
        
        // Save state
        Storage.save();
      },
      
      renderActiveTab(tabId) {
        const renderers = {
          profile: ProfileTab,
          turf: TurfTab,
          crimes: CrimesTab,
          safehouse: SafeHouseTab,
          inventory: InventoryTab,
          gang: GangTab
        };
        
        const renderer = renderers[tabId];
        if (renderer && renderer.render) {
          console.log(`Rendering tab: ${tabId}`);
          renderer.render();
        } else {
          console.warn(`No renderer found for tab: ${tabId}`);
        }
      }
    };

    // ========================================
    // UI: Tab Renderers (RENDER CONTRACT)
    // ========================================
    const ProfileTab = {
      render() {
        const { player } = GameState;
        
        // Render crime board cards (visual layer)
        this.renderCrimeBoard();
        
        // Hide old stat-grid (legacy UI - no longer needed visually)
        const statGrid = document.querySelector('.stat-grid');
        if (statGrid) {
          statGrid.style.display = 'none';
        }
        
        // Render logout button
        this.renderLogoutButton();
        
        // Render heat log if exists (kept as scroll target)
        this.renderHeatLog();
        
        // Render drain log if exists (kept as scroll target)
        this.renderDrainLog();
      },
      
      renderCrimeBoard() {
        const { player } = GameState;
        
        // Check if crime board already exists
        let crimeBoard = document.querySelector('.crime-board');
        if (!crimeBoard) {
          // Create crime board container
          crimeBoard = document.createElement('div');
          crimeBoard.className = 'crime-board';
          
          // Insert after page header
          const profileTab = document.getElementById('profile-tab');
          const pageHeader = profileTab.querySelector('.page-header');
          if (pageHeader && pageHeader.nextSibling) {
            profileTab.insertBefore(crimeBoard, pageHeader.nextSibling);
          } else if (pageHeader) {
            pageHeader.after(crimeBoard);
          }
        }
        
        // Render cards with live data
        crimeBoard.innerHTML = `
          <div class="crime-card card-profile" id="main-profile-card">
            <div class="profile-card-avatar">${player.name.charAt(0).toUpperCase()}</div>
            <div class="profile-card-content">
              <div class="profile-card-name">${player.name}</div>
              <div class="profile-card-row">
                <span class="profile-card-label">Level ${player.level}</span>
                <span class="profile-card-value">${player.xp} XP</span>
              </div>
              <div class="profile-card-row">
                <span class="profile-card-label"> Cash</span>
                <span class="profile-card-value">$${player.cash.toLocaleString()}</span>
              </div>
              <div class="profile-card-row">
                <span class="profile-card-label"> Rep</span>
                <span class="profile-card-value">${player.reputation}</span>
              </div>
              <div class="profile-card-row">
                <span class="profile-card-label"> Heat</span>
                <span class="profile-card-value">${Math.round(player.heat)}%</span>
              </div>
            </div>
          </div>
          
          <div class="crime-card card-cash">
            <div class="crime-card-icon"></div>
            <div class="crime-card-label">Cash</div>
            <div class="crime-card-value">$${player.cash.toLocaleString()}</div>
          </div>
          
          <div class="crime-card card-xp">
            <div class="crime-card-icon"></div>
            <div class="crime-card-label">Level ${player.level}</div>
            <div class="crime-card-value">${player.xp} XP</div>
          </div>
          
          <div class="crime-card card-rep">
            <div class="crime-card-icon"></div>
            <div class="crime-card-label">Reputation</div>
            <div class="crime-card-value">${player.reputation}</div>
          </div>
          
          <div class="crime-card card-heat">
            <div class="crime-card-icon"></div>
            <div class="crime-card-label">Heat</div>
            <div class="crime-card-value">${Math.round(player.heat)}%</div>
          </div>
          
          <div class="crime-card">
            <div class="crime-card-icon"></div>
            <div class="crime-card-label">Global Heat</div>
            <div class="crime-card-value" style="color: #f28b82;">${Math.round(player.globalHeat)}%</div>
          </div>
          
          <div class="crime-card card-leaderboard" id="leaderboard-card">
            <div class="crime-card-icon"></div>
            <div class="crime-card-label">Leaderboard</div>
            <div class="crime-card-value">Top Players</div>
          </div>
          
          <div class="crime-card card-players-online" id="players-online-card">
            <div class="crime-card-icon"></div>
            <div class="crime-card-label">Players</div>
            <div class="crime-card-value">
              <span class="online-indicator"></span>
              <span>${Math.floor(Math.random() * 50) + 150} Online</span>
            </div>
          </div>
          
          <div class="crime-card card-stats" id="stats-card">
            <div class="crime-card-icon"></div>
            <div class="crime-card-label">Stats</div>
            <div class="crime-card-stats">
              <div class="crime-card-stat-row">
                <span class="crime-card-stat-label">STR</span>
                <span class="crime-card-stat-value">${player.stats.strength}</span>
              </div>
              <div class="crime-card-stat-row">
                <span class="crime-card-stat-label">INT</span>
                <span class="crime-card-stat-value">${player.stats.intelligence}</span>
              </div>
              <div class="crime-card-stat-row">
                <span class="crime-card-stat-label">CHA</span>
                <span class="crime-card-stat-value">${player.stats.charisma}</span>
              </div>
            </div>
          </div>
          
          <div class="crime-card card-heat-log" id="heat-log-card">
            <div class="crime-card-icon"></div>
            <div class="crime-card-label">Heat Log</div>
            <div class="crime-card-value">${GameState.heatLog.length} Events</div>
          </div>
          
          <div class="crime-card card-expense-log" id="expense-log-card">
            <div class="crime-card-icon"></div>
            <div class="crime-card-label">Expenses</div>
            <div class="crime-card-value">${GameState.drainLog.length} Transactions</div>
          </div>
        `;
        
        // Add tap feedback (visual only)
        crimeBoard.querySelectorAll('.crime-card').forEach(card => {
          card.addEventListener('touchstart', () => {
            card.style.transform = card.style.transform.replace('scale(1)', 'scale(0.98)');
          }, { passive: true });
          
          card.addEventListener('touchend', () => {
            setTimeout(() => {
              card.style.transform = '';
            }, 100);
          }, { passive: true });
        });
        
        // Main profile card - opens existing stat-grid on tap
        const mainProfileCard = document.getElementById('main-profile-card');
        if (mainProfileCard) {
          mainProfileCard.addEventListener('click', () => {
            // Scroll to the existing stat-grid section
            const statGrid = document.querySelector('.stat-grid');
            if (statGrid) {
              statGrid.scrollIntoView({ behavior: 'smooth', block: 'start' });
              
              // Brief highlight effect
              statGrid.style.transition = 'background 0.3s ease';
              statGrid.style.background = 'rgba(138, 180, 248, 0.1)';
              setTimeout(() => {
                statGrid.style.background = '';
              }, 600);
            }
          });
        }
        
        // Leaderboard card - opens placeholder modal
        const leaderboardCard = document.getElementById('leaderboard-card');
        if (leaderboardCard) {
          leaderboardCard.addEventListener('click', () => {
            this.showLeaderboardModal();
          });
        }
        
        // Players Online card - opens players modal
        const playersOnlineCard = document.getElementById('players-online-card');
        if (playersOnlineCard) {
          playersOnlineCard.addEventListener('click', () => {
            this.showPlayersOnlineModal();
          });
        }
        
        // Stats card - scrolls to existing stat grid
        const statsCard = document.getElementById('stats-card');
        if (statsCard) {
          statsCard.addEventListener('click', () => {
            const statGrid = document.querySelector('.stat-grid');
            if (statGrid) {
              statGrid.scrollIntoView({ behavior: 'smooth', block: 'start' });
              
              // Brief highlight effect
              statGrid.style.transition = 'background 0.3s ease';
              statGrid.style.background = 'rgba(138, 180, 248, 0.1)';
              setTimeout(() => {
                statGrid.style.background = '';
              }, 600);
            }
          });
        }
        
        // Heat Log card - scrolls to existing heat log section
        const heatLogCard = document.getElementById('heat-log-card');
        if (heatLogCard) {
          heatLogCard.addEventListener('click', () => {
            const heatLogSection = document.getElementById('heat-log-section');
            if (heatLogSection) {
              heatLogSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
              
              // Brief highlight effect
              heatLogSection.style.transition = 'background 0.3s ease';
              heatLogSection.style.background = 'rgba(242, 139, 130, 0.1)';
              setTimeout(() => {
                heatLogSection.style.background = '';
              }, 600);
            }
          });
        }
        
        // Expense Log card - scrolls to existing expense log section
        const expenseLogCard = document.getElementById('expense-log-card');
        if (expenseLogCard) {
          expenseLogCard.addEventListener('click', () => {
            const drainLogSection = document.getElementById('drain-log-section');
            if (drainLogSection) {
              drainLogSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
              
              // Brief highlight effect
              drainLogSection.style.transition = 'background 0.3s ease';
              drainLogSection.style.background = 'rgba(242, 139, 130, 0.1)';
              setTimeout(() => {
                drainLogSection.style.background = '';
              }, 600);
            }
          });
        }
      },
      
      async showPlayersOnlineModal() {
        if (!database) {
          console.error('Firebase not initialized');
          return;
        }
        
        // Create modal
        const modal = document.createElement('div');
        modal.className = 'event-modal';
        modal.id = 'players-online-modal';
        
        modal.innerHTML = `
          <div class="event-modal-content">
            <div class="event-modal-icon"></div>
            <div class="event-modal-title">All Players</div>
            <div class="event-modal-description">
              Loading player activity...
            </div>
            
            <div id="players-list-container" style="margin: 20px 0; padding: 16px; background: #0a0a0a; border: 1px solid #2a2a2a; border-radius: 4px; max-height: 400px; overflow-y: auto;">
              <div style="text-align: center; padding: 20px;">
                <div style="font-size: 32px; margin-bottom: 8px;"></div>
                <div style="opacity: 0.7;">Loading players...</div>
              </div>
            </div>
            
            <button class="outcome-btn" id="close-players-modal">Close</button>
          </div>
        `;
        
        document.getElementById('app').appendChild(modal);
        
        // Close button
        document.getElementById('close-players-modal')?.addEventListener('click', () => {
          modal.remove();
        });
        
        // Fetch real player data from Firebase
        try {
          const leaderboardRef = database.ref('leaderboard');
          const snapshot = await leaderboardRef.once('value');
          const players = snapshot.val();
          
          if (!players) {
            this.showNoPlayersMessage();
            return;
          }
          
          // Convert to array and add online status
          const now = Date.now();
          const ONLINE_THRESHOLD = 5 * 60 * 1000; // 5 minutes
          
          const playerArray = Object.values(players).map(player => {
            const lastActive = player.lastUpdated || 0;
            const timeSinceActive = now - lastActive;
            const isOnline = timeSinceActive < ONLINE_THRESHOLD;
            
            return {
              ...player,
              isOnline,
              timeSinceActive,
              lastActiveText: this.getLastActiveText(timeSinceActive)
            };
          });
          
          // Sort: Online first, then by reputation
          playerArray.sort((a, b) => {
            if (a.isOnline !== b.isOnline) return b.isOnline - a.isOnline;
            return b.reputation - a.reputation;
          });
          
          this.renderPlayersList(playerArray);
          
        } catch (error) {
          console.error('Failed to load players:', error);
          this.showErrorMessage();
        }
      },
      
      getLastActiveText(ms) {
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);
        
        if (seconds < 60) return 'Just now';
        if (minutes < 60) return `${minutes}m ago`;
        if (hours < 24) return `${hours}h ago`;
        return `${days}d ago`;
      },
      
      renderPlayersList(players) {
        const container = document.getElementById('players-list-container');
        if (!container) return;
        
        const currentAccountId = GameState.accountId;
        const onlineCount = players.filter(p => p.isOnline).length;
        const offlineCount = players.length - onlineCount;
        
        // Update description
        const description = document.querySelector('#players-online-modal .event-modal-description');
        if (description) {
          description.innerHTML = `
            <span style="color: #81c995;"> ${onlineCount} online</span>  
            <span style="opacity: 0.6;"> ${offlineCount} offline</span>
          `;
        }
        
        let html = '<div style="display: flex; flex-direction: column; gap: 8px;">';
        
        players.forEach(player => {
          const isCurrentPlayer = player.accountId === currentAccountId;
          const statusColor = player.isOnline ? '#81c995' : '#4a4a4a';
          const statusIcon = player.isOnline ? '' : '';
          const statusText = player.isOnline ? 'Online' : player.lastActiveText;
          const opacity = player.isOnline ? '1' : '0.5';
          
          // Heat level color (gradient from green to red)
          const heatLevel = player.heat || 0;
          let heatColor = '#81c995'; // Low heat (green)
          if (heatLevel > 60) heatColor = '#f28b82'; // High heat (red)
          else if (heatLevel > 30) heatColor = '#fdd663'; // Medium heat (yellow)
          
          // Player status emoji
          const playerStatusEmoji = player.status === 'active' ? '' : '';
          
          html += `
            <div class="player-card-item" data-player-id="${player.accountId}" style="
              display: flex; 
              justify-content: space-between; 
              align-items: center; 
              padding: 10px; 
              background: ${player.isOnline ? 'rgba(129, 201, 149, 0.1)' : 'rgba(74, 74, 74, 0.1)'}; 
              border-left: 3px solid ${statusColor}; 
              border-radius: 4px;
              opacity: ${opacity};
              cursor: pointer;
              transition: all 0.2s;
              ${isCurrentPlayer ? 'box-shadow: 0 0 12px rgba(138, 180, 248, 0.3); border: 2px solid #8ab4f8;' : ''}
            ">
              <div style="display: flex; align-items: center; gap: 12px; flex: 1;">
                <span style="font-size: 20px;">${statusIcon}</span>
                <div style="flex: 1;">
                  <div style="font-size: 14px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                    ${player.username}
                    ${isCurrentPlayer ? '<span style="font-size: 9px; padding: 2px 6px; background: #8ab4f8; color: #0a0a0a; border-radius: 3px; font-weight: 700;">YOU</span>' : ''}
                    <span style="font-size: 12px; opacity: 0.8;" title="${player.status === 'active' ? 'Active' : 'Laying Low'}">${playerStatusEmoji}</span>
                  </div>
                  <div style="font-size: 11px; opacity: 0.7; display: flex; gap: 12px; margin-top: 4px;">
                    <span> Lvl ${player.level}</span>
                    <span> ${player.cash.toLocaleString()}</span>
                    <span> ${player.reputation}</span>
                  </div>
                  <div style="font-size: 11px; opacity: 0.8; display: flex; gap: 12px; margin-top: 4px;">
                    <span style="color: ${heatColor};" title="Heat Level"> ${heatLevel}%</span>
                    <span title="Last Known Location"> ${player.lastKnownZone || 'Unknown'}</span>
                  </div>
                </div>
              </div>
              <div style="text-align: right;">
                <div style="font-size: 11px; opacity: 0.7;">${statusText}</div>
              </div>
            </div>
          `;
        });
        
        html += '</div>';
        
        container.innerHTML = html;
        
        // Add click listeners to player cards
        container.querySelectorAll('.player-card-item').forEach(card => {
          card.addEventListener('click', () => {
            const playerId = card.dataset.playerId;
            this.showPlayerProfile(playerId);
          });
          
          card.addEventListener('mouseenter', () => {
            card.style.background = 'rgba(138, 180, 248, 0.2)';
          });
          
          card.addEventListener('mouseleave', () => {
            const player = players.find(p => p.accountId === card.dataset.playerId);
            if (player) {
              card.style.background = player.isOnline ? 'rgba(129, 201, 149, 0.1)' : 'rgba(74, 74, 74, 0.1)';
            }
          });
        });
      },
      
      // Show player profile modal
      showPlayerProfile(playerId) {
        // Get player from cached leaderboard
        const leaderboard = GlobalLeaderboard.cachedLeaderboard;
        const player = leaderboard.find(p => p.accountId === playerId);
        
        if (!player) {
          console.error('Player not found:', playerId);
          return;
        }
        
        const isCurrentPlayer = playerId === GameState.accountId;
        const now = Date.now();
        const ONLINE_THRESHOLD = 5 * 60 * 1000;
        const isOnline = (now - player.lastUpdated) < ONLINE_THRESHOLD;
        
        const modal = document.createElement('div');
        modal.className = 'player-profile-modal';
        modal.id = 'player-profile-modal';
        
        // Heat color
        const heatLevel = player.heat || 0;
        let heatColor = '#81c995';
        if (heatLevel > 60) heatColor = '#f28b82';
        else if (heatLevel > 30) heatColor = '#fdd663';
        
        modal.innerHTML = `
          <div class="player-profile-content">
            <div class="player-profile-header">
              <div class="player-profile-avatar">${player.username.charAt(0).toUpperCase()}</div>
              <div class="player-profile-username">
                ${player.username}
                ${isCurrentPlayer ? '<span style="font-size: 10px; padding: 2px 6px; background: #8ab4f8; color: #0a0a0a; border-radius: 3px; margin-left: 8px;">YOU</span>' : ''}
              </div>
              <div class="player-profile-status">
                <span>${isOnline ? '' : ''}</span>
                <span>${isOnline ? 'Online' : 'Offline'}</span>
                <span></span>
                <span>${player.status === 'active' ? ' Active' : ' Laying Low'}</span>
              </div>
            </div>
            
            <div class="player-profile-stats">
              <div class="player-profile-stat">
                <div class="player-profile-stat-label">Level</div>
                <div class="player-profile-stat-value"> ${player.level}</div>
              </div>
              <div class="player-profile-stat">
                <div class="player-profile-stat-label">Cash</div>
                <div class="player-profile-stat-value"> ${player.cash.toLocaleString()}</div>
              </div>
              <div class="player-profile-stat">
                <div class="player-profile-stat-label">Reputation</div>
                <div class="player-profile-stat-value"> ${player.reputation}</div>
              </div>
              <div class="player-profile-stat">
                <div class="player-profile-stat-label">Heat</div>
                <div class="player-profile-stat-value" style="color: ${heatColor};"> ${heatLevel}%</div>
              </div>
              <div class="player-profile-stat" style="grid-column: span 2;">
                <div class="player-profile-stat-label">Last Known Location</div>
                <div class="player-profile-stat-value"> ${player.lastKnownZone || 'Unknown'}</div>
              </div>
            </div>
            
            <div class="player-profile-actions">
              ${!isCurrentPlayer ? `
                <button class="player-action-btn primary" id="message-player-btn">
                  <span></span>
                  <span>Send Message</span>
                </button>
                <button class="player-action-btn" id="challenge-player-btn">
                  <span></span>
                  <span>Send Challenge</span>
                </button>
              ` : ''}
              <button class="player-action-btn" id="close-profile-btn">
                <span></span>
                <span>Close</span>
              </button>
            </div>
          </div>
        `;
        
        document.getElementById('app').appendChild(modal);
        
        // Event listeners
        document.getElementById('close-profile-btn')?.addEventListener('click', () => {
          modal.remove();
        });
        
        if (!isCurrentPlayer) {
          document.getElementById('message-player-btn')?.addEventListener('click', () => {
            modal.remove();
            ChatSystem.openChat(playerId);
          });
          
          document.getElementById('challenge-player-btn')?.addEventListener('click', () => {
            modal.remove();
            this.sendChallenge(player);
          });
        }
        
        // Close on background click
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            modal.remove();
          }
        });
      },
      
      // Send challenge (placeholder)
      sendChallenge(player) {
        const notification = document.createElement('div');
        notification.className = 'xp-notification';
        notification.innerHTML = `<span class="xp-positive"> Challenge sent to ${player.username}!</span>`;
        document.getElementById('app').appendChild(notification);
        setTimeout(() => notification.remove(), 3000);
        
        console.log('Challenge sent to:', player.username);
        // TODO: Implement challenge system
      },
      
      showNoPlayersMessage() {
        const container = document.getElementById('players-list-container');
        if (!container) return;
        
        container.innerHTML = `
          <div style="text-align: center; padding: 40px 20px;">
            <div style="font-size: 48px; margin-bottom: 16px; opacity: 0.5;"></div>
            <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">No Players Yet</div>
            <div style="font-size: 13px; opacity: 0.7;">Be the first to build your criminal empire!</div>
          </div>
        `;
      },
      
      showErrorMessage() {
        const container = document.getElementById('players-list-container');
        if (!container) return;
        
        container.innerHTML = `
          <div style="text-align: center; padding: 40px 20px;">
            <div style="font-size: 48px; margin-bottom: 16px;"></div>
            <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Failed to Load</div>
            <div style="font-size: 13px; opacity: 0.7;">Could not connect to player database</div>
          </div>
        `;
      },
      
      showLeaderboardModal() {
        // Initialize Firebase listener if not already listening
        GlobalLeaderboard.initFirebaseListener();
        
        // Create modal
        const modal = document.createElement('div');
        modal.className = 'event-modal';
        modal.id = 'leaderboard-modal';
        
        document.getElementById('app').appendChild(modal);
        
        // Render real leaderboard
        GlobalLeaderboard.renderLeaderboard();
      },
      
      renderLogoutButton() {
        // Check if button already exists
        if (document.getElementById('logout-btn')) return;
        
        const profileHeader = document.querySelector('#profile-tab .page-header');
        if (!profileHeader) return;
        
        // Create button container
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
          position: absolute;
          top: 12px;
          right: 12px;
          display: flex;
          gap: 8px;
        `;
        
        // Chat button
        const chatBtn = document.createElement('button');
        chatBtn.id = 'chat-tab-btn';
        chatBtn.innerHTML = '';
        chatBtn.title = 'Chat';
        chatBtn.style.cssText = `
          background: transparent;
          border: 1px solid #2a2a2a;
          color: #e0e0e0;
          font-size: 18px;
          padding: 8px 12px;
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s;
          min-width: 44px;
          min-height: 44px;
          display: flex;
          align-items: center;
          justify-content: center;
        `;
        
        chatBtn.addEventListener('click', () => {
          ChatSystem.openChat(); // Open global chat
        });
        
        // Logout button
        const logoutBtn = document.createElement('button');
        logoutBtn.id = 'logout-btn';
        logoutBtn.innerHTML = '';
        logoutBtn.title = 'Logout';
        logoutBtn.style.cssText = `
          background: transparent;
          border: 1px solid #2a2a2a;
          color: #e0e0e0;
          font-size: 18px;
          padding: 8px 12px;
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s;
          min-width: 44px;
          min-height: 44px;
          display: flex;
          align-items: center;
          justify-content: center;
        `;
        
        logoutBtn.addEventListener('click', () => {
          AuthManager.logout();
        });
        
        buttonContainer.appendChild(chatBtn);
        buttonContainer.appendChild(logoutBtn);
        
        profileHeader.style.position = 'relative';
        profileHeader.appendChild(buttonContainer);
        
        // Start listening for messages
        ChatSystem.startListeningForMessages();
      },
      
      renderHeatLog() {
        const existingLog = document.getElementById('heat-log-section');
        if (existingLog) existingLog.remove();
        
        if (GameState.heatLog.length === 0) return;
        
        const profileContent = document.getElementById('profile-tab');
        if (!profileContent) return;
        
        const recentLogs = GameState.heatLog.slice(-10).reverse();
        
        const logSection = document.createElement('div');
        logSection.id = 'heat-log-section';
        logSection.className = 'heat-log-section';
        logSection.style.marginTop = '40px'; // Add spacing from Crime Board
        logSection.innerHTML = `
          <div class="gang-section-title">Heat Log</div>
          <div class="heat-log-list">
            ${recentLogs.map(log => `
              <div class="heat-log-entry">
                <div class="heat-log-message">
                  ${log.message}
                  <div class="heat-log-timestamp">${new Date(log.timestamp).toLocaleString()}</div>
                </div>
                <div class="heat-log-value">+${log.heatGain}%</div>
              </div>
            `).join('')}
          </div>
        `;
        
        profileContent.appendChild(logSection);
      },
      
      renderDrainLog() {
        const existingLog = document.getElementById('drain-log-section');
        if (existingLog) existingLog.remove();
        
        if (GameState.drainLog.length === 0) return;
        
        const profileContent = document.getElementById('profile-tab');
        if (!profileContent) return;
        
        const recentLogs = GameState.drainLog.slice(-10).reverse();
        
        const logSection = document.createElement('div');
        logSection.id = 'drain-log-section';
        logSection.className = 'heat-log-section';
        logSection.style.marginTop = '20px'; // Spacing between logs
        logSection.innerHTML = `
          <div class="gang-section-title">Expenses Log</div>
          <div class="heat-log-list">
            ${recentLogs.map(log => `
              <div class="heat-log-entry">
                <div class="heat-log-message">
                  ${log.reason}
                  <div class="heat-log-timestamp">${new Date(log.timestamp).toLocaleString()}</div>
                </div>
                <div class="heat-log-value" style="color: #f28b82;">-$${log.amount}</div>
              </div>
            `).join('')}
          </div>
        `;
        
        profileContent.appendChild(logSection);
      }
    };

    const TurfTab = {
      roamInterval: null,
      eventInterval: null,
      heatDecayInterval: null,
      jailCheckInterval: null,
      globalHeatDecayInterval: null,
      lockdownCheckInterval: null,
      manhuntCheckInterval: null,
      transitionCheckInterval: null,
      suspicionBuildInterval: null,
      suspicionDecayInterval: null,
      suspicionCheckInterval: null,
      worldTickInterval: null,
      moneyDrainInterval: null,
      
      init() {
        // Initialize status button listeners
        const statusButtons = document.querySelectorAll('.status-btn');
        statusButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            this.setPlayerStatus(btn.dataset.status);
          });
        });
        
        // Initialize free roam toggle
        const roamBtn = document.getElementById('roam-toggle-btn');
        if (roamBtn) {
          roamBtn.addEventListener('click', () => {
            this.toggleFreeRoam();
          });
        }
        
        // Initialize map refresh button
        const refreshBtn = document.getElementById('map-refresh-btn');
        if (refreshBtn) {
          refreshBtn.addEventListener('click', () => {
            this.regenerateMap();
          });
        }
        
        // Start heat decay system
        this.startHeatDecay();
        
        // Start jail check system
        this.startJailCheck();
        
        // Start global heat systems
        this.startGlobalHeatDecay();
        this.startLockdownCheck();
        this.startManhuntCheck();
        
        // Start transition check system
        this.startTransitionCheck();
        
        // Start suspicion systems
        this.startSuspicionBuild();
        this.startSuspicionDecay();
        this.startSuspicionCheck();
        
        // Start world tick system
        this.startWorldTick();
        
        // Start money drain system
        this.startMoneyDrain();
        
        // Render global heat display
        this.renderGlobalHeatDisplay();
        
        // Check for active lockdown/manhunt on init
        if (GameState.cityState.lockdown) {
          this.showLockdownState();
        }
        
        // Check for ongoing transition on init
        if (GameState.playerStatusTransition && GameState.playerStatusTransitionEnd) {
          if (Date.now() < GameState.playerStatusTransitionEnd) {
            this.showTransitionIndicator();
          } else {
            // Transition should have completed - complete it now
            this.completeTransition();
          }
        }
        
        // Update suspicion eye indicator
        this.updateSuspicionEye();
        
        // Update risk-based icon brightness
        this.updateIconRiskLevels();
      },
      
      toggleFreeRoam() {
        if (GameState.character.isDead || GameState.player.jail.isJailed || GameState.cityState.lockdown) {
          if (GameState.cityState.lockdown) {
            this.showTemporaryNotification(" City is in lockdown! Free roam disabled.");
          }
          return;
        }
        
        GameState.character.freeRoam = !GameState.character.freeRoam;
        this.updateRoamButton();
        
        if (GameState.character.freeRoam) {
          this.startFreeRoam();
        } else {
          this.stopFreeRoam();
        }
        
        Storage.save();
        console.log(`Free roam: ${GameState.character.freeRoam ? 'ON' : 'OFF'}`);
      },
      
      updateRoamButton() {
        const btn = document.getElementById('roam-toggle-btn');
        const icon = document.getElementById('roam-icon');
        const label = document.getElementById('roam-label');
        
        if (!btn || !icon || !label) return;
        
        const isRoaming = GameState.character.freeRoam;
        btn.classList.toggle('active', isRoaming);
        icon.textContent = isRoaming ? '' : '';
        label.textContent = isRoaming ? 'Stop Roaming' : 'Start Free Roam';
      },
      
      startFreeRoam() {
        // Move character every 2 seconds
        this.roamInterval = setInterval(() => {
          this.moveCharacter();
          this.maybeSpawnPickup();
        }, 2000);
        
        // Random events every 5-10 seconds
        this.scheduleNextEvent();
        
        console.log('Free roam started');
      },
      
      stopFreeRoam() {
        if (this.roamInterval) {
          clearInterval(this.roamInterval);
          this.roamInterval = null;
        }
        if (this.eventInterval) {
          clearTimeout(this.eventInterval);
          this.eventInterval = null;
        }
        
        console.log('Free roam stopped');
      },
      
      regenerateMap() {
        console.log('=== REGENERATING MAP ===');
        
        // Show spinning animation
        const refreshBtn = document.getElementById('map-refresh-btn');
        if (refreshBtn) {
          refreshBtn.classList.add('spinning');
          setTimeout(() => refreshBtn.classList.remove('spinning'), 500);
        }
        
        // Stop free roam if active
        if (GameState.character.freeRoam) {
          this.stopFreeRoam();
          GameState.character.freeRoam = false;
          this.updateRoamButton();
        }
        
        // Generate a new random seed
        GameState.map.seed = Date.now() + Math.floor(Math.random() * 1000000);
        console.log('New map seed:', GameState.map.seed);
        
        // Clear existing map data
        GameState.map.grid = null;
        GameState.map.buildings = [];
        GameState.map.biomeCenters = null;
        GameState.mapIcons = [];
        
        // Clear tile occupancy grid
        TileOccupancy.clear();
        
        // Reset the renderer flag
        ProceduralMapRenderer.rendered = false;
        
        // Re-initialize procedural map (this also initializes TileOccupancy)
        initProceduralMap();
        
        // Re-initialize landmarks
        initProceduralLandmarks();
        
        // Re-initialize roads and buildings
        initRoadsAndBuildings();
        
        // Apply enhanced landmark placement
        initEnhancedProceduralLandmarks();
        
        // Re-render the map
        ProceduralMapRenderer.renderMap();
        
        // Re-render map icons
        this.renderIcons();
        
        // Re-render buildings
        InteractiveBuildings.renderBuildings();
        
        // Reset character to safe house position
        const safeHouse = GameState.mapIcons.find(i => i.type === 'safeHouse');
        if (safeHouse) {
          GameState.character.position = { x: safeHouse.x, y: safeHouse.y };
        }
        this.renderCharacter();
        
        // Save the new map
        Storage.save();
        
        // Show notification
        this.showTemporaryNotification(' Map regenerated!');
        
        console.log('=== MAP REGENERATION COMPLETE ===');
      },
      
      moveCharacter() {
        if (!GameState.character.freeRoam || GameState.character.isDead) return;
        
        const pos = GameState.character.position;
        
        // Small random movement (-3 to +3 units)
        const dx = (Math.random() - 0.5) * 6;
        const dy = (Math.random() - 0.5) * 6;
        
        // Keep within bounds (10% to 90%)
        pos.x = Math.max(10, Math.min(90, pos.x + dx));
        pos.y = Math.max(10, Math.min(90, pos.y + dy));
        
        // Add small fatigue for free roaming
        FatigueSystem.addFatigue('freeRoam', 'movement');
        
        this.renderCharacter();
        Storage.save();
      },
      
      maybeSpawnPickup() {
        // 30% chance to spawn visual pickup
        if (Math.random() > 0.3) return;
        
        const pos = GameState.character.position;
        const type = Math.random() > 0.5 ? '' : '';
        
        this.spawnFloatingPickup(type, pos.x, pos.y);
      },
      
      spawnFloatingPickup(icon, x, y) {
        const container = document.getElementById('floating-pickups');
        if (!container) return;
        
        const pickup = document.createElement('div');
        pickup.className = 'floating-pickup';
        pickup.textContent = icon;
        pickup.style.left = `${x}%`;
        pickup.style.top = `${y}%`;
        
        container.appendChild(pickup);
        
        // Remove after animation
        setTimeout(() => pickup.remove(), 2000);
      },
      
      scheduleNextEvent() {
        if (!GameState.character.freeRoam) return;
        
        // Random delay 5-10 seconds
        const delay = 5000 + Math.random() * 5000;
        
        this.eventInterval = setTimeout(() => {
          this.triggerRandomEvent();
          this.scheduleNextEvent(); // Schedule next
        }, delay);
      },
      
      triggerRandomEvent() {
        if (!GameState.character.freeRoam || GameState.character.isDead) return;
        
        // Check area risk at current position
        const pos = GameState.character.position;
        const areaRisk = MapMemory.getAreaRisk(pos.x, pos.y);
        
        // Higher area risk increases event frequency and severity
        const baseEventChance = 1.0;
        const riskMultiplier = 1 + (areaRisk / 100); // Up to 2x in hot areas
        
        // Only trigger if risk check passes
        if (Math.random() > baseEventChance * riskMultiplier) {
          this.scheduleNextEvent();
          return;
        }
        
        const events = [
          { 
            id: "police_chase",
            icon: "",
            title: "Police Chase",
            description: "Cops are on your tail! What do you do?",
            deadly: true
          },
          { 
            id: "rival_gang",
            icon: "",
            title: "Rival Gang",
            description: "You've walked into rival territory. They're approaching.",
            deadly: true
          },
          { 
            id: "witness",
            icon: "",
            title: "Witness Spotted",
            description: "Someone saw you at the wrong place. They're reaching for their phone.",
            deadly: false
          },
          { 
            id: "setup",
            icon: "",
            title: "It's a Setup!",
            description: "This deal doesn't feel right. Something's off.",
            deadly: true
          }
        ];
        
        const event = events[Math.floor(Math.random() * events.length)];
        
        // Pause free roam during event
        GameState.character.freeRoam = false;
        this.stopFreeRoam();
        this.updateRoamButton();
        
        // Show event modal
        this.showEventModal(event);
        
        // Log event
        GameState.ui.lastEvent = event;
        GameState.ui.eventLog.push({
          event: event.title,
          timestamp: Date.now(),
          position: { x: pos.x, y: pos.y }
        });
        
        Storage.save();
        
        console.log('Event triggered:', event.title, 'at', pos.x.toFixed(1), pos.y.toFixed(1), '- Area risk:', areaRisk.toFixed(1));
      },
      
      showEventModal(event) {
        // Create modal
        const modal = document.createElement('div');
        modal.className = 'event-modal';
        modal.id = 'event-modal';
        
        const choices = [
          { id: 'fight', icon: '', text: 'Fight', escapeChance: 0.4, injuryChance: 0.3, deathChance: 0.3 },
          { id: 'run', icon: '', text: 'Run & Hide', escapeChance: 0.6, injuryChance: 0.2, deathChance: 0.2 },
          { id: 'driver', icon: '', text: 'Call Driver', escapeChance: 0.7, injuryChance: 0.2, deathChance: 0.1 },
          { id: 'mercs', icon: '', text: 'Call Mercenaries', escapeChance: 0.8, injuryChance: 0.1, deathChance: 0.1 }
        ];
        
        let choicesHtml = '';
        choices.forEach(choice => {
          choicesHtml += `
            <button class="choice-btn" data-choice="${choice.id}" 
                    data-escape="${choice.escapeChance}"
                    data-injury="${choice.injuryChance}"
                    data-death="${choice.deathChance}">
              <span class="choice-icon">${choice.icon}</span>
              <span class="choice-text">${choice.text}</span>
            </button>
          `;
        });
        
        modal.innerHTML = `
          <div class="event-modal-content">
            <div class="event-modal-icon">${event.icon}</div>
            <div class="event-modal-title">${event.title}</div>
            <div class="event-modal-description">${event.description}</div>
            <div class="event-choices">
              ${choicesHtml}
            </div>
          </div>
        `;
        
        document.getElementById('app').appendChild(modal);
        
        // Add choice handlers
        const choiceBtns = modal.querySelectorAll('.choice-btn');
        choiceBtns.forEach(btn => {
          btn.addEventListener('click', () => {
            const escapeChance = parseFloat(btn.dataset.escape);
            const injuryChance = parseFloat(btn.dataset.injury);
            const deathChance = parseFloat(btn.dataset.death);
            const choiceId = btn.dataset.choice;
            
            this.resolveChoice(event, choiceId, escapeChance, injuryChance, deathChance);
          });
        });
      },
      
      resolveChoice(event, choiceId, escapeChance, injuryChance, deathChance) {
        // Record fatigue for this action
        FatigueSystem.addFatigue('event', event.title);
        
        // Get current position for map memory
        const pos = GameState.character.position;
        
        // PHASE 7.5: Apply zone modifiers
        const zoneEscapeModifier = ZoneAnalytics.getEscapeModifier(pos.x, pos.y);
        const zoneDifficultyModifier = ZoneAnalytics.getCrimeDifficultyModifier(pos.x, pos.y);
        
        console.log(`Zone modifiers - Escape: ${(zoneEscapeModifier * 100).toFixed(0)}%, Difficulty: ${(zoneDifficultyModifier * 100).toFixed(0)}%`);
        
        // Apply suspicion modifier to escape chance
        const suspicionModifier = this.getSuspicionModifier();
        
        // Apply fatigue penalty to success chance
        const fatiguePenalty = FatigueSystem.getSuccessPenalty();
        
        // Combined modifiers (now includes zone effects)
        const modifiedEscapeChance = (escapeChance * zoneEscapeModifier) * (1 - suspicionModifier) - fatiguePenalty;
        
        // Use fairness-adjusted RNG
        const escaped = RNGFairness.rollWithFairness(modifiedEscapeChance, 'event');
        
        let outcome;
        
        // Base rewards/penalties (modified by zone)
        const zoneRewardModifier = ZoneAnalytics.getRewardModifier(pos.x, pos.y);
        
        let cashChange = 0;
        let xpChange = 0;
        let heatChange = 0;
        
        if (escaped) {
          outcome = {
            type: 'escape',
            icon: '',
            title: 'Escaped!',
            description: 'You managed to get away safely. That was close.',
            colorClass: 'outcome-success'
          };
          cashChange = Math.floor((Math.random() * 100 + 50) * zoneRewardModifier); // Apply zone modifier
          xpChange = Math.floor(Math.random() * 20) + 10;
          heatChange = 5;
          
          // Risky action increases suspicion (affected by fatigue)
          const baseSuspicionGain = 3;
          const fatigueMultiplier = FatigueSystem.getSuspicionMultiplier();
          this.addSuspicion(baseSuspicionGain * fatigueMultiplier, "risky_event");
          
          // Create small hotspot at escape location
          MapMemory.createHotspot(pos.x, pos.y, 25, `Escaped ${event.title}`);
        } else {
          // Failed escape - determine severity
          const roll = Math.random();
          
          if (roll < injuryChance / (injuryChance + deathChance)) {
            outcome = {
              type: 'injured',
              icon: '',
              title: 'Injured',
              description: 'You escaped but took some damage. Be more careful.',
              colorClass: 'outcome-warning'
            };
            cashChange = Math.floor(Math.random() * 50) + 20; // $20-70
            xpChange = Math.floor(Math.random() * 10) + 5; // 5-15 XP
            heatChange = 10; // Moderate heat
            
            const baseSuspicionGain = 5;
            const fatigueMultiplier = FatigueSystem.getSuspicionMultiplier();
            this.addSuspicion(baseSuspicionGain * fatigueMultiplier, "risky_event");
            
            // Create medium hotspot
            MapMemory.createHotspot(pos.x, pos.y, 40, `Injured in ${event.title}`);
          } else if (roll < (injuryChance + deathChance * 0.5) / (injuryChance + deathChance)) {
            outcome = {
              type: 'death',
              icon: '',
              title: 'Killed',
              description: 'You didn\'t make it. The streets claimed another soul.',
              colorClass: 'outcome-danger'
            };
            cashChange = -Math.floor(GameState.player.cash * 0.1); // Lose 10% cash
            xpChange = -Math.floor(Math.random() * 20); // Lose 0-20 XP
            heatChange = -20; // Heat drops on death
            
            // Death resets some suspicion and some fatigue
            this.addSuspicion(-30, "death");
            GameState.player.fatigue.level = Math.max(0, GameState.player.fatigue.level - 30);
            
            // Create large hotspot at death location
            MapMemory.createHotspot(pos.x, pos.y, 70, `Death at ${event.title}`);
          } else {
            outcome = {
              type: 'caught',
              icon: '',
              title: 'Caught',
              description: 'The cops got you. Time to serve your sentence.',
              colorClass: 'outcome-danger'
            };
            cashChange = -Math.floor(Math.random() * 200) - 100; // Lose $100-300
            xpChange = 0;
            heatChange = -50; // Heat resets in jail
            
            // Being caught significantly reduces suspicion and fatigue (forced rest)
            this.addSuspicion(-40, "caught");
            GameState.player.fatigue.level = Math.max(0, GameState.player.fatigue.level - 50);
            
            // Create extreme hotspot at arrest location
            MapMemory.createHotspot(pos.x, pos.y, 90, `Arrested at ${event.title}`);
          }
        }
        
        // Apply changes
        this.applyEconomyChanges(cashChange, xpChange, heatChange);
        
        // Update map visuals
        MapMemory.visualizeHotspots();
        
        // Warn if fatigued
        if (FatigueSystem.shouldWarnPlayer()) {
          this.showTemporaryNotification(" You're feeling worn out. Maybe lay low for a bit...");
        }
        
        // Log outcome
        GameState.ui.lastOutcome = outcome;
        GameState.ui.eventLog[GameState.ui.eventLog.length - 1].outcome = outcome.type;
        GameState.ui.eventLog[GameState.ui.eventLog.length - 1].choice = choiceId;
        GameState.ui.eventLog[GameState.ui.eventLog.length - 1].cashChange = cashChange;
        GameState.ui.eventLog[GameState.ui.eventLog.length - 1].xpChange = xpChange;
        
        Storage.save();
        
        console.log(`Choice: ${choiceId}, Outcome: ${outcome.type}, Cash: ${cashChange}, XP: ${xpChange}, Heat: ${heatChange}, Suspicion modifier: ${(suspicionModifier * 100).toFixed(1)}%, Fatigue penalty: ${(fatiguePenalty * 100).toFixed(1)}%`);
        
        this.showOutcome(outcome);
      },
      
      getSuspicionModifier() {
        // Returns 0 to 0.3 (0% to 30% penalty)
        const suspicion = GameState.player.suspicion;
        if (suspicion < 30) return 0;
        if (suspicion < 60) return (suspicion - 30) / 100; // 0-0.3
        return Math.min(0.3, (suspicion - 30) / 100); // Cap at 30%
      },
      
      addSuspicion(amount, reason) {
        const oldSuspicion = GameState.player.suspicion;
        GameState.player.suspicion = Math.max(0, Math.min(100, GameState.player.suspicion + amount));
        
        if (amount !== 0) {
          console.log(`Suspicion ${amount > 0 ? '+' : ''}${amount}: ${reason} (${oldSuspicion.toFixed(1)}  ${GameState.player.suspicion.toFixed(1)})`);
        }
        
        // Update eye indicator
        this.updateSuspicionEye();
        
        Storage.save();
      },
      
      startSuspicionBuild() {
        // Build suspicion when active or free roaming
        this.suspicionBuildInterval = setInterval(() => {
          let buildAmount = 0;
          
          // Free roaming builds suspicion faster
          if (GameState.character.freeRoam) {
            buildAmount += 0.5; // +0.5% every 10 seconds
          }
          
          // Being active (not laying low) builds suspicion slowly
          if (GameState.playerStatus === 'active' && !GameState.playerStatusTransition) {
            buildAmount += 0.2; // +0.2% every 10 seconds
          }
          
          // High global heat increases suspicion buildup
          if (GameState.player.globalHeat > 60) {
            buildAmount += 0.3;
          }
          
          if (buildAmount > 0) {
            this.addSuspicion(buildAmount, "active_time");
          }
        }, 10000); // Every 10 seconds
      },
      
      startSuspicionDecay() {
        // Decay suspicion when laying low and idle
        this.suspicionDecayInterval = setInterval(() => {
          if (GameState.playerStatus === 'laying_low' && 
              !GameState.character.freeRoam && 
              !GameState.playerStatusTransition) {
            
            const decayAmount = 0.5; // -0.5% every 30 seconds
            this.addSuspicion(-decayAmount, "laying_low");
          }
        }, 30000); // Every 30 seconds
      },
      
      startSuspicionCheck() {
        // Check for detection threshold
        this.suspicionCheckInterval = setInterval(() => {
          const suspicion = GameState.player.suspicion;
          
          // Detection threshold at 80+
          if (suspicion >= 80) {
            // 20% chance per check when over threshold
            if (Math.random() < 0.2) {
              this.triggerDetection();
            }
          }
        }, 15000); // Check every 15 seconds
      },
      
      triggerDetection() {
        console.log('DETECTION TRIGGERED - Suspicion threshold exceeded');
        
        // Get current position
        const pos = GameState.character.position;
        
        // Show detection flash
        const flash = document.createElement('div');
        flash.className = 'detection-flash';
        document.getElementById('app').appendChild(flash);
        setTimeout(() => flash.remove(), 500);
        
        // Detection consequences
        const wasActive = GameState.playerStatus === 'active';
        const wasFreeRoaming = GameState.character.freeRoam;
        
        // Stop free roam
        if (wasFreeRoaming) {
          GameState.character.freeRoam = false;
          this.stopFreeRoam();
          this.updateRoamButton();
        }
        
        // Force laying low
        if (wasActive) {
          GameState.playerStatus = 'laying_low';
          this.updateStatusButtons();
          this.updateStatusIndicator();
        }
        
        // Add significant heat
        this.addGlobalHeat(15, " Detected by authorities");
        
        // Partial suspicion reset (not full)
        this.addSuspicion(-50, "detection_reset");
        
        // Create major hotspot at detection location
        MapMemory.createHotspot(pos.x, pos.y, 85, "Detection event");
        MapMemory.visualizeHotspots();
        
        // Record detection
        GameState.player.lastDetection = Date.now();
        
        // Show warning
        this.showTemporaryNotification(" DETECTED! Authorities are investigating. Stay hidden!");
        
        Storage.save();
      },
      
      updateSuspicionEye() {
        const eye = document.getElementById('suspicion-eye');
        if (!eye) return;
        
        const suspicion = GameState.player.suspicion;
        
        // Show eye when suspicion > 60
        if (suspicion > 60) {
          eye.classList.add('visible');
        } else {
          eye.classList.remove('visible');
        }
      },
      
      startWorldTick() {
        // World tick runs every 8 seconds
        this.worldTickInterval = setInterval(() => {
          GameState.cityState.worldTick++;
          
          // Decay RNG memory periodically
          RNGFairness.decayMemory();
          
          // Decay map hotspots
          MapMemory.decayHotspots();
          MapMemory.visualizeHotspots();
          
          // Risk escalates when active or free roaming
          let riskIncrease = 0;
          
          if (GameState.character.freeRoam) {
            riskIncrease += 3; // Fast escalation
          } else if (GameState.playerStatus === 'active' && !GameState.playerStatusTransition) {
            riskIncrease += 1; // Slow escalation
          }
          
          // Add risk
          if (riskIncrease > 0) {
            GameState.cityState.riskLevel = Math.min(100, GameState.cityState.riskLevel + riskIncrease);
            this.updateIconRiskLevels();
          }
          
          // Risk decays slowly when laying low
          if (GameState.playerStatus === 'laying_low' && !GameState.character.freeRoam && !GameState.playerStatusTransition) {
            const decay = 2; // Slower decay than buildup
            GameState.cityState.riskLevel = Math.max(0, GameState.cityState.riskLevel - decay);
            this.updateIconRiskLevels();
          }
          
          // Log significant risk changes
          if (riskIncrease > 0 || GameState.cityState.riskLevel % 20 === 0) {
            console.log(`World tick: ${GameState.cityState.worldTick}, Risk: ${GameState.cityState.riskLevel}%, Hotspots: ${GameState.mapMemory.hotspots.length}`);
          }
          
          Storage.save();
        }, 8000); // Every 8 seconds
      },
      
      updateIconRiskLevels() {
        const risk = GameState.cityState.riskLevel;
        
        // Determine risk class
        let riskClass = 'risk-low';
        if (risk >= 75) riskClass = 'risk-extreme';
        else if (risk >= 50) riskClass = 'risk-high';
        else if (risk >= 25) riskClass = 'risk-medium';
        
        // Update police, dealer, and gang icons
        const riskIcons = document.querySelectorAll('.map-icon[data-type="police"], .map-icon[data-type="dealer"], .map-icon[data-type="gang"]');
        
        riskIcons.forEach(icon => {
          // Remove all risk classes
          icon.classList.remove('risk-low', 'risk-medium', 'risk-high', 'risk-extreme');
          // Add current risk class
          icon.classList.add(riskClass);
        });
      },
      
      startMoneyDrain() {
        // Check for drains every 2 minutes
        this.moneyDrainInterval = setInterval(() => {
          this.processDrains();
        }, 120000); // Every 2 minutes
      },
      
      processDrains() {
        let totalDrain = 0;
        const drains = [];
        
        // 1. Safe House Upkeep (base cost)
        const upkeepCost = 10; // Small base cost
        totalDrain += upkeepCost;
        drains.push({ reason: "Safe house upkeep", amount: upkeepCost });
        
        // 2. Medical Bills (if injured recently - placeholder)
        // Only charge if player has taken damage in events (we don't track health yet)
        // Skip for now
        
        // 3. Heat Bribes (scales with global heat)
        if (GameState.player.globalHeat > 40) {
          const heatBribe = Math.floor((GameState.player.globalHeat - 40) / 10) * 5; // $5 per 10% above 40%
          if (heatBribe > 0) {
            totalDrain += heatBribe;
            drains.push({ reason: "Heat management bribes", amount: heatBribe });
          }
        }
        
        // 4. Gang Costs (if in a gang with low vault)
        if (GameState.gang && GameState.gang.vault < 500) {
          const gangSupport = 15;
          totalDrain += gangSupport;
          drains.push({ reason: "Gang support costs", amount: gangSupport });
        }
        
        // 5. High Reputation Costs (target on your back)
        if (GameState.player.reputation > 50) {
          const repCost = Math.floor((GameState.player.reputation - 50) / 20) * 10; // $10 per 20 rep above 50
          if (repCost > 0) {
            totalDrain += repCost;
            drains.push({ reason: "Security expenses", amount: repCost });
          }
        }
        
        // Apply total drain (never go below zero)
        if (totalDrain > 0 && GameState.player.cash > 0) {
          const actualDrain = Math.min(totalDrain, GameState.player.cash);
          GameState.player.cash -= actualDrain;
          
          // Log each drain
          drains.forEach(drain => {
            const scaledAmount = Math.floor(drain.amount * (actualDrain / totalDrain));
            if (scaledAmount > 0) {
              this.logDrain(drain.reason, scaledAmount);
            }
          });
          
          // Update profile
          ProfileTab.render();
          
          // Subtle notification (only if significant)
          if (actualDrain >= 50) {
            this.showTemporaryNotification(` Expenses: -$${actualDrain}`);
          }
          
          Storage.save();
          
          console.log(`Money drains applied: -$${actualDrain} (${drains.map(d => d.reason).join(', ')})`);
        }
      },
      
      logDrain(reason, amount) {
        GameState.drainLog.push({
          reason: reason,
          amount: amount,
          timestamp: Date.now()
        });
        
        // Keep only last 20 drains
        if (GameState.drainLog.length > 20) {
          GameState.drainLog = GameState.drainLog.slice(-20);
        }
      },
      
      applyEconomyChanges(cashChange, xpChange, heatChange) {
        // Apply cash change
        GameState.player.cash = Math.max(0, GameState.player.cash + cashChange);
        
        // Apply XP change
        GameState.player.xp = Math.max(0, GameState.player.xp + xpChange);
        
        // Apply heat change
        GameState.player.heat = Math.max(0, Math.min(100, GameState.player.heat + heatChange));
        
        // Apply to global heat (50% of personal heat)
        const globalHeatChange = Math.floor(heatChange * 0.5);
        this.addGlobalHeat(globalHeatChange, "Event outcome");
        
        // Update UI
        this.updateHeatIndicator();
        this.updateGlobalHeatDisplay();
        ProfileTab.render();
        
        // Show notification
        if (cashChange !== 0 || xpChange !== 0) {
          this.showEconomyNotification(cashChange, xpChange);
        }
        
        Storage.save();
        
        // Sync to leaderboard after economy changes
        Storage.updateLeaderboard();
      },
      
      showEconomyNotification(cashChange, xpChange) {
        const notification = document.createElement('div');
        notification.className = 'xp-notification';
        
        let text = '';
        if (cashChange > 0) text += `+$${cashChange} `;
        if (cashChange < 0) text += `-$${Math.abs(cashChange)} `;
        if (xpChange > 0) text += `+${xpChange} XP`;
        if (xpChange < 0) text += `${xpChange} XP`;
        
        notification.innerHTML = `<span class="${cashChange >= 0 && xpChange >= 0 ? 'xp-positive' : 'xp-negative'}">${text}</span>`;
        
        document.getElementById('app').appendChild(notification);
        
        setTimeout(() => notification.remove(), 3000);
      },
      
      showOutcome(outcome) {
        const modal = document.getElementById('event-modal');
        if (!modal) return;
        
        const content = modal.querySelector('.event-modal-content');
        if (!content) return;
        
        let buttonText = 'Continue';
        let buttonAction = 'continue';
        
        if (outcome.type === 'death') {
          buttonText = 'Respawn at Hospital';
          buttonAction = 'respawn';
        } else if (outcome.type === 'caught') {
          buttonText = 'Go to Jail';
          buttonAction = 'jail';
        }
        
        content.innerHTML = `
          <div class="outcome-display">
            <div class="outcome-icon">${outcome.icon}</div>
            <div class="outcome-title ${outcome.colorClass}">${outcome.title}</div>
            <div class="outcome-description">${outcome.description}</div>
            <button class="outcome-btn" data-action="${buttonAction}">${buttonText}</button>
          </div>
        `;
        
        const btn = content.querySelector('.outcome-btn');
        if (btn) {
          btn.addEventListener('click', () => {
            this.handleOutcomeAction(outcome.type, buttonAction);
          });
        }
      },
      
      handleOutcomeAction(outcomeType, action) {
        const modal = document.getElementById('event-modal');
        if (modal) modal.remove();
        
        if (action === 'respawn') {
          // Death consequences already applied in resolveChoice
          // Now trigger respawn flow
          GameState.character.isDead = true;
          
          // Log death for player history
          GameState.player.history.push({
            type: 'death',
            timestamp: Date.now(),
            cause: GameState.ui.lastEvent?.title || 'Unknown'
          });
          
          this.respawn();
        } else if (action === 'jail') {
          // Jail duration scales with global heat (20-60 seconds)
          const baseJailTime = 20 * 1000; // 20 seconds base
          const heatMultiplier = 1 + (GameState.player.globalHeat / 100); // 1x to 2x
          const jailDuration = Math.floor(baseJailTime * heatMultiplier);
          
          GameState.player.jail.isJailed = true;
          GameState.player.jail.releaseTime = Date.now() + jailDuration;
          GameState.character.freeRoam = false;
          
          // Log arrest
          GameState.player.history.push({
            type: 'arrest',
            timestamp: Date.now(),
            duration: jailDuration,
            cause: GameState.ui.lastEvent?.title || 'Unknown'
          });
          
          this.updateRoamButton();
          this.showJailOverlay();
          Storage.save();
          
          console.log(`Sent to jail for ${Math.floor(jailDuration/1000)} seconds (heat: ${GameState.player.globalHeat.toFixed(1)}%)`);
        } else {
          // Continue - player retains control
          console.log('Event resolved - player can continue');
        }
      },
      
      showJailOverlay() {
        // Create overlay
        const overlay = document.createElement('div');
        overlay.className = 'jail-overlay';
        overlay.id = 'jail-overlay';
        
        const jailTime = Math.ceil((GameState.player.jail.releaseTime - Date.now()) / 1000);
        const minutes = Math.floor(jailTime / 60);
        const seconds = jailTime % 60;
        
        overlay.innerHTML = `
          <div class="jail-icon"></div>
          <div class="jail-title">Incarcerated</div>
          <div class="jail-message">
            Time to reflect. Your sentence: ${minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`}
            <br><br>
            <span style="opacity: 0.7; font-size: 12px;">
               While in jail: Heat cools down, fatigue recovers, but time is lost.
            </span>
          </div>
          <div class="jail-timer" id="jail-timer">${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}</div>
          <div class="jail-timer-label">Time Remaining</div>
        `;
        
        document.getElementById('app').appendChild(overlay);
        
        // Start countdown
        this.updateJailTimer();
      },
      
      updateJailTimer() {
        const timerEl = document.getElementById('jail-timer');
        if (!timerEl || !GameState.player.jail.isJailed) return;
        
        const remaining = Math.max(0, GameState.player.jail.releaseTime - Date.now());
        const seconds = Math.ceil(remaining / 1000);
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        
        timerEl.textContent = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
      },
      
      startJailCheck() {
        // Check jail status every second
        this.jailCheckInterval = setInterval(() => {
          if (GameState.player.jail.isJailed) {
            this.updateJailTimer();
            
            // Check if time to release
            if (Date.now() >= GameState.player.jail.releaseTime) {
              this.releaseFromJail();
            }
          }
        }, 1000);
      },
      
      releaseFromJail() {
        console.log('Released from jail');
        
        // Reset jail status
        GameState.player.jail.isJailed = false;
        GameState.player.jail.releaseTime = null;
        
        // Remove overlay
        const overlay = document.getElementById('jail-overlay');
        if (overlay) overlay.remove();
        
        // Move to safe location (either hospital or safe house)
        const safeLocations = GameState.mapIcons.filter(i => 
          i.type === 'hospital' || i.type === 'safeHouse'
        );
        const targetLocation = safeLocations[Math.floor(Math.random() * safeLocations.length)];
        
        if (targetLocation) {
          GameState.character.position = { x: targetLocation.x, y: targetLocation.y };
          
          // Log release
          GameState.player.history.push({
            type: 'release',
            timestamp: Date.now(),
            location: targetLocation.label || targetLocation.type
          });
        }
        
        // Show release notification with consequences summary
        this.showTemporaryNotification(" Released from custody. Heat has cooled, but you've lost time and reputation.");
        
        // Apply minor reputation loss for being caught
        if (GameState.player.reputation > 0) {
          const repLoss = Math.floor(Math.random() * 5) + 3; // 3-8 rep loss
          GameState.player.reputation = Math.max(0, GameState.player.reputation - repLoss);
          
          console.log(`Reputation penalty: -${repLoss} (now ${GameState.player.reputation})`);
        }
        
        this.renderCharacter();
        this.updateRoamButton();
        ProfileTab.render();
        Storage.save();
      },
      
      startHeatDecay() {
        // Decay heat every 5 seconds when laying low
        this.heatDecayInterval = setInterval(() => {
          // Only decay if fully in laying_low state (not transitioning)
          if (GameState.playerStatus === 'laying_low' && !GameState.character.freeRoam && !GameState.playerStatusTransition) {
            const decayAmount = 1; // Lose 1% heat every 5 seconds
            GameState.player.heat = Math.max(0, GameState.player.heat - decayAmount);
            
            // Recover fatigue when laying low and idle
            FatigueSystem.recoverFatigue('idle_laying_low');
            
            this.updateHeatIndicator();
            ProfileTab.render();
            Storage.save();
          } else if (GameState.playerStatus === 'laying_low' && !GameState.playerStatusTransition) {
            // Slower recovery when laying low but still moving
            FatigueSystem.recoverFatigue('laying_low');
            Storage.save();
          } else if (!GameState.character.freeRoam && GameState.playerStatus === 'active') {
            // Minimal recovery when active but idle
            FatigueSystem.recoverFatigue('idle');
            Storage.save();
          }
        }, 5000);
      },
      
      updateHeatIndicator() {
        const heatBar = document.getElementById('heat-bar-fill');
        const heatValue = document.getElementById('heat-value');
        
        if (heatBar) {
          heatBar.style.width = `${GameState.player.heat}%`;
        }
        
        if (heatValue) {
          heatValue.textContent = `${Math.round(GameState.player.heat)}%`;
        }
      },
      
      addGlobalHeat(amount, reason) {
        if (amount <= 0) return;
        
        GameState.player.globalHeat = Math.min(100, GameState.player.globalHeat + amount);
        
        // Log heat gain
        GameState.heatLog.push({
          message: reason,
          heatGain: amount,
          timestamp: Date.now()
        });
        
        // Keep only last 50 logs
        if (GameState.heatLog.length > 50) {
          GameState.heatLog = GameState.heatLog.slice(-50);
        }
        
        // Update police activity level
        this.updatePoliceActivity();
        
        console.log(`Global heat +${amount}%: ${reason}`);
      },
      
      updatePoliceActivity() {
        const heat = GameState.player.globalHeat;
        let newActivity;
        
        if (heat < 25) newActivity = 'low';
        else if (heat < 50) newActivity = 'medium';
        else if (heat < 75) newActivity = 'high';
        else newActivity = 'extreme';
        
        if (GameState.cityState.policeActivity !== newActivity) {
          GameState.cityState.policeActivity = newActivity;
          console.log(`Police activity: ${newActivity}`);
        }
      },
      
      renderGlobalHeatDisplay() {
        // Remove existing display
        const existing = document.getElementById('global-heat-display');
        if (existing) existing.remove();
        
        const display = document.createElement('div');
        display.id = 'global-heat-display';
        display.className = 'global-heat-display';
        
        const heat = GameState.player.globalHeat;
        let stateLabel = 'QUIET';
        if (heat >= 75) stateLabel = 'EXTREME';
        else if (heat >= 50) stateLabel = 'HIGH ALERT';
        else if (heat >= 25) stateLabel = 'ELEVATED';
        
        display.innerHTML = `
          <div class="heat-state-label">${stateLabel}</div>
          <div class="global-heat-icon"></div>
          <div class="global-heat-bar-container">
            <div class="global-heat-bar-fill" id="global-heat-bar-fill" style="width: ${heat}%"></div>
          </div>
          <div class="global-heat-value" id="global-heat-value">${Math.round(heat)}%</div>
        `;
        
        document.getElementById('app').appendChild(display);
      },
      
      updateGlobalHeatDisplay() {
        const fill = document.getElementById('global-heat-bar-fill');
        const value = document.getElementById('global-heat-value');
        const display = document.getElementById('global-heat-display');
        
        const heat = GameState.player.globalHeat;
        
        if (fill) fill.style.width = `${heat}%`;
        if (value) value.textContent = `${Math.round(heat)}%`;
        
        if (display) {
          let stateLabel = 'QUIET';
          if (heat >= 75) stateLabel = 'EXTREME';
          else if (heat >= 50) stateLabel = 'HIGH ALERT';
          else if (heat >= 25) stateLabel = 'ELEVATED';
          
          const label = display.querySelector('.heat-state-label');
          if (label) label.textContent = stateLabel;
        }
      },
      
      startGlobalHeatDecay() {
        // Decay global heat by 1% every 60 seconds when laying low
        this.globalHeatDecayInterval = setInterval(() => {
          // Only decay if fully in laying_low state (not transitioning)
          if (GameState.playerStatus === 'laying_low' && !GameState.character.freeRoam && !GameState.playerStatusTransition) {
            GameState.player.globalHeat = Math.max(0, GameState.player.globalHeat - 1);
            this.updateGlobalHeatDisplay();
            this.updatePoliceActivity();
            ProfileTab.render();
            Storage.save();
          }
        }, 60000); // Every 60 seconds
      },
      
      startLockdownCheck() {
        // Check for lockdown every 10 seconds
        this.lockdownCheckInterval = setInterval(() => {
          const heat = GameState.player.globalHeat;
          
          // Trigger lockdown at 85% heat
          if (heat >= 85 && !GameState.cityState.lockdown) {
            this.initilateLockdown();
          }
          
          // End lockdown check
          if (GameState.cityState.lockdown && GameState.cityState.lockdownUntil) {
            if (Date.now() >= GameState.cityState.lockdownUntil) {
              this.endLockdown();
            }
          }
        }, 10000); // Every 10 seconds
      },
      
      initilateLockdown() {
        GameState.cityState.lockdown = true;
        GameState.cityState.lockdownUntil = Date.now() + (2 * 60 * 1000); // 2 minutes
        
        // Force stop free roam
        if (GameState.character.freeRoam) {
          GameState.character.freeRoam = false;
          this.stopFreeRoam();
          this.updateRoamButton();
        }
        
        this.showLockdownState();
        this.addGlobalHeat(0, " City lockdown initiated");
        
        Storage.save();
        console.log('Lockdown initiated - 2 minutes');
      },
      
      showLockdownState() {
        // Add red overlay
        if (!document.getElementById('lockdown-overlay')) {
          const overlay = document.createElement('div');
          overlay.id = 'lockdown-overlay';
          overlay.className = 'lockdown-overlay';
          document.getElementById('app').appendChild(overlay);
        }
        
        // Add lockdown banner
        if (!document.getElementById('lockdown-banner')) {
          const banner = document.createElement('div');
          banner.id = 'lockdown-banner';
          banner.className = 'lockdown-banner';
          banner.textContent = ' CITY LOCKDOWN - Stay Hidden';
          document.getElementById('app').appendChild(banner);
        }
      },
      
      endLockdown() {
        GameState.cityState.lockdown = false;
        GameState.cityState.lockdownUntil = null;
        
        // Remove visual elements
        const overlay = document.getElementById('lockdown-overlay');
        if (overlay) overlay.remove();
        
        const banner = document.getElementById('lockdown-banner');
        if (banner) banner.remove();
        
        this.showTemporaryNotification(" Lockdown lifted");
        this.addGlobalHeat(0, " City lockdown ended");
        
        Storage.save();
        console.log('Lockdown ended');
      },
      
      startManhuntCheck() {
        // Check for manhunt every 20 seconds
        this.manhuntCheckInterval = setInterval(() => {
          const heat = GameState.player.globalHeat;
          
          // 10% chance of manhunt if heat > 60% and not already active
          if (heat > 60 && !GameState.cityState.manhuntActive && Math.random() < 0.1) {
            this.triggerManhunt();
          }
        }, 20000); // Every 20 seconds
      },
      
      triggerManhunt() {
        GameState.cityState.manhuntActive = true;
        GameState.cityState.manhuntTarget = GameState.player.name;
        
        this.showManhuntWarning();
        this.addGlobalHeat(10, " Manhunt initiated");
        
        Storage.save();
        console.log('Manhunt triggered!');
      },
      
      showManhuntWarning() {
        const warning = document.createElement('div');
        warning.className = 'manhunt-warning';
        warning.id = 'manhunt-warning';
        
        warning.innerHTML = `
          <div class="manhunt-header">
            <div class="manhunt-icon"></div>
            <div class="manhunt-title">Manhunt Active</div>
          </div>
          <div class="manhunt-description">
            The police have your description. You need to lay low or take drastic action.
          </div>
          <div class="manhunt-choices">
            <button class="manhunt-choice-btn" data-choice="hide">
              <span class="manhunt-choice-icon"></span>
              <span>Hide at Safe House (-30% global heat)</span>
            </button>
            <button class="manhunt-choice-btn" data-choice="bribe">
              <span class="manhunt-choice-icon"></span>
              <span>Bribe Officials ($1000, -50% global heat)</span>
            </button>
            <button class="manhunt-choice-btn" data-choice="ignore">
              <span class="manhunt-choice-icon"></span>
              <span>Ignore Warning (Risk it)</span>
            </button>
          </div>
        `;
        
        document.getElementById('app').appendChild(warning);
        
        // Add choice handlers
        warning.querySelectorAll('.manhunt-choice-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const choice = btn.dataset.choice;
            this.resolveManhunt(choice);
          });
        });
      },
      
      resolveManhunt(choice) {
        const warning = document.getElementById('manhunt-warning');
        if (warning) warning.remove();
        
        if (choice === 'hide') {
          GameState.player.globalHeat = Math.max(0, GameState.player.globalHeat - 30);
          this.showTemporaryNotification(" Successfully hid. Heat reduced.");
          this.addGlobalHeat(0, " Hid at Safe House");
        } else if (choice === 'bribe') {
          if (GameState.player.cash >= 1000) {
            GameState.player.cash -= 1000;
            GameState.player.globalHeat = Math.max(0, GameState.player.globalHeat - 50);
            this.showTemporaryNotification(" Officials bribed. Heat reduced significantly.");
            this.addGlobalHeat(0, " Bribed officials");
            ProfileTab.render();
          } else {
            this.showTemporaryNotification(" Insufficient funds for bribe!");
            GameState.player.globalHeat = Math.max(0, GameState.player.globalHeat - 10);
          }
        } else {
          this.showTemporaryNotification(" Manhunt ongoing - stay alert!");
          this.addGlobalHeat(5, " Ignored manhunt warning");
        }
        
        GameState.cityState.manhuntActive = false;
        GameState.cityState.manhuntTarget = null;
        
        this.updateGlobalHeatDisplay();
        this.updatePoliceActivity();
        ProfileTab.render();
        Storage.save();
      },
      
      showTemporaryNotification(message) {
        const notification = document.createElement('div');
        notification.className = 'xp-notification';
        notification.textContent = message;
        document.getElementById('app').appendChild(notification);
        setTimeout(() => notification.remove(), 4000);
      },
      
      showEventNotification(message) {
        const container = document.getElementById('event-notification-container');
        if (!container) return;
        
        // Remove existing notification
        container.innerHTML = '';
        
        const notification = document.createElement('div');
        notification.className = 'event-notification';
        notification.textContent = message;
        
        container.appendChild(notification);
        
        // Remove after 3 seconds
        setTimeout(() => notification.remove(), 3000);
        
        console.log('Event:', message);
      },
      
      triggerDeath() {
        if (GameState.character.isDead) return;
        
        GameState.character.isDead = true;
        GameState.character.freeRoam = false;
        this.stopFreeRoam();
        this.showDeathOverlay();
        Storage.save();
        
        console.log('Character died!');
      },
      
      showDeathOverlay() {
        // Create overlay
        const overlay = document.createElement('div');
        overlay.className = 'death-overlay';
        overlay.id = 'death-overlay';
        
        overlay.innerHTML = `
          <div class="death-icon"></div>
          <div class="death-message">You have fallen...</div>
          <button class="respawn-btn" id="respawn-btn">Respawn at Hospital</button>
        `;
        
        document.getElementById('app').appendChild(overlay);
        
        // Respawn button handler
        const respawnBtn = document.getElementById('respawn-btn');
        if (respawnBtn) {
          respawnBtn.addEventListener('click', () => this.respawn());
        }
      },
      
      respawn() {
        // Find nearest hospital
        const hospital = GameState.mapIcons.find(i => i.type === 'hospital');
        const respawnPos = hospital ? { x: hospital.x, y: hospital.y } : { x: 75, y: 25 };
        
        // Death consequences summary
        const deathConsequences = {
          cashLost: Math.abs(GameState.ui.lastOutcome?.cashChange || 0),
          xpLost: Math.abs(GameState.ui.lastOutcome?.xpChange || 0),
          timeStamp: Date.now()
        };
        
        // Reset character state
        GameState.character.isDead = false;
        GameState.character.freeRoam = false;
        GameState.character.position = respawnPos;
        
        // Apply additional consequences for death
        // 1. Small reputation hit
        const repLoss = Math.floor(Math.random() * 8) + 5; // 5-13 rep loss
        GameState.player.reputation = Math.max(0, GameState.player.reputation - repLoss);
        
        // 2. If in a gang, gang health takes a hit
        if (GameState.gang) {
          const gangHealthLoss = Math.floor(Math.random() * 5) + 3; // 3-8%
          GameState.gang.health = Math.max(0, GameState.gang.health - gangHealthLoss);
          
          GangTab.logWarEvent(` Gang member died. Gang health: -${gangHealthLoss}%`);
          
          console.log(`Gang health penalty: -${gangHealthLoss}% (now ${GameState.gang.health}%)`);
        }
        
        // 3. Create pressure: Rivals may be emboldened
        if (GameState.gang && Object.keys(GameState.gangRelations).length > 0) {
          // Random rival gains confidence
          const rivalIds = Object.keys(GameState.gangRelations);
          const randomRival = rivalIds[Math.floor(Math.random() * rivalIds.length)];
          const rival = GameState.publicGangs.find(g => g.id === randomRival);
          
          if (rival) {
            // Rival gets health boost
            rival.health = Math.min(100, rival.health + 5);
            
            GangTab.logWarEvent(` ${rival.name} grew bolder after your death.`);
          }
        }
        
        // Remove overlays
        const overlay = document.getElementById('death-overlay');
        if (overlay) overlay.remove();
        
        const modal = document.getElementById('event-modal');
        if (modal) modal.remove();
        
        // Show respawn notification with consequences
        setTimeout(() => {
          let message = ` Respawned at hospital. Lost: $${deathConsequences.cashLost}`;
          if (deathConsequences.xpLost > 0) message += `, ${deathConsequences.xpLost} XP`;
          if (repLoss > 0) message += `, ${repLoss} reputation`;
          
          this.showTemporaryNotification(message);
        }, 500);
        
        // Update UI
        this.updateRoamButton();
        this.renderCharacter();
        ProfileTab.render();
        if (GameState.gang) GangTab.render();
        Storage.save();
        
        console.log(`Respawned at hospital: ${respawnPos.x}, ${respawnPos.y} - Rep loss: ${repLoss}, Total consequences logged`);
      },
      
      setIconState(iconType, newState) {
        const icon = GameState.mapIcons.find(i => i.type === iconType);
        if (!icon) return;
        
        icon.state = newState;
        this.renderIcons();
        Storage.save();
        
        console.log(`Icon ${iconType} state changed to: ${newState}`);
      },
      
      setPlayerStatus(status) {
        // Check if already in transition
        if (GameState.playerStatusTransition) {
          console.log('Cannot switch status during transition');
          return;
        }
        
        // Check if already in this status
        if (GameState.playerStatus === status) {
          return;
        }
        
        // Initiate transition
        const transitionDuration = 2000 + Math.random() * 3000; // 2-5 seconds
        const transitionType = status === 'active' ? 'entering_active' : 'entering_laying_low';
        
        GameState.playerStatusTransition = transitionType;
        GameState.playerStatusTransitionEnd = Date.now() + transitionDuration;
        
        // Show transition indicator
        this.showTransitionIndicator();
        
        // Update button states (disable both during transition)
        this.updateStatusButtons();
        
        // Save state
        Storage.save();
        
        console.log(`Status transition started: ${transitionType} (${Math.round(transitionDuration/1000)}s)`);
      },
      
      startTransitionCheck() {
        // Check transition status every 500ms
        this.transitionCheckInterval = setInterval(() => {
          if (GameState.playerStatusTransition && GameState.playerStatusTransitionEnd) {
            // Check if transition complete
            if (Date.now() >= GameState.playerStatusTransitionEnd) {
              this.completeTransition();
            } else {
              // Update progress (gradual heat adjustment)
              this.updateTransitionProgress();
            }
          }
        }, 500);
      },
      
      completeTransition() {
        if (!GameState.playerStatusTransition) return;
        
        // Determine final status
        const newStatus = GameState.playerStatusTransition === 'entering_active' ? 'active' : 'laying_low';
        
        // Update status
        GameState.playerStatus = newStatus;
        GameState.playerStatusTransition = null;
        GameState.playerStatusTransitionEnd = null;
        
        // Remove transition indicator
        const indicator = document.getElementById('transition-indicator');
        if (indicator) indicator.remove();
        
        // Update UI
        this.updateStatusIndicator();
        this.updateStatusButtons();
        
        // Save state
        Storage.save();
        
        console.log(`Status transition completed: ${newStatus}`);
      },
      
      updateTransitionProgress() {
        // Calculate progress (0 to 1)
        const now = Date.now();
        const start = GameState.playerStatusTransitionEnd - 5000; // Assume max 5s duration
        const elapsed = now - start;
        const total = GameState.playerStatusTransitionEnd - start;
        const progress = Math.max(0, Math.min(1, elapsed / total));
        
        // Gradual heat adjustment during transition
        if (GameState.playerStatusTransition === 'entering_laying_low') {
          // Slightly reduce heat as transitioning to laying low
          const heatReduction = 0.1 * progress; // Up to 0.1% total reduction
          if (Math.random() < 0.1) { // Only occasionally to avoid constant updates
            GameState.player.heat = Math.max(0, GameState.player.heat - heatReduction);
            this.updateHeatIndicator();
          }
        }
        
        // Update transition indicator text
        this.updateTransitionIndicator();
      },
      
      showTransitionIndicator() {
        // Remove existing indicator
        const existing = document.getElementById('transition-indicator');
        if (existing) existing.remove();
        
        const indicator = document.createElement('div');
        indicator.id = 'transition-indicator';
        indicator.className = 'transition-indicator';
        
        const message = GameState.playerStatusTransition === 'entering_active'
          ? 'Stepping back into the streets'
          : 'Fading into the shadows';
        
        indicator.textContent = message;
        
        document.getElementById('app').appendChild(indicator);
      },
      
      updateTransitionIndicator() {
        const indicator = document.getElementById('transition-indicator');
        if (!indicator || !GameState.playerStatusTransition) return;
        
        const remaining = Math.max(0, GameState.playerStatusTransitionEnd - Date.now());
        const seconds = Math.ceil(remaining / 1000);
        
        const baseMessage = GameState.playerStatusTransition === 'entering_active'
          ? 'Stepping back into the streets'
          : 'Fading into the shadows';
        
        indicator.textContent = `${baseMessage} (${seconds}s)`;
      },
      
      updateStatusIndicator() {
        const indicator = document.querySelector('.status-indicator');
        if (!indicator) return;
        
        const status = GameState.playerStatus;
        
        // Update classes
        indicator.className = `status-indicator ${status}`;
        
        // Update icon
        indicator.textContent = status === 'laying_low' ? '' : '';
      },
      
      updateStatusButtons() {
        const status = GameState.playerStatus;
        const inTransition = GameState.playerStatusTransition !== null;
        
        document.querySelectorAll('.status-btn').forEach(btn => {
          const isSelected = btn.dataset.status === status;
          btn.classList.toggle('selected', isSelected);
          btn.classList.toggle('transitioning', inTransition);
        });
      },
      
      renderMap() {
        const mapContainer = document.getElementById('city-map');
        if (!mapContainer) {
          console.warn("Map container not found");
          return;
        }
      },
      
      renderIcons() {
        const iconsContainer = document.getElementById('map-icons');
        if (!iconsContainer) {
          console.warn("Icons container not found");
          return;
        }
        
        // Clear existing icons
        iconsContainer.innerHTML = '';
        
        // Render each map icon (landmarks)
        GameState.mapIcons.forEach((iconData, index) => {
          const iconEl = document.createElement('div');
          iconEl.className = `map-icon ${iconData.state}`;
          iconEl.textContent = iconData.icon;
          iconEl.style.left = `${iconData.x}%`;
          iconEl.style.top = `${iconData.y}%`;
          iconEl.dataset.type = iconData.type;
          iconEl.dataset.label = iconData.label || iconData.type;
          
          // Add click handler (no action yet, just visual feedback)
          iconEl.addEventListener('click', () => {
            console.log(`Icon clicked: ${iconData.type} (${iconData.state})`);
            // Future: Open interaction modal
          });
          
          console.log(`Rendering icon ${index}:`, iconData.type, `at ${iconData.x}%, ${iconData.y}% - State: ${iconData.state}`);
          
          iconsContainer.appendChild(iconEl);
        });
        
        console.log(`Rendered ${GameState.mapIcons.length} icons`);
        
        // PHASE 1: Render interactive buildings
        InteractiveBuildings.renderBuildings();
        
        // Update risk-based brightness
        this.updateIconRiskLevels();
      },
      
      renderCharacter() {
        const characterEl = document.getElementById('character-sprite');
        if (!characterEl) {
          console.warn("Character sprite not found");
          return;
        }
        
        const { x, y } = GameState.character.position;
        characterEl.style.left = `${x}%`;
        characterEl.style.top = `${y}%`;
        
        // Check if character is in a dangerous area
        const areaRisk = MapMemory.getAreaRisk(x, y);
        const riskLevel = MapMemory.getRiskLevel(areaRisk);
        
        // Visual feedback for dangerous areas (subtle pulse)
        if (riskLevel === 'extreme' || riskLevel === 'high') {
          characterEl.style.filter = 'drop-shadow(0 0 4px rgba(255, 90, 60, 0.6))';
        } else {
          characterEl.style.filter = 'drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5))';
        }
        
        console.log(`Character positioned at ${x}%, ${y}% - Area risk: ${areaRisk.toFixed(1)}`);
        
        // Update character sprite
        this.updateCharacterSprite();
      },
      
      updateCharacterSprite() {
        const spriteEl = document.querySelector('.character-silhouette');
        if (!spriteEl) return;
        
        const { appearance, equippedWardrobe } = GameState.character;
        
        // Update base character
        const baseChar = appearance.gender === 'male' ? '' : '';
        
        // Get equipped items
        const equippedItems = equippedWardrobe
          .map(id => GameState.wardrobe.items.find(item => item.id === id))
          .filter(item => item);
        
        // Build sprite display
        const wardrobeIcons = equippedItems.map(item => item.icon).join('');
        spriteEl.innerHTML = `${baseChar}${wardrobeIcons}`;
        
        console.log('Character sprite updated:', baseChar, wardrobeIcons);
      },
      
      render() {
        console.log("TurfTab.render() called");
        console.log("Map icons to render:", GameState.mapIcons.length);
        console.log("Icon states:", GameState.mapIcons.map(i => `${i.type}:${i.state}`).join(', '));
        console.log("Player status:", GameState.playerStatus);
        console.log("Free roam:", GameState.character.freeRoam);
        console.log("Character position:", GameState.character.position);
        console.log("Jailed:", GameState.player.jail.isJailed);
        console.log("Heat:", GameState.player.heat);
        console.log("Fatigue:", GameState.player.fatigue.level.toFixed(1), `(${FatigueSystem.getFatigueLevel()})`);
        console.log("Consecutive actions:", GameState.player.fatigue.consecutiveActions);
        console.log("Map hotspots:", GameState.mapMemory.hotspots.length);
        console.log("RNG Memory - Events:", GameState.player.rngMemory.eventOutcomes.length, "recent outcomes");
        console.log("RNG Memory - Raids:", GameState.player.rngMemory.raidOutcomes.length, "recent outcomes");
        console.log("Map grid exists:", GameState.map.grid !== null);
        console.log("Buildings count:", GameState.map.buildings ? GameState.map.buildings.length : 0);
        
        // PHASE 7.4D: Render procedural map tiles
        // Reset render flag if SVG is missing (handles tab switching issues)
        const mapContainer = document.getElementById('city-map');
        if (mapContainer && !mapContainer.querySelector('#unified-biome-layer')) {
          console.log(" SVG missing - resetting render flag");
          ProceduralMapRenderer.rendered = false;
        }
        
        ProceduralMapRenderer.renderMap();
        
        this.renderMap();
        this.renderIcons();
        this.renderCharacter();
        this.updateStatusButtons();
        this.updateStatusIndicator();
        this.updateRoamButton();
        this.updateHeatIndicator();
        
        // Initialize hotspot visualization
        MapMemory.visualizeHotspots();
        
        // Resume free roam if it was active
        if (GameState.character.freeRoam && !GameState.character.isDead && !GameState.player.jail.isJailed && !this.roamInterval) {
          this.startFreeRoam();
        }
        
        // Show death overlay if dead
        if (GameState.character.isDead && !document.getElementById('death-overlay')) {
          this.showDeathOverlay();
        }
        
        // Show jail overlay if jailed
        if (GameState.player.jail.isJailed && !document.getElementById('jail-overlay')) {
          this.showJailOverlay();
        }
      }
    };

    const CrimesTab = {
      render() {
        const container = document.getElementById('crimes-tab');
        if (!container) return;
        
        container.innerHTML = `
          <div class="page-header">Crimes</div>
          ${this.renderGarage()}
          ${this.renderCategories()}
        `;
        
        // Add event listeners for crime buttons
        container.querySelectorAll('.crime-attempt-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const crimeId = btn.dataset.crimeId;
            this.handleCrimeAttempt(crimeId);
          });
        });
        
        // Add event listeners for sell buttons
        container.querySelectorAll('.sell-vehicle-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const vehicleId = btn.dataset.vehicleId;
            this.handleVehicleSale(vehicleId);
          });
        });
      },
      
      renderGarage() {
        const garageStatus = CrimesSystem.getGarageStatus();
        
        if (garageStatus.count === 0) return '';
        
        return `
          <div class="gang-section" style="margin-bottom: 16px;">
            <div class="gang-section-title">
               Your Garage (${garageStatus.count}/${garageStatus.capacity})
              <span style="opacity: 0.7; font-size: 11px; margin-left: 8px;">Total Value: $${garageStatus.totalValue.toLocaleString()}</span>
            </div>
            <div style="display: flex; flex-direction: column; gap: 8px;">
              ${garageStatus.vehicles.map(vehicle => this.renderVehicle(vehicle, garageStatus.canSell)).join('')}
            </div>
          </div>
        `;
      },
      
      renderVehicle(vehicle, canSell) {
        const tierEmojis = {
          junker: '',
          sedan: '',
          luxury: '',
          exotic: ''
        };
        
        const tierColors = {
          junker: '#8a8a8a',
          sedan: '#8ab4f8',
          luxury: '#fdd663',
          exotic: '#f28b82'
        };
        
        const icon = tierEmojis[vehicle.tier] || '';
        const color = tierColors[vehicle.tier] || '#e0e0e0';
        
        return `
          <div class="gang-property" style="justify-content: space-between;">
            <div style="display: flex; align-items: center; gap: 12px;">
              <div style="font-size: 24px;">${icon}</div>
              <div>
                <div style="font-size: 14px; font-weight: 500;">${vehicle.name}</div>
                <div style="font-size: 11px; color: ${color}; text-transform: capitalize;">${vehicle.tier}</div>
              </div>
            </div>
            <div style="display: flex; align-items: center; gap: 12px;">
              <div style="text-align: right;">
                <div style="font-size: 11px; opacity: 0.6;">Sell Value</div>
                <div style="font-size: 14px; color: #81c995; font-weight: 600;">$${vehicle.sellValue.toLocaleString()}</div>
              </div>
              <button 
                class="sell-vehicle-btn raid-btn" 
                data-vehicle-id="${vehicle.id}"
                ${!canSell ? 'disabled' : ''}
                style="padding: 8px 16px; min-height: 36px; ${!canSell ? 'opacity: 0.4; cursor: not-allowed;' : ''}">
                 Sell
              </button>
            </div>
          </div>
        `;
      },
      
      renderCategories() {
        let html = '';
        
        Object.values(CrimesDatabase.categories).forEach(category => {
          const crimes = CrimesSystem.getCrimesByCategory(category.id);
          if (crimes.length === 0) return;
          
          // Check if category is unlocked
          const isUnlocked = GameState.player.level >= category.unlockLevel;
          
          html += `
            <div class="gang-section" style="margin-bottom: 16px; ${!isUnlocked ? 'opacity: 0.5;' : ''}">
              <div class="gang-section-title">
                ${category.icon} ${category.name}
                ${!isUnlocked ? `<span style="opacity: 0.6; font-size: 10px; margin-left: 8px;">Unlock at Level ${category.unlockLevel}</span>` : ''}
                ${category.comingSoon ? `<span style="opacity: 0.6; font-size: 10px; margin-left: 8px;">Coming Soon</span>` : ''}
              </div>
              <div style="font-size: 11px; opacity: 0.7; margin-bottom: 12px;">${category.description}</div>
              <div style="display: flex; flex-direction: column; gap: 8px;">
                ${crimes.map(crime => this.renderCrime(crime, isUnlocked)).join('')}
              </div>
            </div>
          `;
        });
        
        return html;
      },
      
      renderCrime(crime, categoryUnlocked) {
        const canAttempt = CrimesSystem.canAttemptCrime(crime.id);
        const successChance = CrimesSystem.calculateSuccessChance(crime.id);
        
        const riskColors = {
          low: '#81c995',
          medium: '#fdd663',
          high: '#ff9966',
          extreme: '#f28b82'
        };
        
        const riskColor = riskColors[crime.riskLevel] || '#e0e0e0';
        
        return `
          <div class="gang-property" style="flex-direction: column; align-items: stretch; gap: 8px; ${!categoryUnlocked ? 'pointer-events: none;' : ''}">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div style="display: flex; align-items: center; gap: 12px;">
                <div style="font-size: 28px;">${crime.icon}</div>
                <div>
                  <div style="font-size: 14px; font-weight: 500;">${crime.name}</div>
                  <div style="font-size: 11px; opacity: 0.7;">${crime.description}</div>
                </div>
              </div>
              <div style="text-align: right;">
                <div style="font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.6; margin-bottom: 4px;">Risk</div>
                <div style="font-size: 12px; color: ${riskColor}; font-weight: 600; text-transform: uppercase;">${crime.riskLevel}</div>
              </div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; font-size: 11px;">
              <div>
                <div style="opacity: 0.6;">Reward</div>
                <div style="color: #81c995;">$${crime.rewards.cash.min}-${crime.rewards.cash.max}</div>
              </div>
              <div>
                <div style="opacity: 0.6;">Heat</div>
                <div style="color: #f28b82;">+${crime.costs.heatGain.min}-${crime.costs.heatGain.max}%</div>
              </div>
              <div>
                <div style="opacity: 0.6;">Success</div>
                <div style="color: #8ab4f8;">${Math.round(successChance * 100)}%</div>
              </div>
            </div>
            
            <button 
              class="crime-attempt-btn raid-btn" 
              data-crime-id="${crime.id}"
              ${!canAttempt.canAttempt ? 'disabled' : ''}
              style="width: 100%; ${!canAttempt.canAttempt ? 'opacity: 0.4; cursor: not-allowed;' : ''}">
              <span></span>
              <span>${canAttempt.canAttempt ? 'Attempt' : canAttempt.reason}</span>
            </button>
          </div>
        `;
      },
      
      handleCrimeAttempt(crimeId) {
        console.log(`Attempting crime: ${crimeId}`);
        
        const result = CrimesSystem.attemptCrime(crimeId);
        
        if (!result) {
          console.log('Crime attempt blocked');
          return;
        }
        
        // Show result modal
        this.showCrimeResult(result);
        
        // Refresh crimes list
        this.render();
      },
      
      showCrimeResult(result) {
        const modal = document.createElement('div');
        modal.className = 'event-modal';
        modal.id = 'crime-result-modal';
        
        const outcomeIcons = {
          critical_success: '',
          success: '',
          partial_failure: '',
          failure: ''
        };
        
        const outcomeColors = {
          critical_success: '#fdd663',
          success: '#81c995',
          partial_failure: '#ff9966',
          failure: '#f28b82'
        };
        
        const icon = outcomeIcons[result.outcome] || '';
        const color = outcomeColors[result.outcome] || '#e0e0e0';
        
        modal.innerHTML = `
          <div class="event-modal-content">
            <div class="raid-result">
              <div class="raid-result-icon">${icon}</div>
              <div class="raid-result-title" style="color: ${color};">${result.crimeName}</div>
              <div class="raid-result-description">${result.message}</div>
              
              ${result.specialEvent ? `
                <div style="margin: 12px 0; padding: 12px; background: rgba(138, 180, 248, 0.1); border-left: 3px solid #8ab4f8; border-radius: 4px;">
                  <div style="font-size: 12px; font-weight: 600; margin-bottom: 4px; color: #8ab4f8;">SPECIAL EVENT</div>
                  <div style="font-size: 13px; line-height: 1.4;">${result.specialEvent}</div>
                </div>
              ` : ''}
              
              ${result.vehicleStored ? `
                <div style="margin: 12px 0; padding: 12px; background: rgba(129, 201, 149, 0.1); border-left: 3px solid #81c995; border-radius: 4px;">
                  <div style="font-size: 13px; color: #81c995;"> Vehicle stored in your garage!</div>
                </div>
              ` : ''}
              
              <div class="raid-result-rewards">
                ${result.rewards.cash > 0 ? `
                  <div class="reward-item">
                    <span class="reward-label">Cash</span>
                    <span class="reward-value reward-positive">+$${result.rewards.cash}</span>
                  </div>
                ` : ''}
                ${result.rewards.xp > 0 ? `
                  <div class="reward-item">
                    <span class="reward-label">XP</span>
                    <span class="reward-value reward-positive">+${result.rewards.xp}</span>
                  </div>
                ` : ''}
                ${result.rewards.reputation > 0 ? `
                  <div class="reward-item">
                    <span class="reward-label">Reputation</span>
                    <span class="reward-value reward-positive">+${result.rewards.reputation}</span>
                  </div>
                ` : ''}
                <div class="reward-item">
                  <span class="reward-label">Heat</span>
                  <span class="reward-value reward-negative">+${result.costs.heat.toFixed(1)}%</span>
                </div>
                ${result.costs.injured ? `
                  <div class="reward-item">
                    <span class="reward-label">Status</span>
                    <span class="reward-value reward-negative">Injured</span>
                  </div>
                ` : ''}
              </div>
              
              <button class="outcome-btn" id="close-crime-result">Continue</button>
            </div>
          </div>
        `;
        
        document.getElementById('app').appendChild(modal);
        
        document.getElementById('close-crime-result')?.addEventListener('click', () => {
          modal.remove();
        });
      },
      
      handleVehicleSale(vehicleId) {
        const result = CrimesSystem.sellVehicle(vehicleId);
        
        if (!result) return;
        
        if (!result.success) {
          // Show cooldown message
          const notification = document.createElement('div');
          notification.className = 'xp-notification';
          notification.innerHTML = `<span class="xp-negative"> ${result.reason}</span>`;
          document.getElementById('app').appendChild(notification);
          setTimeout(() => notification.remove(), 3000);
          return;
        }
        
        // Show sale success
        const notification = document.createElement('div');
        notification.className = 'xp-notification';
        notification.innerHTML = `<span class="xp-positive"> Sold ${result.vehicle.name} for $${result.value.toLocaleString()}</span>`;
        document.getElementById('app').appendChild(notification);
        setTimeout(() => notification.remove(), 3000);
        
        // Refresh display
        this.render();
      }
    };

    const SafeHouseTab = {
      init() {
        // Initialize trait selection listeners
        const traitButtons = document.querySelectorAll('.option-btn[data-trait]');
        traitButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            this.selectTrait(btn.dataset.trait, btn.dataset.value);
          });
        });
      },
      
      selectTrait(trait, value) {
        // Update GameState
        GameState.character.appearance[trait] = value;
        
        // Update button selection for this trait
        document.querySelectorAll(`.option-btn[data-trait="${trait}"]`).forEach(btn => {
          btn.classList.toggle('selected', btn.dataset.value === value);
        });
        
        // Update preview
        this.updatePreview();
        
        // Update character on map
        TurfTab.updateCharacterSprite();
        
        // Save
        Storage.save();
        
        console.log(`Character ${trait} changed to: ${value}`);
      },
      
      toggleWardrobeItem(itemId) {
        const item = GameState.wardrobe.items.find(i => i.id === itemId);
        if (!item || !item.isUnlocked) return;
        
        const equipped = GameState.wardrobe.equipped;
        const index = equipped.indexOf(itemId);
        
        if (index > -1) {
          // Unequip
          equipped.splice(index, 1);
        } else {
          // Equip (remove other items in same slot first)
          const otherInSlot = equipped.find(id => {
            const otherItem = GameState.wardrobe.items.find(i => i.id === id);
            return otherItem && otherItem.slot === item.slot;
          });
          if (otherInSlot) {
            equipped.splice(equipped.indexOf(otherInSlot), 1);
          }
          equipped.push(itemId);
        }
        
        // Update character equipped wardrobe
        GameState.character.equippedWardrobe = [...equipped];
        
        // Update UI
        this.renderWardrobe();
        this.updatePreview();
        TurfTab.updateCharacterSprite();
        
        // Save
        Storage.save();
        
        console.log(`Wardrobe updated:`, equipped);
      },
      
      updatePreview() {
        const { appearance } = GameState.character;
        
        // Update character icon (simplified - just using base emoji)
        const characterIcon = document.getElementById('preview-character');
        if (characterIcon) {
          characterIcon.textContent = appearance.gender === 'male' ? '' : '';
        }
        
        // Update wardrobe icons
        const wardrobePreview = document.getElementById('preview-wardrobe');
        if (wardrobePreview) {
          const equippedItems = GameState.wardrobe.equipped
            .map(id => GameState.wardrobe.items.find(item => item.id === id))
            .filter(item => item);
          
          wardrobePreview.textContent = equippedItems.map(item => item.icon).join('');
        }
        
        // Update details tags
        const detailsContainer = document.getElementById('preview-details');
        if (detailsContainer) {
          const gender = appearance.gender.charAt(0).toUpperCase() + appearance.gender.slice(1);
          const race = appearance.race.charAt(0).toUpperCase() + appearance.race.slice(1);
          const hair = appearance.hair.charAt(0).toUpperCase() + appearance.hair.slice(1) + ' Hair';
          
          detailsContainer.innerHTML = `
            <span class="preview-tag">${gender}</span>
            <span class="preview-tag">${race}</span>
            <span class="preview-tag">${hair}</span>
          `;
        }
      },
      
      renderWardrobe() {
        const container = document.getElementById('wardrobe-grid');
        if (!container) return;
        
        container.innerHTML = '';
        
        GameState.wardrobe.items.forEach(item => {
          const isEquipped = GameState.wardrobe.equipped.includes(item.id);
          const itemEl = document.createElement('div');
          itemEl.className = `wardrobe-item ${item.isUnlocked ? '' : 'locked'} ${isEquipped ? 'equipped' : ''}`;
          
          itemEl.innerHTML = `
            ${!item.isUnlocked ? '<span class="item-locked-badge"></span>' : ''}
            <div class="item-icon">${item.icon}</div>
            <div class="item-name">${item.name}</div>
            ${!item.isUnlocked ? `<div class="item-cost">$${item.cost}</div>` : ''}
          `;
          
          if (item.isUnlocked) {
            itemEl.addEventListener('click', () => {
              this.toggleWardrobeItem(item.id);
            });
          }
          
          container.appendChild(itemEl);
        });
      },
      
      render() {
        this.updatePreview();
        this.renderWardrobe();
        
        // Update trait button selections
        const { appearance } = GameState.character;
        Object.keys(appearance).forEach(trait => {
          const value = appearance[trait];
          document.querySelectorAll(`.option-btn[data-trait="${trait}"]`).forEach(btn => {
            btn.classList.toggle('selected', btn.dataset.value === value);
          });
        });
      }
    };

    const InventoryTab = {
      render() {
        // Future implementation
      }
    };

    const GangTab = {
      propertyIncomeInterval: null,
      heatDecayInterval: null,
      
      init() {
        // Start property income tick
        this.startPropertyIncome();
        
        // Start heat decay for gang relations
        this.startRelationHeatDecay();
      },
      
      render() {
        const container = document.getElementById('gang-content');
        if (!container) return;
        
        if (!GameState.gang) {
          this.renderNoGang(container);
        } else {
          this.renderGangProfile(container);
        }
      },
      
      renderNoGang(container) {
        container.innerHTML = `
          <div class="no-gang-message">
            <div class="no-gang-icon"></div>
            <div class="no-gang-text">
              You're not in a gang. Create your own or join an existing one to expand your criminal empire.
            </div>
            <div class="gang-action-buttons">
              <button class="gang-action-btn" id="create-gang-btn">
                <span></span>
                <span>Create Gang</span>
              </button>
              <button class="gang-action-btn" id="join-gang-btn">
                <span></span>
                <span>Join Gang</span>
              </button>
            </div>
          </div>
        `;
        
        document.getElementById('create-gang-btn')?.addEventListener('click', () => {
          this.showCreateGangModal();
        });
        
        document.getElementById('join-gang-btn')?.addEventListener('click', () => {
          this.showJoinGangModal();
        });
      },
      
      renderGangProfile(container) {
        const gang = GameState.gang;
        const isLeader = gang.members[0].id === 'player';
        
        container.innerHTML = `
          <div class="gang-container">
            <div class="gang-header">
              <div class="gang-flag">${gang.flag}</div>
              <div class="gang-name">${gang.name}</div>
              <div class="gang-role">${isLeader ? 'Leader' : 'Member'}</div>
            </div>
            
            <div class="gang-stats-grid">
              <div class="gang-stat-card">
                <div class="gang-stat-label">Vault</div>
                <div class="gang-stat-value">$${gang.vault.toLocaleString()}</div>
              </div>
              <div class="gang-stat-card">
                <div class="gang-stat-label">Members</div>
                <div class="gang-stat-value">${gang.members.length}</div>
              </div>
              <div class="gang-stat-card">
                <div class="gang-stat-label">Health</div>
                <div class="gang-stat-value">${gang.health}%</div>
              </div>
              <div class="gang-stat-card">
                <div class="gang-stat-label">Properties</div>
                <div class="gang-stat-value">${gang.properties.length}</div>
              </div>
            </div>
            
            <div class="gang-section">
              <div class="gang-section-title">Members</div>
              <div class="gang-member-list" id="gang-member-list">
                ${this.renderMembers(gang.members)}
              </div>
            </div>
            
            <div class="gang-section">
              <div class="gang-section-title">Properties</div>
              <div class="gang-property-list" id="gang-property-list">
                ${gang.properties.length > 0 ? this.renderProperties(gang.properties) : '<div style="text-align: center; opacity: 0.5; padding: 20px;">No properties owned</div>'}
              </div>
            </div>
          </div>
          
          ${this.renderRelationsSection()}
          ${this.renderWarLogSection()}
        `;
        
        // Add raid button listeners
        container.querySelectorAll('.raid-btn').forEach(btn => {
          if (!btn.disabled) {
            btn.addEventListener('click', () => {
              const gangId = btn.dataset.gangId;
              this.initiateRaid(gangId);
            });
          }
        });
      },
      
      renderMembers(members) {
        return members.map(member => `
          <div class="gang-member">
            <span class="gang-member-name">${member.name}</span>
            <span class="gang-member-role">${member.role}</span>
          </div>
        `).join('');
      },
      
      renderProperties(properties) {
        return properties.map(prop => `
          <div class="gang-property">
            <div class="property-info">
              <div class="property-name">${prop.name}</div>
              <div class="property-income">+$${prop.income}/min</div>
            </div>
            <div class="property-icon">${prop.icon}</div>
          </div>
        `).join('');
      },
      
      renderRelationsSection() {
        if (!GameState.gang) return '';
        
        // Initialize relations for all public gangs
        GameState.publicGangs.forEach(gang => {
          if (gang.id !== GameState.gang?.id && !GameState.gangRelations[gang.id]) {
            GameState.gangRelations[gang.id] = {
              status: 'neutral',
              heat: 0,
              lastAction: null,
              warStarted: null
            };
          }
        });
        
        const relations = GameState.publicGangs
          .filter(gang => gang.id !== GameState.gang?.id)
          .map(gang => {
            const relation = GameState.gangRelations[gang.id] || { status: 'neutral', heat: 0 };
            return { gang, relation };
          });
        
        if (relations.length === 0) return '';
        
        return `
          <div class="relations-section">
            <div class="gang-section-title">Gang Relations</div>
            ${relations.map(({ gang, relation }) => this.renderRelationCard(gang, relation)).join('')}
          </div>
        `;
      },
      
      renderRelationCard(gang, relation) {
        const isAtWar = relation.status === 'war';
        const canRaid = !isAtWar || relation.heat < 100;
        
        return `
          <div class="relation-card">
            <div class="relation-header">
              <div class="relation-gang-info">
                <div class="relation-flag">${gang.flag}</div>
                <div class="relation-name">${gang.name}</div>
              </div>
              <div class="relation-status ${relation.status}">${isAtWar ? ' WAR' : ' Neutral'}</div>
            </div>
            
            <div class="relation-heat-bar">
              <span style="font-size: 12px; opacity: 0.7;">Heat:</span>
              <div class="heat-bar-small">
                <div class="heat-bar-small-fill" style="width: ${relation.heat}%"></div>
              </div>
              <span class="heat-value-small">${Math.round(relation.heat)}%</span>
            </div>
            
            <div class="relation-actions">
              <button class="raid-btn" data-gang-id="${gang.id}" ${!canRaid ? 'disabled' : ''}>
                <span></span>
                <span>Raid</span>
              </button>
            </div>
          </div>
        `;
      },
      
      renderWarLogSection() {
        if (!GameState.gang || GameState.gangWarLog.length === 0) return '';
        
        // Get last 10 war events
        const recentLogs = GameState.gangWarLog.slice(-10).reverse();
        
        return `
          <div class="war-log-section">
            <div class="gang-section-title">War Log</div>
            <div class="war-log-list">
              ${recentLogs.length > 0 
                ? recentLogs.map(log => this.renderWarLogEntry(log)).join('') 
                : '<div class="war-log-empty">No conflicts yet</div>'}
            </div>
          </div>
        `;
      },
      
      renderWarLogEntry(log) {
        const timestamp = new Date(log.timestamp).toLocaleString();
        return `
          <div class="war-log-entry">
            ${log.message}
            <div class="war-log-timestamp">${timestamp}</div>
          </div>
        `;
      },
      
      showCreateGangModal() {
        const modal = document.createElement('div');
        modal.className = 'event-modal';
        modal.id = 'gang-modal';
        
        const createCost = 5000;
        const canAfford = GameState.player.cash >= createCost;
        
        modal.innerHTML = `
          <div class="event-modal-content">
            <div class="event-modal-title">Create Gang</div>
            <div class="gang-creation-form">
              <div class="form-group">
                <label class="form-label">Gang Name</label>
                <input type="text" class="form-input" id="gang-name-input" placeholder="Enter gang name" maxlength="30">
              </div>
              
              <div class="form-group">
                <label class="form-label">Gang Flag</label>
                <div class="flag-selector">
                  <div class="flag-option selected" data-flag=""></div>
                  <div class="flag-option" data-flag=""></div>
                  <div class="flag-option" data-flag=""></div>
                  <div class="flag-option" data-flag=""></div>
                  <div class="flag-option" data-flag=""></div>
                  <div class="flag-option" data-flag=""></div>
                  <div class="flag-option" data-flag=""></div>
                  <div class="flag-option" data-flag=""></div>
                  <div class="flag-option" data-flag=""></div>
                  <div class="flag-option" data-flag=""></div>
                </div>
              </div>
              
              <div class="form-group">
                <label class="form-label">Gang Color</label>
                <div class="color-selector">
                  <div class="color-option selected" data-color="#f28b82" style="background: #f28b82;"></div>
                  <div class="color-option" data-color="#8ab4f8" style="background: #8ab4f8;"></div>
                  <div class="color-option" data-color="#81c995" style="background: #81c995;"></div>
                  <div class="color-option" data-color="#fdd663" style="background: #fdd663;"></div>
                  <div class="color-option" data-color="#c58af9" style="background: #c58af9;"></div>
                  <div class="color-option" data-color="#ff6b6b" style="background: #ff6b6b;"></div>
                  <div class="color-option" data-color="#4ecdc4" style="background: #4ecdc4;"></div>
                  <div class="color-option" data-color="#95e1d3" style="background: #95e1d3;"></div>
                </div>
              </div>
              
              <div class="form-cost">Cost: $${createCost.toLocaleString()}</div>
              
              <button class="outcome-btn" id="create-gang-confirm-btn" ${!canAfford ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>
                ${canAfford ? 'Create Gang' : 'Insufficient Funds'}
              </button>
              <button class="outcome-btn" id="cancel-gang-btn" style="background: #0a0a0a; margin-top: 8px;">Cancel</button>
            </div>
          </div>
        `;
        
        document.getElementById('app').appendChild(modal);
        
        // Flag selection
        let selectedFlag = '';
        modal.querySelectorAll('.flag-option').forEach(opt => {
          opt.addEventListener('click', () => {
            modal.querySelectorAll('.flag-option').forEach(o => o.classList.remove('selected'));
            opt.classList.add('selected');
            selectedFlag = opt.dataset.flag;
          });
        });
        
        // Color selection
        let selectedColor = '#f28b82';
        modal.querySelectorAll('.color-option').forEach(opt => {
          opt.addEventListener('click', () => {
            modal.querySelectorAll('.color-option').forEach(o => o.classList.remove('selected'));
            opt.classList.add('selected');
            selectedColor = opt.dataset.color;
          });
        });
        
        // Confirm button
        if (canAfford) {
          document.getElementById('create-gang-confirm-btn')?.addEventListener('click', () => {
            const nameInput = document.getElementById('gang-name-input');
            const gangName = nameInput.value.trim();
            
            if (!gangName) {
              alert('Please enter a gang name');
              return;
            }
            
            this.createGang(gangName, selectedFlag, selectedColor, createCost);
            modal.remove();
          });
        }
        
        // Cancel button
        document.getElementById('cancel-gang-btn')?.addEventListener('click', () => {
          modal.remove();
        });
      },
      
      createGang(name, flag, color, cost) {
        // Deduct cost
        GameState.player.cash -= cost;
        
        // Create gang
        GameState.gang = {
          id: 'player_gang_' + Date.now(),
          name: name,
          flag: flag,
          color: color,
          vault: 0,
          health: 100,
          members: [
            { id: 'player', name: GameState.player.name, role: 'Leader' }
          ],
          properties: [
            // Starter property
            { id: 'safehouse_base', name: 'Safe House', icon: '', income: 50, lastCollected: Date.now() }
          ],
          createdAt: Date.now()
        };
        
        ProfileTab.render();
        this.render();
        Storage.save();
        
        console.log('Gang created:', name);
      },
      
      showJoinGangModal() {
        const modal = document.createElement('div');
        modal.className = 'event-modal';
        modal.id = 'gang-modal';
        
        const gangListHTML = GameState.publicGangs.map(gang => `
          <div class="gang-list-item" data-gang-id="${gang.id}">
            <div class="gang-list-info">
              <div class="gang-list-flag">${gang.flag}</div>
              <div class="gang-list-details">
                <div class="gang-list-name">${gang.name}</div>
                <div class="gang-list-members">${gang.memberCount} members</div>
              </div>
            </div>
            <button class="outcome-btn" style="padding: 8px 16px; min-height: 36px;">Join</button>
          </div>
        `).join('');
        
        modal.innerHTML = `
          <div class="event-modal-content">
            <div class="event-modal-title">Join Gang</div>
            <div class="gang-list">
              ${gangListHTML}
            </div>
            <button class="outcome-btn" id="cancel-join-btn" style="background: #0a0a0a; margin-top: 16px;">Cancel</button>
          </div>
        `;
        
        document.getElementById('app').appendChild(modal);
        
        // Join buttons
        modal.querySelectorAll('.gang-list-item button').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const gangId = btn.closest('.gang-list-item').dataset.gangId;
            const gang = GameState.publicGangs.find(g => g.id === gangId);
            if (gang) {
              this.joinGang(gang);
              modal.remove();
            }
          });
        });
        
        // Cancel button
        document.getElementById('cancel-join-btn')?.addEventListener('click', () => {
          modal.remove();
        });
      },
      
      joinGang(publicGang) {
        // Join existing gang
        GameState.gang = {
          id: publicGang.id,
          name: publicGang.name,
          flag: publicGang.flag,
          color: '#8ab4f8',
          vault: publicGang.vault || Math.floor(Math.random() * 5000) + 1000,
          health: publicGang.health || 100,
          members: [
            { id: 'npc_leader', name: 'Gang Leader', role: 'Leader' },
            { id: 'player', name: GameState.player.name, role: 'Member' }
          ],
          properties: [
            { id: 'warehouse_1', name: 'Warehouse', icon: '', income: 75, lastCollected: Date.now() }
          ],
          createdAt: Date.now()
        };
        
        this.render();
        Storage.save();
        
        console.log('Joined gang:', publicGang.name);
      },
      
      initiateRaid(targetGangId) {
        const targetGang = GameState.publicGangs.find(g => g.id === targetGangId);
        if (!targetGang || !GameState.gang) return;
        
        // Record fatigue for this action
        FatigueSystem.addFatigue('raid', `Raid on ${targetGang.name}`);
        
        const relation = GameState.gangRelations[targetGangId];
        
        // Base success rate: 60%
        const baseSuccessRate = 0.6;
        
        // Apply fatigue penalty
        const fatiguePenalty = FatigueSystem.getSuccessPenalty();
        const adjustedSuccessRate = baseSuccessRate - fatiguePenalty;
        
        // Use fairness-adjusted RNG
        const raidSuccess = RNGFairness.rollWithFairness(adjustedSuccessRate, 'raid');
        
        let result = {
          success: raidSuccess,
          cashStolen: 0,
          healthDamage: 0,
          heatGain: 0,
          retaliation: false
        };
        
        if (raidSuccess) {
          // Successful raid
          result.cashStolen = Math.floor(Math.random() * 500) + 200; // $200-700
          result.healthDamage = Math.floor(Math.random() * 10) + 5; // 5-15%
          result.heatGain = Math.floor(Math.random() * 20) + 15; // 15-35%
          
          // Apply rewards
          GameState.gang.vault += result.cashStolen;
          targetGang.health = Math.max(0, targetGang.health - result.healthDamage);
          
          // 30% chance of retaliation
          result.retaliation = Math.random() < 0.3;
        } else {
          // Failed raid
          result.healthDamage = Math.floor(Math.random() * 5) + 3; // 3-8% to us
          result.heatGain = Math.floor(Math.random() * 15) + 10; // 10-25%
          
          // Apply damage to our gang
          GameState.gang.health = Math.max(0, GameState.gang.health - result.healthDamage);
          
          // 50% chance of retaliation on failure
          result.retaliation = Math.random() < 0.5;
        }
        
        // Update heat
        relation.heat = Math.min(100, relation.heat + result.heatGain);
        relation.lastAction = Date.now();
        
        // Check for war threshold
        if (relation.heat >= 75 && relation.status !== 'war') {
          relation.status = 'war';
          relation.warStarted = Date.now();
          this.logWarEvent(` War declared with ${targetGang.name}!`);
        }
        
        // Log raid
        this.logWarEvent(
          raidSuccess 
            ? ` Successful raid on ${targetGang.name}. Stole $${result.cashStolen}.`
            : ` Failed raid on ${targetGang.name}. Took ${result.healthDamage}% damage.`
        );
        
        // Warn if fatigued
        if (FatigueSystem.shouldWarnPlayer()) {
          setTimeout(() => {
            const notification = document.createElement('div');
            notification.className = 'xp-notification';
            notification.innerHTML = `<span class="xp-negative"> Your crew is exhausted. Rest recommended.</span>`;
            document.getElementById('app').appendChild(notification);
            setTimeout(() => notification.remove(), 4000);
          }, 500);
        }
        
        // Process retaliation
        if (result.retaliation) {
          setTimeout(() => this.processRetaliation(targetGang), 1000);
        }
        
        this.showRaidResult(targetGang, result);
        Storage.save();
      },
      
      processRetaliation(enemyGang) {
        if (!GameState.gang) return;
        
        const retaliationDamage = Math.floor(Math.random() * 15) + 10; // 10-25%
        const cashStolen = Math.floor(Math.random() * 300) + 100; // $100-400
        
        GameState.gang.health = Math.max(0, GameState.gang.health - retaliationDamage);
        GameState.gang.vault = Math.max(0, GameState.gang.vault - cashStolen);
        
        // Create new pressure: If gang health drops too low, consequences
        if (GameState.gang.health <= 20) {
          // Critical health - lose a property (if any)
          if (GameState.gang.properties.length > 1) { // Keep at least base property
            const lostProperty = GameState.gang.properties.pop();
            GangTab.logWarEvent(` CRITICAL: Lost control of ${lostProperty.name} due to low gang health!`);
          }
          
          // Force defensive posture
          this.showTemporaryNotification(" GANG CRITICAL: Health dangerously low. Avoid conflicts!");
        }
        
        // Check if this pushes gang into defeat state
        if (GameState.gang.health <= 0) {
          this.triggerGangDefeat(enemyGang);
        } else {
          this.logWarEvent(` ${enemyGang.name} retaliated! Lost $${cashStolen} and took ${retaliationDamage}% damage.`);
          
          // Show notification
          const notification = document.createElement('div');
          notification.className = 'xp-notification';
          notification.innerHTML = `<span class="xp-negative"> Retaliation from ${enemyGang.name}!</span>`;
          document.getElementById('app').appendChild(notification);
          setTimeout(() => notification.remove(), 4000);
        }
        
        // Refresh gang tab if active
        if (GameState.ui.activeTab === 'gang') {
          this.render();
        }
        
        Storage.save();
      },
      
      showRaidResult(targetGang, result) {
        const modal = document.createElement('div');
        modal.className = 'event-modal';
        modal.id = 'raid-result-modal';
        
        modal.innerHTML = `
          <div class="event-modal-content">
            <div class="raid-result">
              <div class="raid-result-icon">${result.success ? '' : ''}</div>
              <div class="raid-result-title">${result.success ? 'Raid Successful!' : 'Raid Failed'}</div>
              <div class="raid-result-description">
                ${result.success 
                  ? `Your gang successfully raided ${targetGang.name} and got away with cash.`
                  : `The raid on ${targetGang.name} went wrong. Your gang took damage.`}
              </div>
              
              <div class="raid-result-rewards">
                ${result.success 
                  ? `<div class="reward-item">
                      <span class="reward-label">Cash Stolen</span>
                      <span class="reward-value reward-positive">+$${result.cashStolen}</span>
                    </div>
                    <div class="reward-item">
                      <span class="reward-label">Enemy Damage</span>
                      <span class="reward-value reward-positive">-${result.healthDamage}% HP</span>
                    </div>`
                  : `<div class="reward-item">
                      <span class="reward-label">Gang Damage</span>
                      <span class="reward-value reward-negative">-${result.healthDamage}% HP</span>
                    </div>`}
                <div class="reward-item">
                  <span class="reward-label">Heat Gained</span>
                  <span class="reward-value reward-negative">+${result.heatGain}%</span>
                </div>
                ${result.retaliation 
                  ? `<div class="reward-item">
                      <span class="reward-label">Warning</span>
                      <span class="reward-value reward-negative"> Retaliation Incoming</span>
                    </div>`
                  : ''}
              </div>
              
              <button class="outcome-btn" id="close-raid-result">Continue</button>
            </div>
          </div>
        `;
        
        document.getElementById('app').appendChild(modal);
        
        document.getElementById('close-raid-result')?.addEventListener('click', () => {
          modal.remove();
          this.render(); // Refresh gang display
        });
      },
      
      logWarEvent(message) {
        GameState.gangWarLog.push({
          message: message,
          timestamp: Date.now()
        });
        
        // Keep only last 50 events
        if (GameState.gangWarLog.length > 50) {
          GameState.gangWarLog = GameState.gangWarLog.slice(-50);
        }
      },
      
      triggerGangDefeat(defeatingGang) {
        console.log(`Gang defeated by ${defeatingGang.name}`);
        
        // Gang defeat consequences (NOT game over)
        const defeatPenalties = {
          vaultLoss: GameState.gang.vault,
          propertyLoss: GameState.gang.properties.length,
          timestamp: Date.now()
        };
        
        // 1. Lose all vault money
        GameState.gang.vault = 0;
        
        // 2. Lose all properties except base safe house
        const keptProperties = GameState.gang.properties.filter(p => p.id === 'safehouse_base');
        GameState.gang.properties = keptProperties;
        
        // 3. Gang health reduced to 25% (not destroyed)
        GameState.gang.health = 25;
        
        // 4. All wars end (forced peace)
        Object.keys(GameState.gangRelations).forEach(gangId => {
          const relation = GameState.gangRelations[gangId];
          relation.status = 'neutral';
          relation.heat = 0;
          relation.warStarted = null;
        });
        
        // Log defeat
        this.logWarEvent(` DEFEATED by ${defeatingGang.name}! Gang severely weakened but survives.`);
        
        // Show defeat modal (not game over)
        this.showGangDefeatModal(defeatingGang, defeatPenalties);
        
        Storage.save();
      },
      
      showGangDefeatModal(defeatingGang, penalties) {
        const modal = document.createElement('div');
        modal.className = 'event-modal';
        modal.id = 'defeat-modal';
        
        modal.innerHTML = `
          <div class="event-modal-content">
            <div class="raid-result">
              <div class="raid-result-icon"></div>
              <div class="raid-result-title" style="color: #f28b82;">Gang Defeated</div>
              <div class="raid-result-description">
                ${defeatingGang.name} has crushed your gang. You've lost territory and resources, but your core remains. Rebuild from the ashes.
              </div>
              
              <div class="raid-result-rewards">
                <div class="reward-item">
                  <span class="reward-label">Vault Lost</span>
                  <span class="reward-value reward-negative">-$${penalties.vaultLoss}</span>
                </div>
                <div class="reward-item">
                  <span class="reward-label">Properties Lost</span>
                  <span class="reward-value reward-negative">-${penalties.propertyLoss} locations</span>
                </div>
                <div class="reward-item">
                  <span class="reward-label">Gang Health</span>
                  <span class="reward-value reward-warning">25% remaining</span>
                </div>
                <div class="reward-item">
                  <span class="reward-label">Wars Ended</span>
                  <span class="reward-value" style="color: #8ab4f8;">Forced peace</span>
                </div>
              </div>
              
              <div style="margin: 16px 0; padding: 12px; background: rgba(138, 180, 248, 0.1); border-radius: 4px; font-size: 12px; opacity: 0.9;">
                 You can rebuild: Recruit members, earn money, and reclaim territory. Your gang survives.
              </div>
              
              <button class="outcome-btn" id="close-defeat-modal">Rebuild</button>
            </div>
          </div>
        `;
        
        document.getElementById('app').appendChild(modal);
        
        document.getElementById('close-defeat-modal')?.addEventListener('click', () => {
          modal.remove();
          
          // Force player to safe house
          const safeHouse = GameState.mapIcons.find(i => i.type === 'safeHouse');
          if (safeHouse) {
            GameState.character.position = { x: safeHouse.x, y: safeHouse.y };
          }
          
          // Force laying low
          GameState.playerStatus = 'laying_low';
          GameState.character.freeRoam = false;
          
          TurfTab.updateStatusButtons();
          TurfTab.updateStatusIndicator();
          TurfTab.renderCharacter();
          this.render();
        });
      },
      
      startRelationHeatDecay() {
        // Decay heat by 1% every 30 seconds for neutral relations
        this.heatDecayInterval = setInterval(() => {
          Object.keys(GameState.gangRelations).forEach(gangId => {
            const relation = GameState.gangRelations[gangId];
            
            if (relation.status === 'neutral' && relation.heat > 0) {
              relation.heat = Math.max(0, relation.heat - 1);
            }
            
            // End war if heat drops below 25%
            if (relation.status === 'war' && relation.heat < 25) {
              relation.status = 'neutral';
              relation.warStarted = null;
              const gang = GameState.publicGangs.find(g => g.id === gangId);
              if (gang) {
                this.logWarEvent(` Peace restored with ${gang.name}.`);
              }
            }
          });
          
          // Refresh if gang tab is active
          if (GameState.ui.activeTab === 'gang' && GameState.gang) {
            this.render();
          }
          
          Storage.save();
        }, 30000); // Every 30 seconds
      },
      
      startPropertyIncome() {
        // Collect property income every 60 seconds
        this.propertyIncomeInterval = setInterval(() => {
          if (GameState.gang && GameState.gang.properties.length > 0) {
            const now = Date.now();
            let totalIncome = 0;
            
            GameState.gang.properties.forEach(prop => {
              const minutesElapsed = (now - prop.lastCollected) / 60000;
              const income = Math.floor(prop.income * minutesElapsed);
              
              if (income > 0) {
                totalIncome += income;
                prop.lastCollected = now;
              }
            });
            
            if (totalIncome > 0) {
              GameState.gang.vault += totalIncome;
              console.log(`Property income collected: $${totalIncome}`);
              
              // Update gang tab if active
              if (GameState.ui.activeTab === 'gang') {
                this.render();
              }
              
              Storage.save();
            }
          }
        }, 60000); // Check every minute
      }
    };

    // ========================================
    // APP: Initialize
    // ========================================
    async function init() {
      console.log('=== Crime RPG Initialization ===');
      console.log(' INIT FUNCTION STARTED');
      
      // Load Firebase first
      console.log(' Attempting to load Firebase...');
      try {
        await loadFirebase();
        console.log(' Firebase loaded successfully');
      } catch (error) {
        console.error(' Failed to load Firebase:', error);
        console.log(' Continuing without Firebase...');
      }
      
      // Check authentication state FIRST
      console.log(' Checking authentication state...');
      const authState = AuthManager.getAuthState();
      
      if (!authState.isLoggedIn) {
        console.log(' User not logged in - showing login screen');
        AuthManager.showLoginScreen();
        return;
      }
      
      console.log(' User is logged in:', authState.activeUserId);
      
      // PHASE B: Execute boot flow
      console.log(' Executing boot flow...');
      const canProceed = await BootFlow.executeBoot();
      
      if (!canProceed) {
        console.log(' Waiting for account creation/sign-in...');
        return; // User needs to create account or sign in
      }
      
      // User is authenticated, proceed with game initialization
      console.log(' Boot flow complete - initializing game...');
      initializeGame();
    }
    
    function initializeGame() {
      console.log('=== [DEBUG] initializeGame() called ===');
      
      console.log('[DEBUG] Loading storage...');
      Storage.load();
      
      console.log('[DEBUG] Initializing map icons...');
      initializeMapIcons(); // After load, so it doesn't get overwritten
      
      console.log('[DEBUG] Initializing Firebase leaderboard listener...');
      // Initialize Firebase real-time listener
      GlobalLeaderboard.initFirebaseListener();
      
      console.log('[DEBUG] Initializing map seed...');
      // PHASE 7.4A: Initialize map seed for procedural generation
      initMapSeed();
      
      console.log('[DEBUG] Initializing procedural map...');
      // PHASE 7.4B: Initialize procedural tile grid and biomes
      initProceduralMap();
      
      console.log('[DEBUG] Initializing procedural landmarks...');
      // PHASE 7.4C: Initialize procedural landmark placement
      initProceduralLandmarks();
      
      console.log('[DEBUG] Initializing roads and buildings...');
      // PHASE 7.5: Initialize roads and buildings
      initRoadsAndBuildings();
      
      console.log('[DEBUG] Initializing enhanced procedural landmarks...');
      // PHASE 7.6: Apply enhanced landmark placement (replaces 7.4C for new accounts)
      initEnhancedProceduralLandmarks();
      
      console.log('[DEBUG] Initializing tab system...');
      TabSystem.init();
      
      console.log('[DEBUG] Initializing tab-specific listeners...');
      // Initialize tab-specific listeners
      TurfTab.init();
      SafeHouseTab.init();
      GangTab.init();
      
      console.log('[DEBUG] Rendering active tab...');
      // Render active tab
      const activeTab = GameState.ui.activeTab;
      TabSystem.renderActiveTab(activeTab);
      
      console.log("Crime RPG - Account System Active");
      console.log("Account ID:", GameState.accountId);
      console.log("Player Name:", GameState.player.name);
      console.log("Game State:", GameState);
      console.log("Player Status:", GameState.playerStatus);
      console.log("Status Transition:", GameState.playerStatusTransition);
      console.log("Player Suspicion:", GameState.player.suspicion);
      console.log("Player Fatigue:", GameState.player.fatigue.level.toFixed(1), `(${FatigueSystem.getFatigueLevel()})`);
      console.log("Fatigue Consecutive Actions:", GameState.player.fatigue.consecutiveActions);
      console.log("Map Memory System Active");
      console.log("Active Hotspots:", GameState.mapMemory.hotspots.length);
      console.log("Interactive Buildings:", GameState.map.buildings ? GameState.map.buildings.length : 0);
      console.log("Failure Continuation System Active");
      console.log("Player History Events:", GameState.player.history.length);
      console.log("Crimes System Active");
      console.log("Available Crimes:", CrimesSystem.getAvailableCrimes().length);
      console.log("Total Crimes Defined:", Object.keys(CrimesDatabase.crimes).length);
      console.log("Crime Categories:", Object.keys(CrimesDatabase.categories).length);
      console.log("CrimesTab render function exists:", typeof CrimesTab.render === 'function');
      console.log("World Tick:", GameState.cityState.worldTick);
      console.log("Risk Level:", GameState.cityState.riskLevel);
      console.log("RNG Fairness System Active");
      console.log("Event Outcomes Memory:", GameState.player.rngMemory.eventOutcomes.length);
      console.log("Raid Outcomes Memory:", GameState.player.rngMemory.raidOutcomes.length);
      console.log("Character Appearance:", GameState.character.appearance);
      console.log("Equipped Wardrobe:", GameState.character.equippedWardrobe);
      console.log("Free Roam Active:", GameState.character.freeRoam);
      console.log("Player Cash:", GameState.player.cash);
      console.log("Player XP:", GameState.player.xp);
      console.log("Player Heat:", GameState.player.heat);
      console.log("Global Heat:", GameState.player.globalHeat);
      console.log("City State:", GameState.cityState);
      console.log("Jail Status:", GameState.player.jail);
      console.log("Gang:", GameState.gang);
      console.log("Gang Relations:", GameState.gangRelations);
      
      console.log('=== PHASE D: Sign-In Flow - COMPLETE ===');
      console.log('=== PHASE E: Multi-User Support - COMPLETE ===');
      console.log('=== [DEBUG] initializeGame() COMPLETE ===');
      console.log('==========================================');
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (TurfTab.roamInterval) clearInterval(TurfTab.roamInterval);
      if (TurfTab.eventInterval) clearTimeout(TurfTab.eventInterval);
      if (TurfTab.heatDecayInterval) clearInterval(TurfTab.heatDecayInterval);
      if (TurfTab.jailCheckInterval) clearInterval(TurfTab.jailCheckInterval);
      if (TurfTab.globalHeatDecayInterval) clearInterval(TurfTab.globalHeatDecayInterval);
      if (TurfTab.lockdownCheckInterval) clearInterval(TurfTab.lockdownCheckInterval);
      if (TurfTab.manhuntCheckInterval) clearInterval(TurfTab.manhuntCheckInterval);
      if (TurfTab.transitionCheckInterval) clearInterval(TurfTab.transitionCheckInterval);
      if (TurfTab.suspicionBuildInterval) clearInterval(TurfTab.suspicionBuildInterval);
      if (TurfTab.suspicionDecayInterval) clearInterval(TurfTab.suspicionDecayInterval);
      if (TurfTab.suspicionCheckInterval) clearInterval(TurfTab.suspicionCheckInterval);
      if (TurfTab.worldTickInterval) clearInterval(TurfTab.worldTickInterval);
      if (GangTab.propertyIncomeInterval) clearInterval(GangTab.propertyIncomeInterval);
      if (GangTab.heatDecayInterval) clearInterval(GangTab.heatDecayInterval);
    });

    // Boot app when DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>
